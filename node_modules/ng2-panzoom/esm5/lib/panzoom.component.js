/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ElementRef, ViewChild, Input, NgZone } from '@angular/core';
import { PanZoomConfig } from './panzoom-config';
/**
 * @record
 */
function ZoomAnimation() { }
if (false) {
    /** @type {?} */
    ZoomAnimation.prototype.deltaZoomLevel;
    /** @type {?} */
    ZoomAnimation.prototype.panStepFunc;
    /** @type {?} */
    ZoomAnimation.prototype.duration;
    /** @type {?} */
    ZoomAnimation.prototype.progress;
}
/**
 * @record
 */
function Position() { }
if (false) {
    /** @type {?|undefined} */
    Position.prototype.x;
    /** @type {?|undefined} */
    Position.prototype.y;
    /** @type {?|undefined} */
    Position.prototype.length;
}
var PanZoomComponent = /** @class */ (function () {
    function PanZoomComponent(el, zone) {
        var _this = this;
        this.el = el;
        this.zone = zone;
        this.previousPosition = null;
        this.isDragging = false;
        this.panVelocity = null;
        this.animationParams = null;
        // reference to the appropriate getAnimationFrame function for the client browser
        this.lastTick = 0;
        this.isChrome = false;
        this.willChangeNextFrame = true; // used for scaling in Chrome
        this.isMobile = false;
        this.isFirstSync = true;
        this.zoomLevelIsChanging = false;
        this.dragFinishing = false;
        this.dragMouseButton = null;
        //////////////////////////// END OF LIFECYCLE HOOKS ////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        ///////////////////////////////// EVENT HANDLERS ///////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        this.onMouseWheel = (/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            // console.log('PanZoomComponent: OnMouseWheel() event:', event);
            if (!(event && event.pageX && event.pageY)) {
                return;
            }
            // let event = e.event;
            /** @type {?} */
            var deltaY = event.deltaY;
            if (_this.config.zoomOnMouseWheel) {
                // event.preventDefault();
                if (_this.animationParams) {
                    return; // already zooming
                }
                if (!_this.config.invertMouseWheel) {
                    deltaY = -deltaY;
                }
                // console.log('deltaY:', event.deltaY);
                // let sign = event.deltaY / Math.abs(event.deltaY);
                /** @type {?} */
                var clickPoint = {
                    x: event.pageX - _this.jQueryFrameElement.offset().left,
                    y: event.pageY - _this.jQueryFrameElement.offset().top
                };
                _this.lastClickPoint = clickPoint;
                if (_this.config.freeMouseWheel) {
                    // free wheel scroll
                    _this.freeZoom(clickPoint, deltaY);
                }
                else {
                    // let sign = Math.sign(event.deltaY);
                    if (deltaY < 0) {
                        _this.zoomIn(clickPoint);
                    }
                    else if (deltaY > 0) {
                        _this.zoomOut(clickPoint);
                    }
                }
            }
        });
        this.onMousedown = (/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            // console.log('PanZoomComponent: onMousedown()', event);
            /* Check if clicked location is inside element from which
               dragging is prevented. */
            if (_this.config.noDragFromElementClass
                && _this.isParentElement(_this.config.noDragFromElementClass, event.srcElement)) {
                return;
            }
            if (event.button === _this.dragMouseButton || event.type === 'touchstart') {
                event.preventDefault();
                // event.stopPropagation();
                _this.dragFinishing = false;
                _this.panVelocity = null;
                if (_this.config.panOnClickDrag) {
                    _this.previousPosition = {
                        x: event.pageX,
                        y: event.pageY
                    };
                    _this.lastMouseEventTime = event.timeStamp;
                    _this.isDragging = true;
                    _this.model.isPanning = false;
                    if (_this.isMobile) {
                        _this.zone.runOutsideAngular((/**
                         * @return {?}
                         */
                        function () { return document.addEventListener('touchend', _this.onTouchEnd, false); })); // leave this on document
                        _this.zone.runOutsideAngular((/**
                         * @return {?}
                         */
                        function () { return document.addEventListener('touchmove', _this.onTouchMove, { passive: true, capture: false }); })); // leave this on document
                    }
                    else {
                        _this.zone.runOutsideAngular((/**
                         * @return {?}
                         */
                        function () { return document.addEventListener('mousemove', _this.onMouseMove, { passive: true, capture: false }); })); // leave this on document
                        _this.zone.runOutsideAngular((/**
                         * @return {?}
                         */
                        function () { return document.addEventListener('mouseup', _this.onMouseUp); })); // leave this on document
                    }
                }
                return false;
            }
        });
        this.onTouchStart = (/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            // console.log('PanZoomComponent: onTouchStart()', event);
            // console.log('PanZoomComponent: onTouchStart(): touches:', event.touches.length);
            event.preventDefault();
            // event.stopPropagation();
            if (event.touches.length !== 1) {
                // multiple touches, get ready for zooming
                // Calculate x and y distance between touch events
                /** @type {?} */
                var x = event.touches[0].pageX - event.touches[1].pageX;
                /** @type {?} */
                var y = event.touches[0].pageY - event.touches[1].pageY;
                // Calculate length between touch points with pythagoras
                // There is no reason to use Math.pow and Math.sqrt as we
                // only want a relative length and not the exact one.
                _this.previousPosition = {
                    length: x * x + y * y
                };
            }
            _this.onMousedown(event);
        });
        this.onMouseMove = (/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            // console.log('PanZoomComponent: onMouseMove()', event);
            // console.log(`PanZoomComponent: onMouseMove(): event.timeStamp:`, event.timeStamp);
            // timestamp - 10587.879999999132 - milliseconds
            // Called when moving the mouse with the left button down
            // event.preventDefault();
            // event.stopPropagation();
            if (!(event && event.pageX && event.pageY)) {
                return;
            }
            /** @type {?} */
            var now = event.timeStamp;
            /** @type {?} */
            var timeSinceLastMouseEvent = (now - _this.lastMouseEventTime) / 1000;
            // let timeSinceLastMouseEvent = (now - this.lastMouseEventTime);
            _this.lastMouseEventTime = now;
            /** @type {?} */
            var dragDelta = {
                // a representation of how far each coordinate has moved since the last time it was moved
                x: event.pageX - _this.previousPosition.x,
                y: event.pageY - _this.previousPosition.y
            };
            if (_this.config.keepInBounds) {
                /** @type {?} */
                var topLeftCornerView = _this.getViewPosition({ x: 0, y: 0 });
                /** @type {?} */
                var bottomRightCornerView = _this.getViewPosition({ x: _this.contentWidth, y: _this.contentHeight });
                if (topLeftCornerView.x > 0 && dragDelta.x > 0) {
                    dragDelta.x *= Math.min(1, Math.pow(topLeftCornerView.x, -_this.config.keepInBoundsDragPullback));
                }
                if (topLeftCornerView.y > 0 && dragDelta.y > 0) {
                    dragDelta.y *= Math.min(1, Math.pow(topLeftCornerView.y, -_this.config.keepInBoundsDragPullback));
                }
                if (bottomRightCornerView.x < _this.contentWidth && dragDelta.x < 0) {
                    dragDelta.x *= Math.min(1, Math.pow(_this.contentWidth - bottomRightCornerView.x, -_this.config.keepInBoundsDragPullback));
                }
                if (bottomRightCornerView.y < _this.contentHeight && dragDelta.y < 0) {
                    dragDelta.y *= Math.min(1, Math.pow(_this.contentHeight - bottomRightCornerView.y, -_this.config.keepInBoundsDragPullback));
                }
            }
            // now pan the view
            /** @type {?} */
            var delta = {
                x: dragDelta.x || 0,
                y: dragDelta.y || 0
            };
            _this.model.pan.x += delta.x;
            _this.model.pan.y += delta.y;
            _this.syncBaseToModel();
            _this.animationTick(performance.now());
            if (!_this.model.isPanning) {
                // This will improve the performance,
                // because the browser stops evaluating hits against the elements displayed inside the pan zoom view.
                // Besides this, mouse events will not be sent to any other elements,
                // this prevents issues like selecting elements while dragging.
                _this.panzoomOverlayRef.nativeElement.style.display = 'block';
            }
            _this.model.isPanning = true;
            // set these for the animation slow down once drag stops
            // panVelocity is a measurement of speed for x and y coordinates, in pixels per mouse move event.  It is a measure of how fast the mouse is moving
            _this.panVelocity = {
                x: dragDelta.x / timeSinceLastMouseEvent,
                y: dragDelta.y / timeSinceLastMouseEvent
            };
            // console.log(`PanZoomComponent: onMouseMove(): panVelocity:`, this.panVelocity);
            _this.previousPosition = {
                x: event.pageX,
                y: event.pageY
            };
        });
        this.onTouchMove = (/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            // console.log('PanZoomComponent: onTouchMove()');
            // console.log('PanZoomComponent: onTouchMove(): event:', event);
            // event.preventDefault();
            // event.stopPropagation();
            if (event.touches.length === 1) {
                // single touch, emulate mouse move
                _this.onMouseMove(event);
            }
            else {
                // multiple touches, zoom in/out
                // console.log('pinch zooming');
                // Calculate x and y distance between touch events
                /** @type {?} */
                var x = event.touches[0].pageX - event.touches[1].pageX;
                /** @type {?} */
                var y = event.touches[0].pageY - event.touches[1].pageY;
                // Calculate length between touch points with pythagoras
                // There is no reason to use Math.pow and Math.sqrt as we
                // only want a relative length and not the exact one.
                /** @type {?} */
                var length_1 = x * x + y * y;
                // Calculate delta between current position and last position
                /** @type {?} */
                var delta = length_1 - _this.previousPosition.length;
                // Naive hysteresis
                if (Math.abs(delta) < 100) {
                    return;
                }
                // Calculate center between touch points
                /** @type {?} */
                var centerX = event.touches[1].pageX + x / 2;
                /** @type {?} */
                var centerY = event.touches[1].pageY + y / 2;
                // Calculate zoom center
                /** @type {?} */
                var clickPoint = {
                    x: centerX - _this.jQueryFrameElement.offset().left,
                    y: centerY - _this.jQueryFrameElement.offset().top
                };
                _this.lastClickPoint = clickPoint;
                _this.changeZoomLevel(_this.base.zoomLevel + delta * 0.0001, clickPoint);
                // this.freeZoom( clickPoint, delta);
                // Update length for next move event
                _this.previousPosition = {
                    length: length_1
                };
            }
        });
        this.onMouseUp = (/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            // console.log('PanZoomComponent: onMouseup()', event);
            if (event.button !== _this.dragMouseButton) {
                return;
            }
            event.preventDefault();
            // event.stopPropagation();
            /** @type {?} */
            var now = event.timeStamp;
            /** @type {?} */
            var timeSinceLastMouseEvent = (now - _this.lastMouseEventTime) / 1000;
            if (_this.panVelocity && (_this.panVelocity.x !== 0 || _this.panVelocity.y !== 0)) {
                // apply strong initial dampening if the mouse up occured much later than the last mouse move, indicating that the mouse hasn't moved recently
                // TBD - experiment with this formula
                /** @type {?} */
                var initialMultiplier = Math.max(0, -0.2 + Math.pow(timeSinceLastMouseEvent + 1, -4));
                _this.panVelocity.x *= initialMultiplier;
                _this.panVelocity.y *= initialMultiplier;
                _this.dragFinishing = true;
                // console.log(`PanZoomComponent: onMouseUp(): panVelocity:`, this.panVelocity);
                _this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                function () { return _this.animationId = _this.animationFrameFunc(_this.animationTick); }));
            }
            else {
                _this.dragFinishing = false;
                _this.panVelocity = null;
            }
            _this.isDragging = false;
            // this.model.isPanning = false;
            if (_this.isMobile) {
                _this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                function () { return document.removeEventListener('touchend', _this.onTouchEnd); }));
                _this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                function () { return document.removeEventListener('touchmove', _this.onTouchMove, (/** @type {?} */ ({ passive: true, capture: false }))); }));
            }
            else {
                _this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                function () { return document.removeEventListener('mousemove', _this.onMouseMove, (/** @type {?} */ ({ passive: true, capture: false }))); }));
                _this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                function () { return document.removeEventListener('mouseup', _this.onMouseUp, (/** @type {?} */ ({ passive: true }))); }));
            }
            // Set the overlay to non-blocking again:
            _this.panzoomOverlayRef.nativeElement.style.display = 'none';
        });
        this.onTouchEnd = (/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            // console.log('PanZoomComponent: onTouchEnd()');
            _this.onMouseUp(event);
        });
        this.onDblClick = (/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            // console.log('PanZoomComponent: onDblClick()');
            event.preventDefault();
            // event.stopPropagation();
            if (!_this.config.zoomOnDoubleClick) {
                return;
            }
            /** @type {?} */
            var clickPoint = {
                x: event.pageX - _this.jQueryFrameElement.offset().left,
                y: event.pageY - _this.jQueryFrameElement.offset().top
            };
            _this.lastClickPoint = clickPoint;
            _this.zoomIn(clickPoint);
        });
        this.preventDefault = (/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.preventDefault();
        });
        ////////////////////////////////////////////////////////////////////////////////
        ///////////////////////////// END EVENT HANDLERS ///////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        ///////////////////////////// APPLY ANIMATIONS /////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        this.animationTick = (/**
         * @param {?} timestamp
         * @return {?}
         */
        function (timestamp) {
            // console.log('PanZoomComponent: animationTick()');
            // timestamp looks like 76916.963.  The unit is milliseconds and should be accurate to 5 µs (microseconds)
            // console.log('PanZoomComponent: animationTick()');
            // timestamp looks like 76916.963.  The unit is milliseconds and should be accurate to 5 µs (microseconds)
            /** @type {?} */
            var deltaTime = 0;
            if (_this.lastTick !== 0) {
                deltaTime = (timestamp - _this.lastTick); // orig - milliseconds since the last animationTick
            }
            _this.lastTick = timestamp;
            if (_this.animationParams) {
                // when we're running an animation (but not waiting for a released drag to halt)
                // console.log('PanZoomComponent: animationTick(): model is zooming');
                _this.animationParams.progress += Math.abs(deltaTime / _this.animationParams.duration);
                if (_this.animationParams.progress >= 1.0) {
                    // Only when the animation has finished, sync the base to the model.
                    _this.animationParams.progress = 1.0;
                    _this.updateDOM();
                    _this.animationParams = null;
                }
            }
            if (_this.panVelocity && _this.dragFinishing) {
                // This is when we've panned and released the mouse button and the view is "free-floating" until it slows to a halt.  Don't let the while loop fool you - this only applies it for the current frame.
                // Prevent overshooting if delta time is large for some reason. We apply the simple solution of slicing delta time into smaller pieces and applying each one
                if (deltaTime > 0) {
                    deltaTime = deltaTime / 1000;
                }
                while (deltaTime > 0) {
                    /** @type {?} */
                    var dTime = Math.min(.02, deltaTime);
                    deltaTime = deltaTime - dTime;
                    _this.model.pan.x = _this.model.pan.x + _this.panVelocity.x * dTime;
                    _this.panVelocity.x = _this.panVelocity.x * (1 - _this.config.friction * dTime);
                    _this.model.pan.y = _this.model.pan.y + _this.panVelocity.y * dTime;
                    _this.panVelocity.y = _this.panVelocity.y * (1 - _this.config.friction * dTime);
                    /** @type {?} */
                    var speed = _this.length(_this.panVelocity);
                    if (speed < _this.config.haltSpeed) {
                        _this.model.isPanning = false;
                        _this.panVelocity = null;
                        _this.dragFinishing = false;
                        break;
                    }
                }
            }
            if (_this.config.keepInBounds || _this.dragFinishing) {
                // Checks that keepInBounds is set and that the mouse button isn't pressed, and if so, it stops the contents from going out of view
                // console.log('PanZoomComponent: animationTick(): keepInBounds');
                /** @type {?} */
                var topLeftCornerView = _this.getViewPosition({ x: 0, y: 0 });
                /** @type {?} */
                var bottomRightCornerView = _this.getViewPosition({ x: _this.contentWidth, y: _this.contentHeight });
                if (topLeftCornerView.x > 0) {
                    _this.base.pan.x -= _this.config.keepInBoundsRestoreForce * topLeftCornerView.x;
                }
                if (topLeftCornerView.y > 0) {
                    _this.base.pan.y -= _this.config.keepInBoundsRestoreForce * topLeftCornerView.y;
                }
                if (bottomRightCornerView.x < _this.contentWidth) {
                    _this.base.pan.x -= _this.config.keepInBoundsRestoreForce * (bottomRightCornerView.x - _this.contentWidth);
                }
                if (bottomRightCornerView.y < _this.contentHeight) {
                    _this.base.pan.y -= _this.config.keepInBoundsRestoreForce * (bottomRightCornerView.y - _this.contentHeight);
                }
            }
            _this.updateDOM();
            _this.config.modelChanged.next(_this.model);
            if (_this.animationParams || (_this.panVelocity && _this.dragFinishing)) {
                // Are we in an animation?  If so, run the next frame
                if (_this.isChrome && _this.zoomLevelIsChanging) {
                    // run will-change toggle hack on Chrome to trigger re-rasterization
                    // see https://developers.google.com/web/updates/2016/09/re-rastering-composite
                    if (_this.willChangeNextFrame) {
                        ((/** @type {?} */ (_this.acceleratedFrameRef.nativeElement.style))).willChange = 'auto';
                    }
                    else {
                        ((/** @type {?} */ (_this.acceleratedFrameRef.nativeElement.style))).willChange = 'transform';
                    }
                    _this.willChangeNextFrame = !_this.willChangeNextFrame;
                }
                // console.log('calling next tick');
                _this.animationFrameFunc(_this.animationTick); // Call the next animation frame
            }
            else if (_this.panVelocity && !_this.dragFinishing) {
                // we're just mouse-panning the frame.  We don't need another tick
                return;
            }
            else {
                // Animation has ended
                _this.syncBaseToModel();
                _this.scale = _this.getCssScale(_this.base.zoomLevel);
                _this.willChangeNextFrame = true;
                ((/** @type {?} */ (_this.acceleratedFrameRef.nativeElement.style))).willChange = 'transform';
                _this.zoomLevelIsChanging = false;
                _this.lastTick = 0;
            }
        });
    }
    /**
     * @return {?}
     */
    PanZoomComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // console.log('PanZoomComponent: ngOnInit(): initializing PanZoomComponent');
        var _this = this;
        if (this.config.initialZoomToFit) {
            this.base = this.calcZoomToFit(this.config.initialZoomToFit);
        }
        else {
            this.base = {
                zoomLevel: this.config.initialZoomLevel,
                pan: {
                    x: this.config.initialPanX,
                    y: this.config.initialPanY
                }
            };
        }
        this.model = {
            zoomLevel: this.base.zoomLevel,
            isPanning: false,
            // Only true if panning is actually taking place, not just after mousedown
            pan: {
                x: this.base.pan.x,
                y: this.base.pan.y
            }
        };
        this.config.modelChanged.next(this.model);
        // create public API
        this.api = {
            model: this.model,
            config: this.config,
            changeZoomLevel: this.zoomToLevelAndPoint.bind(this),
            zoomIn: this.zoomInToLastClickPoint.bind(this),
            zoomOut: this.zoomOutFromLastClickPoint.bind(this),
            zoomToFit: this.zoomToFit.bind(this),
            resetView: this.resetView.bind(this),
            getViewPosition: this.getViewPosition.bind(this),
            getModelPosition: this.getModelPosition.bind(this),
            panToPoint: this.panToPoint.bind(this),
            panDelta: this.panDelta.bind(this),
            panDeltaPercent: this.panDeltaPercent.bind(this),
            panDeltaAbsolute: this.panDeltaAbsolute.bind(this)
        };
        this.config.api.next(this.api);
        if (this.config.freeMouseWheel) {
            this.scale = this.getCssScale(this.config.initialZoomLevel);
            /** @type {?} */
            var maxZoomLevel = this.config.zoomLevels - 1;
            this.maxScale = this.getCssScale(maxZoomLevel);
            this.minScale = this.getCssScale(0);
        }
        this.minimumAllowedZoomLevel = 0;
        if (this.config.keepInBounds) {
            this.minimumAllowedZoomLevel = this.config.neutralZoomLevel;
            this.minScale = this.getCssScale(this.config.neutralZoomLevel);
        }
        this.acceleratedFrameRef = this.zoomElementRef;
        // console.log('frameHeight:', this.frameHeight);
        // console.log('frameWidth:', this.frameWidth);
        ((/** @type {?} */ (this.acceleratedFrameRef.nativeElement.style))).willChange = 'transform';
        if (navigator.userAgent.search('Chrome') >= 0) {
            this.isChrome = true;
            this.acceleratedFrameRef.nativeElement.style.transform = 'translateZ(0)';
        }
        this.animationTick(performance.now());
        this.scale = this.getCssScale(this.base.zoomLevel);
        this.isFirstSync = false;
        switch (this.config.dragMouseButton) {
            case 'left':
                this.dragMouseButton = 0;
                break;
            case 'middle':
                this.dragMouseButton = 1;
                this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                function () { return _this.frameElementRef.nativeElement.addEventListener('auxclick', _this.preventDefault); }));
                break;
            case 'right':
                this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                function () { return document.addEventListener('contextmenu', _this.preventDefault); }));
                this.dragMouseButton = 2;
                break;
            default:
                this.dragMouseButton = 0; // left
        }
    };
    /**
     * @return {?}
     */
    PanZoomComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        // console.log('PanZoomComponent: ngAfterViewInit()');
        var _this = this;
        this.jQueryFrameElement = $('.pan-zoom-frame');
        this.contentHeight = $('.zoomElement').children().height();
        this.contentWidth = $('.zoomElement').children().width();
        this.frameHeight = this.jQueryFrameElement.height();
        this.frameWidth = this.jQueryFrameElement.width();
        this.zone.runOutsideAngular((/**
         * @return {?}
         */
        function () { return _this.animationFrameFunc = window.requestAnimationFrame; }));
        // this.zone.runOutsideAngular( () => this.wheelAnimationFrameFunc = window.requestAnimationFrame );
        if (this.isMobileDevice()) {
            this.isMobile = true;
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            function () { return _this.frameElementRef.nativeElement.addEventListener('touchstart', _this.onTouchStart); }));
        }
        else {
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            function () { return _this.frameElementRef.nativeElement.addEventListener('mousedown', _this.onMousedown); }));
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            function () { return _this.frameElementRef.nativeElement.addEventListener('dblclick', _this.onDblClick); }));
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            function () { return _this.frameElementRef.nativeElement.addEventListener('wheel', (/**
             * @param {?} event
             * @return {?}
             */
            function (event) { return _this.animationFrameFunc((/**
             * @return {?}
             */
            function () { return _this.onMouseWheel(event); })); }), { passive: true }); }));
        }
    };
    /**
     * @return {?}
     */
    PanZoomComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // console.log('PanZoomComponent: ngOnDestroy()');
        if (this.isMobile) {
            this.frameElementRef.nativeElement.removeEventListener('touchstart', this.onTouchStart);
        }
        else {
            this.frameElementRef.nativeElement.removeEventListener('mousedown', this.onMousedown);
            this.frameElementRef.nativeElement.removeEventListener('wheel', (/**
             * @param {?} event
             * @return {?}
             */
            function (event) { return _this.animationFrameFunc((/**
             * @return {?}
             */
            function () { return _this.onMouseWheel(event); })); }), { passive: true });
            this.frameElementRef.nativeElement.removeEventListener('dblclick', this.onDblClick);
        }
        if (this.animationFrameFunc && this.animationId) {
            window.cancelAnimationFrame(this.animationId);
        }
        switch (this.config.dragMouseButton) {
            case 'middle':
                this.dragMouseButton = 1;
                this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                function () { return _this.frameElementRef.nativeElement.removeEventListener('auxclick', _this.preventDefault); }));
                break;
            case 'right':
                this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                function () { return document.removeEventListener('contextmenu', _this.preventDefault); }));
                this.dragMouseButton = 2;
                break;
        }
    };
    /**
     * Method will check if 'child' node element is a child of
     * parent node with class 'className'
     * @param className
     * @param child
     */
    /**
     * Method will check if 'child' node element is a child of
     * parent node with class 'className'
     * @private
     * @param {?} className
     * @param {?} child
     * @return {?}
     */
    PanZoomComponent.prototype.isParentElement = /**
     * Method will check if 'child' node element is a child of
     * parent node with class 'className'
     * @private
     * @param {?} className
     * @param {?} child
     * @return {?}
     */
    function (className, child) {
        /** @type {?} */
        var node = child.parentNode;
        while (node != null) {
            if (node.classList && node.classList.contains(className)) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    };
    /**
     * @private
     * @return {?}
     */
    PanZoomComponent.prototype.updateDOM = /**
     * @private
     * @return {?}
     */
    function () {
        // console.log('PanZoomComponent: updateDOM()');
        // Called by ngAfterViewInit() and animationTick()
        // This function does not get called by freeZoom(), which operates independently of animationTick() and updateDOM().
        if (this.animationParams) {
            // we're running an animation sequence (but not freeZooming or panning with onMouseMove() )
            this.model.zoomLevel = this.base.zoomLevel + this.animationParams.deltaZoomLevel * this.animationParams.progress; // calculate how far we need to zoom in or out for the current animationTick
            // calculate how far we need to zoom in or out for the current animationTick
            /** @type {?} */
            var deltaTranslation = this.animationParams.panStepFunc(this.model.zoomLevel);
            // sync the model pan coordinates to our translated pan coordinates
            // we do this by adding how far we want to move in each direction to our our existing base pan coordinates (where we started)
            this.model.pan.x = this.base.pan.x + deltaTranslation.x;
            this.model.pan.y = this.base.pan.y + deltaTranslation.y;
            if (this.config.keepInBounds) {
                /** @type {?} */
                var topLeftCornerView = this.getViewPosition({ x: 0, y: 0 });
                /** @type {?} */
                var bottomRightCornerView = this.getViewPosition({ x: this.contentWidth, y: this.contentHeight });
                if (topLeftCornerView.x > 0) {
                    this.model.pan.x = 0;
                }
                if (topLeftCornerView.y > 0) {
                    this.model.pan.y = 0;
                }
                if (bottomRightCornerView.x < this.contentWidth) {
                    this.model.pan.x -= (bottomRightCornerView.x - this.contentWidth);
                }
                if (bottomRightCornerView.y < this.contentHeight) {
                    this.model.pan.y -= (bottomRightCornerView.y - this.contentHeight);
                }
            }
        }
        ////////////////////////////////////////////////////
        //////////////////// APPLY SCALING /////////////////
        ////////////////////////////////////////////////////
        if (this.animationParams || this.isFirstSync) {
            /** @type {?} */
            var scale = this.getCssScale(this.model.zoomLevel);
            /** @type {?} */
            var scaleString = "scale(" + scale + ")";
            this.zoomElementRef.nativeElement.style.transformOrigin = '0 0';
            this.zoomElementRef.nativeElement.style.transform = scaleString;
        }
        ////////////////////////////////////////////////////
        //////////////// APPLY PAN ANIMATION ///////////////
        ////////////////////////////////////////////////////
        /** @type {?} */
        var translate3d = "translate3d(" + this.model.pan.x + "px, " + this.model.pan.y + "px, 0)";
        this.panElementRef.nativeElement.style.transform = translate3d;
    };
    /**
     * @private
     * @param {?} clickPoint
     * @param {?} wheelDelta
     * @return {?}
     */
    PanZoomComponent.prototype.freeZoom = /**
     * @private
     * @param {?} clickPoint
     * @param {?} wheelDelta
     * @return {?}
     */
    function (clickPoint, wheelDelta) {
        // console.log('PanZoomComponent: freeZoom(): this.base:', this.base);
        if (this.isDragging) {
            // don't allow zooming if the mouse is down
            return;
        }
        // now handle interruption of an in-progress animation
        if (this.animationParams) {
            this.animationParams = null; // cancel an existing animation
        }
        if (this.panVelocity) {
            this.dragFinishing = false;
            this.panVelocity = null;
        }
        /** @type {?} */
        var currentPan = {
            // the current base coordinates
            x: this.base.pan.x,
            y: this.base.pan.y
        };
        // !!!something, somewhere is potentially invalidating the base pan!!!
        /** @type {?} */
        var currentScale = this.scale;
        // get the current CSS scale (scale0)
        /** @type {?} */
        var newScale = this.scale + (wheelDelta * this.config.freeMouseWheelFactor * this.scale);
        // takes either the minimum scale (furthest allowable zoomed out) or the calculated current scale, whichever is greater, unless calculated current scale exceeds maxScale (furthest allowable zoomed in), in which case maxScale is used
        newScale = Math.max(this.minScale, Math.min(this.maxScale, newScale));
        this.scale = newScale;
        /** @type {?} */
        var targetPoint = {
            // The target point to zoom to.  It must stay the same as the untranslated point
            x: clickPoint.x - (newScale / currentScale) * (clickPoint.x - currentPan.x),
            y: clickPoint.y - (newScale / currentScale) * (clickPoint.y - currentPan.y)
        };
        // Apply Pan & Scale
        /** @type {?} */
        var translate3d = "translate3d(" + targetPoint.x + "px, " + targetPoint.y + "px, 0)";
        this.panElementRef.nativeElement.style.transform = translate3d;
        /** @type {?} */
        var scaleString = "scale(" + this.scale + ")";
        this.zoomElementRef.nativeElement.style.transformOrigin = '0 0';
        this.zoomElementRef.nativeElement.style.transform = scaleString;
        if (this.isChrome) {
            if (this.willChangeNextFrame) {
                ((/** @type {?} */ (this.acceleratedFrameRef.nativeElement.style))).willChange = 'auto';
            }
            else {
                ((/** @type {?} */ (this.acceleratedFrameRef.nativeElement.style))).willChange = 'transform';
            }
            this.willChangeNextFrame = !this.willChangeNextFrame;
        }
        this.model.pan.x = targetPoint.x;
        this.model.pan.y = targetPoint.y;
        this.model.zoomLevel = this.getZoomLevel(this.scale);
        this.syncBaseToModel();
        this.config.modelChanged.next(this.model);
        // console.log(`PanZoomComponent: freeZoom(): baseAfterZoom: x: ${this.base.pan.x} y: ${this.base.pan.y} zoomlevel: ${this.base.zoomLevel}` );
        // console.log('zoomLevel:', this.base.zoomLevel);
    };
    ////////////////////////////////////////////////////
    //////////////// HELPER FUNCTIONS //////////////////
    ////////////////////////////////////////////////////
    ////////////////////////////////////////////////////
    //////////////// HELPER FUNCTIONS //////////////////
    ////////////////////////////////////////////////////
    /**
     * @private
     * @return {?}
     */
    PanZoomComponent.prototype.isMobileDevice = 
    ////////////////////////////////////////////////////
    //////////////// HELPER FUNCTIONS //////////////////
    ////////////////////////////////////////////////////
    /**
     * @private
     * @return {?}
     */
    function () {
        return (typeof window.orientation !== 'undefined') || (navigator.userAgent.indexOf('IEMobile') !== -1);
    };
    /**
     * @private
     * @return {?}
     */
    PanZoomComponent.prototype.syncBaseToModel = /**
     * @private
     * @return {?}
     */
    function () {
        this.base.pan.x = this.model.pan.x;
        this.base.pan.y = this.model.pan.y;
        this.base.zoomLevel = this.model.zoomLevel;
    };
    /**
     * @private
     * @param {?} vector2d
     * @return {?}
     */
    PanZoomComponent.prototype.length = /**
     * @private
     * @param {?} vector2d
     * @return {?}
     */
    function (vector2d) {
        // console.log('PanZoomComponent: length()');
        return Math.sqrt(vector2d.x * vector2d.x + vector2d.y * vector2d.y);
    };
    /**
     * @private
     * @return {?}
     */
    PanZoomComponent.prototype.getCenterPoint = /**
     * @private
     * @return {?}
     */
    function () {
        // console.log('PanZoomComponent: getCenterPoint()');
        // console.log('PanZoomComponent: getCenterPoint(): projectedContentRef:', this.projectedContentRef);
        /** @type {?} */
        var center = {
            // x: this.jQueryFrameElement.width() / 2,
            x: this.frameElementRef.nativeElement.offsetWidth / 2,
            // x: this.projectedContentRef.nativeElement.offsetWidth / 2,
            // y: this.jQueryFrameElement.height() / 2
            y: this.frameElementRef.nativeElement.offsetHeight / 2
            // y: this.projectedContentRef.nativeElement.offsetHeight / 2
        };
        return center;
    };
    /**
     * @private
     * @param {?} zoomLevel
     * @return {?}
     */
    PanZoomComponent.prototype.getCssScale = /**
     * @private
     * @param {?} zoomLevel
     * @return {?}
     */
    function (zoomLevel) {
        // console.log('PanZoomComponent: getCssScale()');
        return Math.pow(this.config.scalePerZoomLevel, zoomLevel - this.config.neutralZoomLevel);
    };
    /**
     * @private
     * @param {?} cssScale
     * @return {?}
     */
    PanZoomComponent.prototype.getZoomLevel = /**
     * @private
     * @param {?} cssScale
     * @return {?}
     */
    function (cssScale) {
        // console.log('PanZoomComponent: getZoomLevel()');
        return Math.log10(cssScale) / Math.log10(this.config.scalePerZoomLevel) + this.config.neutralZoomLevel;
    };
    /**
     * @private
     * @param {?} rect
     * @return {?}
     */
    PanZoomComponent.prototype.calcZoomToFit = /**
     * @private
     * @param {?} rect
     * @return {?}
     */
    function (rect) {
        // console.log('PanZoomComponent: calcZoomToFit(): rect:', rect);
        // let (W, H) denote the size of the viewport
        // let (w, h) denote the size of the rectangle to zoom to
        // then we must CSS scale by the min of W/w and H/h in order to just fit the rectangle
        // returns the target left and top coordinates for the panElement and target zoomLevel
        // console.log('PanZoomComponent: calcZoomToFit(): rect:', rect);
        // let (W, H) denote the size of the viewport
        // let (w, h) denote the size of the rectangle to zoom to
        // then we must CSS scale by the min of W/w and H/h in order to just fit the rectangle
        // returns the target left and top coordinates for the panElement and target zoomLevel
        /** @type {?} */
        var viewportWidth = this.frameElementRef.nativeElement.offsetWidth;
        /** @type {?} */
        var viewportHeight = this.frameElementRef.nativeElement.offsetHeight;
        /** @type {?} */
        var targetWidth = rect.width;
        /** @type {?} */
        var targetHeight = rect.height;
        /** @type {?} */
        var cssScaleExact = Math.min(viewportWidth / targetWidth, viewportHeight / targetHeight);
        /** @type {?} */
        var zoomLevelExact = this.getZoomLevel(cssScaleExact);
        /** @type {?} */
        var zoomLevel = zoomLevelExact * this.config.zoomToFitZoomLevelFactor;
        /** @type {?} */
        var cssScale = this.getCssScale(zoomLevel);
        return {
            zoomLevel: zoomLevel,
            pan: {
                x: -rect.x * cssScale + (viewportWidth - targetWidth * cssScale) / 2,
                y: -rect.y * cssScale + (viewportHeight - targetHeight * cssScale) / 2
            }
        };
    };
    /**
     * @private
     * @param {?} target
     * @param {?=} duration
     * @return {?}
     */
    PanZoomComponent.prototype.zoomToFitModel = /**
     * @private
     * @param {?} target
     * @param {?=} duration
     * @return {?}
     */
    function (target, duration) {
        // console.log('PanZoomComponent: zoomToFitModel(): target:', target);
        if (duration === void 0) { duration = null; }
        // target.pan.x is the panElement left style property
        // target.pan.y is the panElement top style property
        this.animateToTarget(target, duration);
    };
    /**
     * @private
     * @param {?} level
     * @param {?} clickPoint
     * @return {?}
     */
    PanZoomComponent.prototype.zoomToLevelAndPoint = /**
     * @private
     * @param {?} level
     * @param {?} clickPoint
     * @return {?}
     */
    function (level, clickPoint) {
        // console.log('PanZoomComponent: zoomToLevelAndPoint(): level:', level);
        // console.log('PanZoomComponent: zoomToLevelAndPoint(): clickPoint:', clickPoint);
        this.changeZoomLevel(level, clickPoint);
    };
    /**
     * @private
     * @return {?}
     */
    PanZoomComponent.prototype.zoomInToLastClickPoint = /**
     * @private
     * @return {?}
     */
    function () {
        // console.log('PanZoomComponent: zoomInToLastClickPoint(): lastClickPoint', this.lastClickPoint);
        this.changeZoomLevel(this.base.zoomLevel + this.config.zoomButtonIncrement, this.lastClickPoint);
    };
    /**
     * @private
     * @return {?}
     */
    PanZoomComponent.prototype.zoomOutFromLastClickPoint = /**
     * @private
     * @return {?}
     */
    function () {
        // console.log('PanZoomComponent: zoomOutFromLastClickPoint()');
        this.changeZoomLevel(this.base.zoomLevel - this.config.zoomButtonIncrement, this.lastClickPoint);
    };
    /**
     * @private
     * @return {?}
     */
    PanZoomComponent.prototype.startAnimation = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.lastTick = performance.now();
        this.zone.runOutsideAngular((/**
         * @return {?}
         */
        function () { return _this.animationId = _this.animationFrameFunc(_this.animationTick); }));
    };
    ////////////////////////////////////////////////////
    /////////////////// API METHODS ////////////////////
    ////////////////////////////////////////////////////
    ////////////////////////////////////////////////////
    /////////////////// API METHODS ////////////////////
    ////////////////////////////////////////////////////
    /**
     * @private
     * @param {?} modelPosition
     * @return {?}
     */
    PanZoomComponent.prototype.getViewPosition = 
    ////////////////////////////////////////////////////
    /////////////////// API METHODS ////////////////////
    ////////////////////////////////////////////////////
    /**
     * @private
     * @param {?} modelPosition
     * @return {?}
     */
    function (modelPosition) {
        // console.log('PanZoomComponent: getViewPosition()');
        // p' = p * s + t
        // viewPosition = modelPosition * scale + basePan
        // console.log('PanZoomComponent: getViewPosition()');
        // p' = p * s + t
        // viewPosition = modelPosition * scale + basePan
        /** @type {?} */
        var scale;
        /** @type {?} */
        var translation;
        if (this.animationParams) {
            scale = this.getCssScale(this.base.zoomLevel + this.animationParams.deltaZoomLevel * this.animationParams.progress);
            /** @type {?} */
            var deltaTranslation = this.animationParams.panStepFunc(this.model.zoomLevel);
            translation = { x: this.base.pan.x + deltaTranslation.x, y: this.base.pan.y + deltaTranslation.y };
        }
        else {
            scale = this.getCssScale(this.base.zoomLevel);
            translation = this.base.pan;
        }
        return {
            x: modelPosition.x * scale + translation.x,
            y: modelPosition.y * scale + translation.y
        };
    };
    /**
     * @private
     * @param {?} viewPosition
     * @return {?}
     */
    PanZoomComponent.prototype.getModelPosition = /**
     * @private
     * @param {?} viewPosition
     * @return {?}
     */
    function (viewPosition) {
        // console.log('PanZoomComponent: getModelPosition()');
        // p = (1/s)(p' - t)
        /** @type {?} */
        var pmark = viewPosition;
        /** @type {?} */
        var s = this.getCssScale(this.base.zoomLevel);
        /** @type {?} */
        var t = this.base.pan;
        return {
            x: (1 / s) * (pmark.x - t.x),
            y: (1 / s) * (pmark.y - t.y)
        };
    };
    /**
     * @private
     * @return {?}
     */
    PanZoomComponent.prototype.resetView = /**
     * @private
     * @return {?}
     */
    function () {
        // console.log('PanZoomComponent: resetView()');
        if (this.config.initialZoomToFit) {
            this.zoomToFit(this.config.initialZoomToFit);
        }
        else if (this.config.initialPanX !== null && this.config.initialPanY !== null && this.config.initialZoomLevel !== null) {
            this.zoomToFitModel({
                zoomLevel: this.config.initialZoomLevel,
                pan: {
                    x: this.config.initialPanX,
                    y: this.config.initialPanY
                }
            });
        }
        else {
            console.error('PanZoomComponent: resetView() could not reset view as some vars were not set.  The culprits are either config.initialZoomLevel, config.initialPanX, or config.initialPanY.  Or just set panzoomConfig.initialZoomToFit');
            console.log('config.initialZoomLevel: ' + this.config.initialZoomLevel);
            console.log('config.initialPanX: ' + this.config.initialPanX);
            console.log('config.initialPanY: ' + this.config.initialPanY);
        }
    };
    /**
     * @private
     * @param {?} rectangle
     * @param {?=} duration
     * @return {?}
     */
    PanZoomComponent.prototype.zoomToFit = /**
     * @private
     * @param {?} rectangle
     * @param {?=} duration
     * @return {?}
     */
    function (rectangle, duration) {
        // console.log('PanZoomComponent: zoomToFit(): rectangle', rectangle);
        if (duration === void 0) { duration = null; }
        // console.log('PanZoomComponent: zoomToFit(): rectangle', rectangle);
        // when a user clicks a zoom to fit button
        // example rectangle: { "x": 0, "y": 100, "width": 100, "height": 100 }
        /** @type {?} */
        var target = this.calcZoomToFit(rectangle);
        // target.pan.x is the panElement left style property
        // target.pan.y is the panElement top style property
        this.animateToTarget(target, duration);
    };
    /**
     * @private
     * @param {?} clickPoint
     * @return {?}
     */
    PanZoomComponent.prototype.zoomIn = /**
     * @private
     * @param {?} clickPoint
     * @return {?}
     */
    function (clickPoint) {
        // console.log('PanZoomComponent: zoomIn(): clickPoint:', clickPoint);
        this.changeZoomLevel(this.base.zoomLevel + this.config.zoomButtonIncrement, clickPoint);
    };
    /**
     * @private
     * @param {?} clickPoint
     * @return {?}
     */
    PanZoomComponent.prototype.zoomOut = /**
     * @private
     * @param {?} clickPoint
     * @return {?}
     */
    function (clickPoint) {
        // console.log('PanZoomComponent: zoomOut()');
        this.changeZoomLevel(this.base.zoomLevel - this.config.zoomButtonIncrement, clickPoint);
    };
    /**
     * @private
     * @param {?} point
     * @param {?=} duration
     * @return {?}
     */
    PanZoomComponent.prototype.panToPoint = /**
     * @private
     * @param {?} point
     * @param {?=} duration
     * @return {?}
     */
    function (point, duration) {
        // console.log('PanZoomComponent: panToPoint(): point:', point);
        if (duration === void 0) { duration = null; }
        // console.log('PanZoomComponent: panToPoint(): point:', point);
        // API call to animate the view so that the centre point of the view is at the
        // point parameter coordinates, relative to the original, unzoomed
        // content width and height
        // example point: { "x": 0, "y": 0 } // makes the top-left corner of the content
        // the centre of the view
        /** @type {?} */
        var target = {
            pan: {
                x: ((this.frameWidth / 2)) - point.x * this.scale,
                y: ((this.frameHeight / 2)) - point.y * this.scale
            },
            zoomLevel: this.base.zoomLevel
        };
        this.animateToTarget(target, duration);
    };
    /**
     * @private
     * @param {?} delta
     * @param {?=} duration
     * @return {?}
     */
    PanZoomComponent.prototype.panDelta = /**
     * @private
     * @param {?} delta
     * @param {?=} duration
     * @return {?}
     */
    function (delta, duration) {
        // console.log('PanZoomComponent: panDelta(): delta:', delta);
        if (duration === void 0) { duration = null; }
        // console.log('PanZoomComponent: panDelta(): delta:', delta);
        // API call to pan the view left, right, up, or down, based on a number of pixels
        // of the original, unzoomed content.
        // Positive is right and down
        // Negative is left and up
        // example point: { "x": 100, "y": -50 } // moves the view right 50px and up 50px
        /** @type {?} */
        var target = {
            pan: {
                x: this.base.pan.x - this.scale * delta.x,
                y: this.base.pan.y - this.scale * delta.y
            },
            zoomLevel: this.base.zoomLevel
        };
        this.animateToTarget(target, duration);
    };
    /**
     * @private
     * @param {?} delta
     * @param {?=} duration
     * @return {?}
     */
    PanZoomComponent.prototype.panDeltaAbsolute = /**
     * @private
     * @param {?} delta
     * @param {?=} duration
     * @return {?}
     */
    function (delta, duration) {
        // console.log('PanZoomComponent: panDeltaAbsolute(): delta:', delta);
        if (duration === void 0) { duration = null; }
        // console.log('PanZoomComponent: panDeltaAbsolute(): delta:', delta);
        // API call to pan the view left, right, up, or down, based on a number of pixels
        // This method doesn't adjust for scale.  I'm not sure why you'd want this
        // but have it here just in case someone needs it
        // Positive is right and down
        // Negative is left and up
        // example point: { "x": 100, "y": -50 } // moves the view right 50px and up 50px
        /** @type {?} */
        var target = {
            pan: {
                x: this.base.pan.x - delta.x,
                y: this.base.pan.y - delta.y
            },
            zoomLevel: this.base.zoomLevel
        };
        this.animateToTarget(target, duration);
    };
    /**
     * @private
     * @param {?} deltaPercent
     * @param {?=} duration
     * @return {?}
     */
    PanZoomComponent.prototype.panDeltaPercent = /**
     * @private
     * @param {?} deltaPercent
     * @param {?=} duration
     * @return {?}
     */
    function (deltaPercent, duration) {
        // console.log('PanZoomComponent: panDeltaPercent(): deltaPercent:', deltaPercent);
        if (duration === void 0) { duration = null; }
        // console.log('PanZoomComponent: panDeltaPercent(): deltaPercent:', deltaPercent);
        // API call to pan the view up, down, left, or right, based on a percentage
        // of the original, unzoomed content width and height
        // example point: { "x": 10, "y": -20 }
        /** @type {?} */
        var deltaX = 0;
        /** @type {?} */
        var deltaY = 0;
        if (deltaPercent.x !== 0) {
            deltaX = this.contentWidth * (deltaPercent.x / 100) * this.scale;
        }
        if (deltaPercent.y !== 0) {
            deltaY = this.contentHeight * (deltaPercent.y / 100) * this.scale;
        }
        /** @type {?} */
        var target = {
            pan: {
                x: this.base.pan.x - deltaX,
                y: this.base.pan.y - deltaY
            },
            zoomLevel: this.base.zoomLevel
        };
        // target.pan.x is the panElement left style property
        // target.pan.y is the panElement top style property
        this.animateToTarget(target, duration);
    };
    ////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////// ANIMATION BUILDERS ///////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////// ANIMATION BUILDERS ///////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @private
     * @param {?} targetModel
     * @param {?=} duration
     * @return {?}
     */
    PanZoomComponent.prototype.animateToTarget = 
    ////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////// ANIMATION BUILDERS ///////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @private
     * @param {?} targetModel
     * @param {?=} duration
     * @return {?}
     */
    function (targetModel, duration) {
        // console.log('PanZoomComponent: animateToTarget()');
        // what this function really does is take a target model, and then sets
        // this.animationParams with the parameters for the whole animation,
        // namely the delta zoomLevel
        // it is the responsibility of the caller to kick off the animation with a call to animationFrameFunc()
        var _this = this;
        if (duration === void 0) { duration = null; }
        if (this.animationParams) {
            // make the user wait for existing animation to finish before clicking
            return;
        }
        this.zoomLevelIsChanging = false;
        if (this.base.zoomLevel !== targetModel.zoomLevel) {
            this.zoomLevelIsChanging = true;
        }
        /** @type {?} */
        var deltaZoomLevel = targetModel.zoomLevel - this.base.zoomLevel;
        // deltaZoomLevel is the number of zoom levels we are changing here
        /** @type {?} */
        var oldBase = {
            // the current base coordinates
            x: this.base.pan.x,
            y: this.base.pan.y
        };
        this.model.pan.x = this.base.pan.x;
        this.model.pan.y = this.base.pan.y;
        /*this.lastClickPoint = {
              x: this.base.pan.x,
              y: this.base.pan.y
            };*/
        /** @type {?} */
        var panStepFunc = (/**
         * @param {?} zoomLevel
         * @return {?}
         */
        function (zoomLevel) {
            // this function gets called during every animation tick in updateDOM(), to calculate where to move the model pan coordinates to (i.e. the translation) for that tick, zoomLevel is ignored within animateToTarget()
            /** @type {?} */
            var targetPoint = {
                // The target point to zoom to for the current animation frame.  It must stay the same as the untranslated point
                x: (oldBase.x - targetModel.pan.x) * _this.animationParams.progress,
                y: (oldBase.y - targetModel.pan.y) * _this.animationParams.progress
            };
            return { x: -targetPoint.x, y: -targetPoint.y };
        });
        // now set the parameters of our new animation
        if (duration) {
            duration = duration * 1000;
        }
        else {
            duration = this.config.zoomStepDuration * 1000;
        }
        this.animationParams = {
            deltaZoomLevel: deltaZoomLevel,
            // how many zooom levels to zoom in or out
            panStepFunc: panStepFunc,
            // a function which runs on every animation tick, which calcs how much to pan the view on every frame
            // duration: duration || this.config.zoomStepDuration, // how long the animation should take
            duration: duration,
            // how long the animation should take
            progress: 0.0
        };
        this.startAnimation();
    };
    /**
     * @private
     * @param {?} newZoomLevel
     * @param {?} clickPoint
     * @return {?}
     */
    PanZoomComponent.prototype.changeZoomLevel = /**
     * @private
     * @param {?} newZoomLevel
     * @param {?} clickPoint
     * @return {?}
     */
    function (newZoomLevel, clickPoint) {
        // console.log('PanZoomComponent: changeZoomLevel()');
        var _this = this;
        if (this.animationParams) {
            // let's let any current animation just finish
            return;
        }
        this.zoomLevelIsChanging = true;
        // keep zoom level in bounds
        newZoomLevel = Math.max(this.minimumAllowedZoomLevel, newZoomLevel);
        newZoomLevel = Math.min(this.config.zoomLevels - 1, newZoomLevel);
        // console.log('newZoomLevel:', newZoomLevel);
        /** @type {?} */
        var deltaZoomLevel = newZoomLevel - this.base.zoomLevel;
        if (!deltaZoomLevel) {
            // a deltaZoomLevel of zero means that we aren't changing zoom, because we're either zoomed all the way in or all the way out
            return;
        }
        //
        // Let p be the vector to the clicked point in view coords and let p' be the same point in model coords. Let s be a scale factor
        // and let t be a translation vector. Let the transformation be defined as:
        //
        //  p' = p * s + t
        //
        // And conversely:
        //
        //  p = (1/s)(p' - t)
        //
        // Now use subscription 0 to denote the value before transform and zoom and let 1 denote the value after transform. Scale
        // changes from s0 to s1. Translation changes from t0 to t1. But keep p and p' fixed so that the view coordinate p' still
        // corresponds to the model coordinate p. This can be expressed as an equation relying upon solely upon p', s0, s1, t0, and t1:
        //
        //  (1/s0)(p - t0) = (1/s1)(p - t1)
        //
        // Every variable but t1 is known, thus it is easily isolated to:
        //
        //  t1 = p' - (s1/s0)*(p' - t0)
        //
        /** @type {?} */
        var currentPan = {
            // t0 - the current base coordinates
            x: this.base.pan.x,
            y: this.base.pan.y
        };
        /** @type {?} */
        var currentScale = this.scale;
        // s0 - get the current CSS scale (scale0)
        /** @type {?} */
        var destPoint = clickPoint || this.getCenterPoint();
        // pmark - the point we are aiming to zoom to (either the click point or the centre of the page)
        /** @type {?} */
        var panStepFunc = (/**
         * @param {?} zoomLevel
         * @return {?}
         */
        function (zoomLevel) {
            // this function gets called during every animation tick, to calculate where to move the model pan coordinates to (i.e. the translation) for that tick, where zoomLevel is calculated from the current zoomLevel + the target zoomLevel * the progress of the current animation
            // this function gets called during every animation tick, to calculate where to move the model pan coordinates to (i.e. the translation) for that tick, where zoomLevel is calculated from the current zoomLevel + the target zoomLevel * the progress of the current animation
            /** @type {?} */
            var targetScale = _this.getCssScale(zoomLevel);
            // s1 - the scale to translate to for the current animation tick
            /** @type {?} */
            var targetPoint = {
                // t1 - The target point to pan to.  It must stay the same as the untranslated point
                x: destPoint.x - (targetScale / currentScale) * (destPoint.x - currentPan.x),
                y: destPoint.y - (targetScale / currentScale) * (destPoint.y - currentPan.y)
            };
            return {
                // now return the difference between our initial click point and our translated (zoomed) click point
                // these are not absolute coordinates - just how far to move them
                x: targetPoint.x - currentPan.x,
                y: targetPoint.y - currentPan.y
            };
        });
        // now set the parameters of our new animation
        this.animationParams = {
            deltaZoomLevel: deltaZoomLevel,
            // the destination zoom level for this zoom operation (when the animation is completed)
            panStepFunc: panStepFunc,
            // duration: this.config.zoomStepDuration, // how long the animation should take
            duration: this.config.zoomStepDuration * 1000,
            // how long the animation should take
            progress: 0.0
        };
        this.startAnimation();
    };
    PanZoomComponent.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:component-selector
                    selector: 'pan-zoom',
                    // we don't want to kill change detection for all elements beneath this, so we don't set OnPush.  Child views can implement OnPush if the developer wants to.  We can get away with this because the kwheel directive runs outside of Angular, so it doesnt trigger change detection.
                    template: "\n<div #frameElement class=\"pan-zoom-frame\" style=\"position:relative; width: 100%; height: 100%; overflow: hidden;\">\n  <div #panElement class=\"panElement\" style=\"position: absolute; left: 0px; top: 0px;\">\n    <div #zoomElement class=\"zoomElement\">\n      <ng-content></ng-content>\n    </div>\n  </div>\n</div>\n<div #panzoomOverlay style=\"position: absolute; top: 0; left: 0; right: 0; bottom: 0; opacity: 0; display: none; pointer-events: none;\"></div>\n  "
                }] }
    ];
    /** @nocollapse */
    PanZoomComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgZone }
    ]; };
    PanZoomComponent.propDecorators = {
        frameElementRef: [{ type: ViewChild, args: ['frameElement', { static: true },] }],
        panElementRef: [{ type: ViewChild, args: ['panElement', { static: true },] }],
        zoomElementRef: [{ type: ViewChild, args: ['zoomElement', { static: true },] }],
        panzoomOverlayRef: [{ type: ViewChild, args: ['panzoomOverlay', { static: true },] }],
        config: [{ type: Input }]
    };
    return PanZoomComponent;
}());
export { PanZoomComponent };
if (false) {
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.frameElementRef;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.panElementRef;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.zoomElementRef;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.panzoomOverlayRef;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.config;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.base;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.model;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.api;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.contentHeight;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.contentWidth;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.frameHeight;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.frameWidth;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.lastMouseEventTime;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.previousPosition;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.isDragging;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.panVelocity;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.animationParams;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.jQueryFrameElement;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.animationFrameFunc;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.lastTick;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.isChrome;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.willChangeNextFrame;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.animationId;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.isMobile;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.scale;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.isFirstSync;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.lastClickPoint;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.acceleratedFrameRef;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.zoomLevelIsChanging;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.dragFinishing;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.dragMouseButton;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.maxScale;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.minScale;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.minimumAllowedZoomLevel;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.onMouseWheel;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.onMousedown;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.onTouchStart;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.onMouseMove;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.onTouchMove;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.onMouseUp;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.onTouchEnd;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.onDblClick;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.preventDefault;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.animationTick;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.el;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.zone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFuem9vbS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZzItcGFuem9vbS8iLCJzb3VyY2VzIjpbImxpYi9wYW56b29tLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBb0MsVUFBVSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2xILE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQzs7OztBQW1CakQsNEJBS0M7OztJQUpDLHVDQUF1Qjs7SUFDdkIsb0NBQXNCOztJQUN0QixpQ0FBaUI7O0lBQ2pCLGlDQUFpQjs7Ozs7QUFHbkIsdUJBSUM7OztJQUhDLHFCQUFXOztJQUNYLHFCQUFXOztJQUNYLDBCQUFnQjs7QUFHbEI7SUFrQkUsMEJBQXNCLEVBQWMsRUFDZCxJQUFZO1FBRGxDLGlCQUN1QztRQURqQixPQUFFLEdBQUYsRUFBRSxDQUFZO1FBQ2QsU0FBSSxHQUFKLElBQUksQ0FBUTtRQWlCMUIscUJBQWdCLEdBQWEsSUFBSSxDQUFDO1FBQ2xDLGVBQVUsR0FBRyxLQUFLLENBQUM7UUFDbkIsZ0JBQVcsR0FBVSxJQUFJLENBQUM7UUFDMUIsb0JBQWUsR0FBa0IsSUFBSSxDQUFDOztRQUd0QyxhQUFRLEdBQUcsQ0FBQyxDQUFDO1FBQ2IsYUFBUSxHQUFHLEtBQUssQ0FBQztRQUNqQix3QkFBbUIsR0FBRyxJQUFJLENBQUMsQ0FBQyw2QkFBNkI7UUFFekQsYUFBUSxHQUFHLEtBQUssQ0FBQztRQUVqQixnQkFBVyxHQUFHLElBQUksQ0FBQztRQUduQix3QkFBbUIsR0FBRyxLQUFLLENBQUM7UUFDNUIsa0JBQWEsR0FBRyxLQUFLLENBQUM7UUFDdEIsb0JBQWUsR0FBVyxJQUFJLENBQUM7Ozs7O1FBMEsvQixpQkFBWTs7OztRQUFHLFVBQUMsS0FBaUI7WUFDdkMsaUVBQWlFO1lBRWpFLElBQUksQ0FBQyxDQUFDLEtBQUssSUFBSSxLQUFLLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDMUMsT0FBTzthQUNSOzs7Z0JBR0csTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNO1lBRXpCLElBQUksS0FBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRTtnQkFDaEMsMEJBQTBCO2dCQUUxQixJQUFJLEtBQUksQ0FBQyxlQUFlLEVBQUU7b0JBQ3hCLE9BQU8sQ0FBQyxrQkFBa0I7aUJBQzNCO2dCQUVELElBQUksQ0FBQyxLQUFJLENBQUMsTUFBTSxDQUFDLGdCQUFnQixFQUFFO29CQUNqQyxNQUFNLEdBQUcsQ0FBQyxNQUFNLENBQUM7aUJBQ2xCOzs7O29CQU1HLFVBQVUsR0FBVTtvQkFDdEIsQ0FBQyxFQUFFLEtBQUssQ0FBQyxLQUFLLEdBQUcsS0FBSSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sRUFBRSxDQUFDLElBQUk7b0JBQ3RELENBQUMsRUFBRSxLQUFLLENBQUMsS0FBSyxHQUFHLEtBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHO2lCQUN0RDtnQkFFRCxLQUFJLENBQUMsY0FBYyxHQUFHLFVBQVUsQ0FBQztnQkFFakMsSUFBSSxLQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsRUFBRTtvQkFDOUIsb0JBQW9CO29CQUNwQixLQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsRUFBRSxNQUFNLENBQUMsQ0FBQztpQkFDbkM7cUJBQ0k7b0JBQ0gsc0NBQXNDO29CQUN0QyxJQUFJLE1BQU0sR0FBRyxDQUFDLEVBQUU7d0JBQ2QsS0FBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztxQkFDekI7eUJBQ0ksSUFBSSxNQUFNLEdBQUcsQ0FBQyxFQUFFO3dCQUNuQixLQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO3FCQUMxQjtpQkFDRjthQUNGO1FBQ0gsQ0FBQyxFQUFBO1FBdUJPLGdCQUFXOzs7O1FBQUcsVUFBQyxLQUFVO1lBQy9CLHlEQUF5RDtZQUV6RDt3Q0FDNEI7WUFDNUIsSUFBSSxLQUFJLENBQUMsTUFBTSxDQUFDLHNCQUFzQjttQkFDL0IsS0FBSSxDQUFDLGVBQWUsQ0FBQyxLQUFJLENBQUMsTUFBTSxDQUFDLHNCQUFzQixFQUFFLEtBQUssQ0FBQyxVQUFVLENBQUMsRUFBRTtnQkFDakYsT0FBTzthQUNSO1lBRUQsSUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLLEtBQUksQ0FBQyxlQUFlLElBQUksS0FBSyxDQUFDLElBQUksS0FBSyxZQUFZLEVBQUU7Z0JBQ3hFLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztnQkFDdkIsMkJBQTJCO2dCQUUzQixLQUFJLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQztnQkFDM0IsS0FBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7Z0JBRXhCLElBQUksS0FBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLEVBQUU7b0JBQzlCLEtBQUksQ0FBQyxnQkFBZ0IsR0FBRzt3QkFDdEIsQ0FBQyxFQUFFLEtBQUssQ0FBQyxLQUFLO3dCQUNkLENBQUMsRUFBRSxLQUFLLENBQUMsS0FBSztxQkFDZixDQUFDO29CQUNGLEtBQUksQ0FBQyxrQkFBa0IsR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDO29CQUMxQyxLQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztvQkFDdkIsS0FBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO29CQUU3QixJQUFJLEtBQUksQ0FBQyxRQUFRLEVBQUU7d0JBQ2pCLEtBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCOzs7d0JBQUUsY0FBTSxPQUFBLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLEVBQUUsS0FBSSxDQUFDLFVBQVUsRUFBRSxLQUFLLENBQUUsRUFBOUQsQ0FBOEQsRUFBRSxDQUFDLENBQUMseUJBQXlCO3dCQUM5SCxLQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQjs7O3dCQUFFLGNBQU0sT0FBQSxRQUFRLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxFQUFFLEtBQUksQ0FBQyxXQUFXLEVBQUUsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsQ0FBRSxFQUE1RixDQUE0RixFQUFFLENBQUMsQ0FBQyx5QkFBeUI7cUJBQzdKO3lCQUNJO3dCQUNILEtBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCOzs7d0JBQUUsY0FBTSxPQUFBLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsS0FBSSxDQUFDLFdBQVcsRUFBRSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxDQUFFLEVBQTVGLENBQTRGLEVBQUUsQ0FBQyxDQUFDLHlCQUF5Qjt3QkFDNUosS0FBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUI7Ozt3QkFBRSxjQUFNLE9BQUEsUUFBUSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxLQUFJLENBQUMsU0FBUyxDQUFFLEVBQXJELENBQXFELEVBQUUsQ0FBQyxDQUFDLHlCQUF5QjtxQkFDdEg7aUJBQ0Y7Z0JBRUQsT0FBTyxLQUFLLENBQUM7YUFDZDtRQUNILENBQUMsRUFBQTtRQUlPLGlCQUFZOzs7O1FBQUcsVUFBQyxLQUFpQjtZQUN2QywwREFBMEQ7WUFDMUQsbUZBQW1GO1lBRW5GLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztZQUN2QiwyQkFBMkI7WUFFM0IsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7Ozs7b0JBSTFCLENBQUMsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUs7O29CQUNuRCxDQUFDLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLO2dCQUV2RCx3REFBd0Q7Z0JBQ3hELHlEQUF5RDtnQkFDekQscURBQXFEO2dCQUNyRCxLQUFJLENBQUMsZ0JBQWdCLEdBQUc7b0JBQ3RCLE1BQU0sRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO2lCQUN0QixDQUFDO2FBQ0g7WUFDRCxLQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzFCLENBQUMsRUFBQTtRQUlPLGdCQUFXOzs7O1FBQUcsVUFBQyxLQUFVO1lBQy9CLHlEQUF5RDtZQUN6RCxxRkFBcUY7WUFDckYsZ0RBQWdEO1lBQ2hELHlEQUF5RDtZQUV6RCwwQkFBMEI7WUFDMUIsMkJBQTJCO1lBRTNCLElBQUksQ0FBQyxDQUFDLEtBQUssSUFBSSxLQUFLLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDMUMsT0FBTzthQUNSOztnQkFFRyxHQUFHLEdBQUcsS0FBSyxDQUFDLFNBQVM7O2dCQUNyQix1QkFBdUIsR0FBRyxDQUFDLEdBQUcsR0FBRyxLQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxJQUFJO1lBQ3BFLGlFQUFpRTtZQUNqRSxLQUFJLENBQUMsa0JBQWtCLEdBQUcsR0FBRyxDQUFDOztnQkFDMUIsU0FBUyxHQUFHOztnQkFFZCxDQUFDLEVBQUUsS0FBSyxDQUFDLEtBQUssR0FBRyxLQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztnQkFDeEMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxLQUFLLEdBQUcsS0FBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7YUFDekM7WUFFRCxJQUFJLEtBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFOztvQkFDeEIsaUJBQWlCLEdBQUcsS0FBSSxDQUFDLGVBQWUsQ0FBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFFOztvQkFDMUQscUJBQXFCLEdBQUcsS0FBSSxDQUFDLGVBQWUsQ0FBRSxFQUFFLENBQUMsRUFBRSxLQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsRUFBRSxLQUFJLENBQUMsYUFBYSxFQUFFLENBQUU7Z0JBR25HLElBQUksaUJBQWlCLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxTQUFTLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRTtvQkFDOUMsU0FBUyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFDRCxJQUFJLENBQUMsR0FBRyxDQUFDLGlCQUFpQixDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUksQ0FBQyxNQUFNLENBQUMsd0JBQXdCLENBQUMsQ0FDcEUsQ0FBQztpQkFDMUI7Z0JBRUQsSUFBSSxpQkFBaUIsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFO29CQUM5QyxTQUFTLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUNDLElBQUksQ0FBQyxHQUFHLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSSxDQUFDLE1BQU0sQ0FBQyx3QkFBd0IsQ0FBQyxDQUNyRSxDQUFDO2lCQUMzQjtnQkFFRCxJQUFJLHFCQUFxQixDQUFDLENBQUMsR0FBRyxLQUFJLENBQUMsWUFBWSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFO29CQUNsRSxTQUFTLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUNDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSSxDQUFDLFlBQVksR0FBRyxxQkFBcUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFJLENBQUMsTUFBTSxDQUFDLHdCQUF3QixDQUFDLENBQzlGLENBQUM7aUJBQzFCO2dCQUVELElBQUkscUJBQXFCLENBQUMsQ0FBQyxHQUFHLEtBQUksQ0FBQyxhQUFhLElBQUksU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUU7b0JBQ25FLFNBQVMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQ0EsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsYUFBYSxHQUFHLHFCQUFxQixDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUksQ0FBQyxNQUFNLENBQUMsd0JBQXdCLENBQUMsQ0FDOUYsQ0FBQztpQkFDMUI7YUFDRjs7O2dCQUdHLEtBQUssR0FBVTtnQkFDakIsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQztnQkFDbkIsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQzthQUNwQjtZQUNELEtBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQzVCLEtBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQzVCLEtBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztZQUN2QixLQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1lBRXRDLElBQUksQ0FBQyxLQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRTtnQkFDekIscUNBQXFDO2dCQUNyQyxxR0FBcUc7Z0JBQ3JHLHFFQUFxRTtnQkFDckUsK0RBQStEO2dCQUMvRCxLQUFJLENBQUMsaUJBQWlCLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO2FBQzlEO1lBRUQsS0FBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO1lBRTVCLHdEQUF3RDtZQUN4RCxrSkFBa0o7WUFDbEosS0FBSSxDQUFDLFdBQVcsR0FBRztnQkFDakIsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLEdBQUcsdUJBQXVCO2dCQUN4QyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUMsR0FBRyx1QkFBdUI7YUFDekMsQ0FBQztZQUNGLGtGQUFrRjtZQUVsRixLQUFJLENBQUMsZ0JBQWdCLEdBQUc7Z0JBQ3RCLENBQUMsRUFBRSxLQUFLLENBQUMsS0FBSztnQkFDZCxDQUFDLEVBQUUsS0FBSyxDQUFDLEtBQUs7YUFDZixDQUFDO1FBRUosQ0FBQyxFQUFBO1FBSU8sZ0JBQVc7Ozs7UUFBRyxVQUFDLEtBQVU7WUFDL0Isa0RBQWtEO1lBQ2xELGlFQUFpRTtZQUVqRSwwQkFBMEI7WUFDMUIsMkJBQTJCO1lBRTNCLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO2dCQUM5QixtQ0FBbUM7Z0JBQ25DLEtBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDekI7aUJBQ0k7Ozs7O29CQUtDLENBQUMsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUs7O29CQUNuRCxDQUFDLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLOzs7OztvQkFJbkQsUUFBTSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7OztvQkFHdEIsS0FBSyxHQUFHLFFBQU0sR0FBRyxLQUFJLENBQUMsZ0JBQWdCLENBQUMsTUFBTTtnQkFFakQsbUJBQW1CO2dCQUNuQixJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxFQUFFO29CQUN6QixPQUFPO2lCQUNSOzs7b0JBR0csT0FBTyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsR0FBRyxDQUFDOztvQkFDeEMsT0FBTyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsR0FBRyxDQUFDOzs7b0JBR3hDLFVBQVUsR0FBRztvQkFDZixDQUFDLEVBQUUsT0FBTyxHQUFHLEtBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJO29CQUNsRCxDQUFDLEVBQUUsT0FBTyxHQUFHLEtBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHO2lCQUNsRDtnQkFDRCxLQUFJLENBQUMsY0FBYyxHQUFHLFVBQVUsQ0FBQztnQkFFakMsS0FBSSxDQUFDLGVBQWUsQ0FBRSxLQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLEdBQUcsTUFBTSxFQUFFLFVBQVUsQ0FBQyxDQUFDO2dCQUN4RSxxQ0FBcUM7Z0JBRXJDLG9DQUFvQztnQkFDcEMsS0FBSSxDQUFDLGdCQUFnQixHQUFHO29CQUN0QixNQUFNLEVBQUUsUUFBTTtpQkFDZixDQUFDO2FBQ0g7UUFDSCxDQUFDLEVBQUE7UUFJTyxjQUFTOzs7O1FBQUcsVUFBQyxLQUFLO1lBQ3hCLHVEQUF1RDtZQUV2RCxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssS0FBSSxDQUFDLGVBQWUsRUFBRTtnQkFDekMsT0FBTzthQUNSO1lBRUQsS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDOzs7Z0JBR25CLEdBQUcsR0FBRyxLQUFLLENBQUMsU0FBUzs7Z0JBQ3JCLHVCQUF1QixHQUFHLENBQUMsR0FBRyxHQUFHLEtBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLElBQUk7WUFFcEUsSUFBSSxLQUFJLENBQUMsV0FBVyxJQUFJLENBQUMsS0FBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLEtBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFHOzs7O29CQUczRSxpQkFBaUIsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUM5QixDQUFDLEVBQ0QsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyx1QkFBdUIsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FDL0M7Z0JBRUQsS0FBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksaUJBQWlCLENBQUM7Z0JBQ3hDLEtBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxJQUFJLGlCQUFpQixDQUFDO2dCQUN4QyxLQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQztnQkFDMUIsZ0ZBQWdGO2dCQUNoRixLQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQjs7O2dCQUFFLGNBQU0sT0FBQSxLQUFJLENBQUMsV0FBVyxHQUFHLEtBQUksQ0FBQyxrQkFBa0IsQ0FBQyxLQUFJLENBQUMsYUFBYSxDQUFDLEVBQTlELENBQThELEVBQUUsQ0FBQzthQUNyRztpQkFDSTtnQkFDSCxLQUFJLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQztnQkFDM0IsS0FBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7YUFDekI7WUFFRCxLQUFJLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztZQUN4QixnQ0FBZ0M7WUFFaEMsSUFBSSxLQUFJLENBQUMsUUFBUSxFQUFFO2dCQUNqQixLQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQjs7O2dCQUFFLGNBQU0sT0FBQSxRQUFRLENBQUMsbUJBQW1CLENBQUMsVUFBVSxFQUFFLEtBQUksQ0FBQyxVQUFVLENBQUMsRUFBekQsQ0FBeUQsRUFBRSxDQUFDO2dCQUMvRixLQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQjs7O2dCQUFFLGNBQU0sT0FBQSxRQUFRLENBQUMsbUJBQW1CLENBQUMsV0FBVyxFQUFFLEtBQUksQ0FBQyxXQUFXLEVBQUUsbUJBQUssRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsRUFBQSxDQUFFLEVBQXBHLENBQW9HLEVBQUUsQ0FBQzthQUMzSTtpQkFDSTtnQkFDSCxLQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQjs7O2dCQUFFLGNBQU0sT0FBQSxRQUFRLENBQUMsbUJBQW1CLENBQUMsV0FBVyxFQUFFLEtBQUksQ0FBQyxXQUFXLEVBQUUsbUJBQUssRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsRUFBQSxDQUFFLEVBQXBHLENBQW9HLEVBQUMsQ0FBQztnQkFDekksS0FBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUI7OztnQkFBRSxjQUFNLE9BQUEsUUFBUSxDQUFDLG1CQUFtQixDQUFDLFNBQVMsRUFBRSxLQUFJLENBQUMsU0FBUyxFQUFFLG1CQUFLLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxFQUFBLENBQUUsRUFBaEYsQ0FBZ0YsRUFBQyxDQUFDO2FBQ3hIO1lBRUQseUNBQXlDO1lBQ3pDLEtBQUksQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7UUFDOUQsQ0FBQyxFQUFBO1FBSU8sZUFBVTs7OztRQUFHLFVBQUMsS0FBVTtZQUM5QixpREFBaUQ7WUFDakQsS0FBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN4QixDQUFDLEVBQUE7UUFJTyxlQUFVOzs7O1FBQUcsVUFBQyxLQUFVO1lBQzlCLGlEQUFpRDtZQUNqRCxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7WUFDdkIsMkJBQTJCO1lBQzNCLElBQUksQ0FBQyxLQUFJLENBQUMsTUFBTSxDQUFDLGlCQUFpQixFQUFFO2dCQUNsQyxPQUFPO2FBQ1I7O2dCQUVHLFVBQVUsR0FBVTtnQkFDdEIsQ0FBQyxFQUFFLEtBQUssQ0FBQyxLQUFLLEdBQUcsS0FBSSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sRUFBRSxDQUFDLElBQUk7Z0JBQ3RELENBQUMsRUFBRSxLQUFLLENBQUMsS0FBSyxHQUFHLEtBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHO2FBQ3REO1lBQ0QsS0FBSSxDQUFDLGNBQWMsR0FBRyxVQUFVLENBQUM7WUFDakMsS0FBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUMxQixDQUFDLEVBQUE7UUFJTyxtQkFBYzs7OztRQUFHLFVBQUMsS0FBVTtZQUNsQyxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDekIsQ0FBQyxFQUFBOzs7Ozs7O1FBd0JPLGtCQUFhOzs7O1FBQUcsVUFBQyxTQUFpQjtZQUN4QyxvREFBb0Q7WUFDcEQsMEdBQTBHOzs7O2dCQUV0RyxTQUFTLEdBQUcsQ0FBQztZQUNqQixJQUFJLEtBQUksQ0FBQyxRQUFRLEtBQUssQ0FBQyxFQUFFO2dCQUN2QixTQUFTLEdBQUcsQ0FBQyxTQUFTLEdBQUcsS0FBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsbURBQW1EO2FBQzdGO1lBQ0QsS0FBSSxDQUFDLFFBQVEsR0FBRyxTQUFTLENBQUM7WUFFMUIsSUFBSSxLQUFJLENBQUMsZUFBZSxFQUFFO2dCQUN4QixnRkFBZ0Y7Z0JBQ2hGLHNFQUFzRTtnQkFFdEUsS0FBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEdBQUcsS0FBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFFckYsSUFBSSxLQUFJLENBQUMsZUFBZSxDQUFDLFFBQVEsSUFBSSxHQUFHLEVBQUU7b0JBQ3hDLG9FQUFvRTtvQkFDcEUsS0FBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRLEdBQUcsR0FBRyxDQUFDO29CQUNwQyxLQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7b0JBQ2pCLEtBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDO2lCQUM3QjthQUNGO1lBRUQsSUFBSSxLQUFJLENBQUMsV0FBVyxJQUFJLEtBQUksQ0FBQyxhQUFhLEVBQUU7Z0JBQzFDLHFNQUFxTTtnQkFDck0sNEpBQTRKO2dCQUM1SixJQUFJLFNBQVMsR0FBRyxDQUFDLEVBQUU7b0JBQ2pCLFNBQVMsR0FBRyxTQUFTLEdBQUcsSUFBSSxDQUFDO2lCQUM5QjtnQkFDRCxPQUFPLFNBQVMsR0FBRyxDQUFDLEVBQUU7O3dCQUNoQixLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsU0FBUyxDQUFDO29CQUNwQyxTQUFTLEdBQUcsU0FBUyxHQUFHLEtBQUssQ0FBQztvQkFFOUIsS0FBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEtBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7b0JBQ2pFLEtBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxHQUFHLEtBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEtBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQyxDQUFDO29CQUU3RSxLQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsS0FBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEtBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztvQkFDakUsS0FBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEdBQUcsS0FBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsS0FBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDLENBQUM7O3dCQUV6RSxLQUFLLEdBQUcsS0FBSSxDQUFDLE1BQU0sQ0FBQyxLQUFJLENBQUMsV0FBVyxDQUFDO29CQUV6QyxJQUFJLEtBQUssR0FBRyxLQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRTt3QkFDakMsS0FBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO3dCQUM3QixLQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQzt3QkFDeEIsS0FBSSxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQUM7d0JBQzNCLE1BQU07cUJBQ1A7aUJBRUY7YUFDRjtZQUVELElBQUksS0FBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLElBQUksS0FBSSxDQUFDLGFBQWEsRUFBRTs7OztvQkFHOUMsaUJBQWlCLEdBQUcsS0FBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDOztvQkFDeEQscUJBQXFCLEdBQUcsS0FBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsRUFBRSxLQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7Z0JBRWpHLElBQUksaUJBQWlCLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRTtvQkFDM0IsS0FBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEtBQUksQ0FBQyxNQUFNLENBQUMsd0JBQXdCLEdBQUcsaUJBQWlCLENBQUMsQ0FBQyxDQUFDO2lCQUMvRTtnQkFFRCxJQUFJLGlCQUFpQixDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUU7b0JBQzNCLEtBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxLQUFJLENBQUMsTUFBTSxDQUFDLHdCQUF3QixHQUFHLGlCQUFpQixDQUFDLENBQUMsQ0FBQztpQkFDL0U7Z0JBRUQsSUFBSSxxQkFBcUIsQ0FBQyxDQUFDLEdBQUcsS0FBSSxDQUFDLFlBQVksRUFBRTtvQkFDL0MsS0FBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEtBQUksQ0FBQyxNQUFNLENBQUMsd0JBQXdCLEdBQUcsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLEdBQUcsS0FBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO2lCQUN6RztnQkFFRCxJQUFJLHFCQUFxQixDQUFDLENBQUMsR0FBRyxLQUFJLENBQUMsYUFBYSxFQUFFO29CQUNoRCxLQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksS0FBSSxDQUFDLE1BQU0sQ0FBQyx3QkFBd0IsR0FBRyxDQUFDLHFCQUFxQixDQUFDLENBQUMsR0FBRyxLQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7aUJBQzFHO2FBQ0Y7WUFFRCxLQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDakIsS0FBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUcxQyxJQUFLLEtBQUksQ0FBQyxlQUFlLElBQUksQ0FBQyxLQUFJLENBQUMsV0FBVyxJQUFJLEtBQUksQ0FBQyxhQUFhLENBQUMsRUFBRztnQkFDdEUscURBQXFEO2dCQUVyRCxJQUFJLEtBQUksQ0FBQyxRQUFRLElBQUksS0FBSSxDQUFDLG1CQUFtQixFQUFFO29CQUM3QyxvRUFBb0U7b0JBQ3BFLCtFQUErRTtvQkFDL0UsSUFBSSxLQUFJLENBQUMsbUJBQW1CLEVBQUU7d0JBQzVCLENBQUMsbUJBQUssS0FBSSxDQUFDLG1CQUFtQixDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUEsQ0FBQyxDQUFDLFVBQVUsR0FBRyxNQUFNLENBQUM7cUJBQ3pFO3lCQUNJO3dCQUNILENBQUMsbUJBQUssS0FBSSxDQUFDLG1CQUFtQixDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUEsQ0FBQyxDQUFDLFVBQVUsR0FBRyxXQUFXLENBQUM7cUJBQzlFO29CQUNELEtBQUksQ0FBQyxtQkFBbUIsR0FBRyxDQUFDLEtBQUksQ0FBQyxtQkFBbUIsQ0FBQztpQkFDdEQ7Z0JBQ0Qsb0NBQW9DO2dCQUNwQyxLQUFJLENBQUMsa0JBQWtCLENBQUMsS0FBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsZ0NBQWdDO2FBQzlFO2lCQUNJLElBQUksS0FBSSxDQUFDLFdBQVcsSUFBSSxDQUFDLEtBQUksQ0FBQyxhQUFhLEVBQUU7Z0JBQ2hELGtFQUFrRTtnQkFDbEUsT0FBTzthQUNSO2lCQUNJO2dCQUNILHNCQUFzQjtnQkFDdEIsS0FBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO2dCQUN2QixLQUFJLENBQUMsS0FBSyxHQUFHLEtBQUksQ0FBQyxXQUFXLENBQUMsS0FBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFDbkQsS0FBSSxDQUFDLG1CQUFtQixHQUFHLElBQUksQ0FBQztnQkFDaEMsQ0FBQyxtQkFBSyxLQUFJLENBQUMsbUJBQW1CLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBQSxDQUFDLENBQUMsVUFBVSxHQUFHLFdBQVcsQ0FBQztnQkFDN0UsS0FBSSxDQUFDLG1CQUFtQixHQUFHLEtBQUssQ0FBQztnQkFDakMsS0FBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUM7YUFDbkI7UUFFSCxDQUFDLEVBQUE7SUF4ckJxQyxDQUFDOzs7O0lBMEN2QyxtQ0FBUTs7O0lBQVI7UUFDRSw4RUFBOEU7UUFEaEYsaUJBeUZDO1FBdEZDLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRTtZQUNoQyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1NBQzlEO2FBQ0k7WUFDSCxJQUFJLENBQUMsSUFBSSxHQUFHO2dCQUNWLFNBQVMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLGdCQUFnQjtnQkFDdkMsR0FBRyxFQUFFO29CQUNILENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVc7b0JBQzFCLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVc7aUJBQzNCO2FBQ0YsQ0FBQztTQUNIO1FBRUQsSUFBSSxDQUFDLEtBQUssR0FBRztZQUNYLFNBQVMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVM7WUFDOUIsU0FBUyxFQUFFLEtBQUs7O1lBQ2hCLEdBQUcsRUFBRTtnQkFDSCxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDbEIsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDbkI7U0FDRixDQUFDO1FBRUYsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUUxQyxvQkFBb0I7UUFDcEIsSUFBSSxDQUFDLEdBQUcsR0FBRztZQUNULEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSztZQUNqQixNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07WUFDbkIsZUFBZSxFQUFFLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQ3BELE1BQU0sRUFBRSxJQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztZQUM5QyxPQUFPLEVBQUUsSUFBSSxDQUFDLHlCQUF5QixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7WUFDbEQsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztZQUNwQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQ3BDLGVBQWUsRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7WUFDaEQsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7WUFDbEQsVUFBVSxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztZQUN0QyxRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQ2xDLGVBQWUsRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7WUFDaEQsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7U0FDbkQsQ0FBQztRQUVGLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFL0IsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsRUFBRTtZQUM5QixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDOztnQkFDeEQsWUFBWSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxHQUFHLENBQUM7WUFDN0MsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQy9DLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNyQztRQUVELElBQUksQ0FBQyx1QkFBdUIsR0FBRyxDQUFDLENBQUM7UUFDakMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRTtZQUM1QixJQUFJLENBQUMsdUJBQXVCLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQztZQUM1RCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1NBQ2hFO1FBRUQsSUFBSSxDQUFDLG1CQUFtQixHQUFHLElBQUksQ0FBQyxjQUFjLENBQUM7UUFDL0MsaURBQWlEO1FBQ2pELCtDQUErQztRQUUvQyxDQUFDLG1CQUFLLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxhQUFhLENBQUMsS0FBSyxFQUFBLENBQUMsQ0FBQyxVQUFVLEdBQUcsV0FBVyxDQUFDO1FBQzdFLElBQUksU0FBUyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQzdDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1lBQ3JCLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxlQUFlLENBQUM7U0FDMUU7UUFFRCxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQ3RDLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ25ELElBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDO1FBQ3pCLFFBQVEsSUFBSSxDQUFDLE1BQU0sQ0FBQyxlQUFlLEVBQUU7WUFDbkMsS0FBSyxNQUFNO2dCQUNULElBQUksQ0FBQyxlQUFlLEdBQUcsQ0FBQyxDQUFDO2dCQUN6QixNQUFNO1lBQ1IsS0FBSyxRQUFRO2dCQUNYLElBQUksQ0FBQyxlQUFlLEdBQUcsQ0FBQyxDQUFDO2dCQUN6QixJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQjs7O2dCQUFFLGNBQU0sT0FBQSxLQUFJLENBQUMsZUFBZSxDQUFDLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLEVBQUUsS0FBSSxDQUFDLGNBQWMsQ0FBRSxFQUFyRixDQUFxRixFQUFFLENBQUM7Z0JBQzNILE1BQU07WUFDUixLQUFLLE9BQU87Z0JBQ1YsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUI7OztnQkFBRSxjQUFNLE9BQUEsUUFBUSxDQUFDLGdCQUFnQixDQUFDLGFBQWEsRUFBRSxLQUFJLENBQUMsY0FBYyxDQUFFLEVBQTlELENBQThELEVBQUUsQ0FBQztnQkFDcEcsSUFBSSxDQUFDLGVBQWUsR0FBRyxDQUFDLENBQUM7Z0JBQ3pCLE1BQU07WUFDUjtnQkFDRSxJQUFJLENBQUMsZUFBZSxHQUFHLENBQUMsQ0FBQyxDQUFDLE9BQU87U0FDcEM7SUFHSCxDQUFDOzs7O0lBSUQsMENBQWU7OztJQUFmO1FBQ0Usc0RBQXNEO1FBRHhELGlCQXVCQztRQXBCQyxJQUFJLENBQUMsa0JBQWtCLEdBQUcsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLENBQUM7UUFDL0MsSUFBSSxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDM0QsSUFBSSxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDekQsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDcEQsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsS0FBSyxFQUFFLENBQUM7UUFFbEQsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUI7OztRQUFFLGNBQU0sT0FBQSxLQUFJLENBQUMsa0JBQWtCLEdBQUcsTUFBTSxDQUFDLHFCQUFxQixFQUF0RCxDQUFzRCxFQUFFLENBQUM7UUFDNUYsb0dBQW9HO1FBR3BHLElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRSxFQUFFO1lBQ3pCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1lBQ3JCLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCOzs7WUFBRSxjQUFNLE9BQUEsS0FBSSxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUMsZ0JBQWdCLENBQUMsWUFBWSxFQUFFLEtBQUksQ0FBQyxZQUFZLENBQUUsRUFBckYsQ0FBcUYsRUFBRSxDQUFDO1NBQzVIO2FBQ0k7WUFDSCxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQjs7O1lBQUUsY0FBTSxPQUFBLEtBQUksQ0FBQyxlQUFlLENBQUMsYUFBYSxDQUFDLGdCQUFnQixDQUFDLFdBQVcsRUFBRSxLQUFJLENBQUMsV0FBVyxDQUFFLEVBQW5GLENBQW1GLEVBQUUsQ0FBQztZQUN6SCxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQjs7O1lBQUUsY0FBTSxPQUFBLEtBQUksQ0FBQyxlQUFlLENBQUMsYUFBYSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsRUFBRSxLQUFJLENBQUMsVUFBVSxDQUFFLEVBQWpGLENBQWlGLEVBQUUsQ0FBQztZQUN2SCxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQjs7O1lBQUUsY0FBTSxPQUFBLEtBQUksQ0FBQyxlQUFlLENBQUMsYUFBYSxDQUFDLGdCQUFnQixDQUFDLE9BQU87Ozs7WUFBRSxVQUFDLEtBQUssSUFBSyxPQUFBLEtBQUksQ0FBQyxrQkFBa0I7OztZQUFFLGNBQU0sT0FBQSxLQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxFQUF4QixDQUF3QixFQUFFLEVBQXpELENBQXlELEdBQUUsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUUsRUFBdEosQ0FBc0osRUFBRSxDQUFDO1NBQzdMO0lBRUgsQ0FBQzs7OztJQUlELHNDQUFXOzs7SUFBWDtRQUFBLGlCQXVCQztRQXRCQyxrREFBa0Q7UUFDbEQsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2pCLElBQUksQ0FBQyxlQUFlLENBQUMsYUFBYSxDQUFDLG1CQUFtQixDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7U0FDekY7YUFDSTtZQUNILElBQUksQ0FBQyxlQUFlLENBQUMsYUFBYSxDQUFDLG1CQUFtQixDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDdEYsSUFBSSxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUMsbUJBQW1CLENBQUMsT0FBTzs7OztZQUFFLFVBQUMsS0FBSyxJQUFLLE9BQUEsS0FBSSxDQUFDLGtCQUFrQjs7O1lBQUUsY0FBTSxPQUFBLEtBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLEVBQXhCLENBQXdCLEVBQUUsRUFBekQsQ0FBeUQsR0FBRSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBRSxDQUFDO1lBQzFKLElBQUksQ0FBQyxlQUFlLENBQUMsYUFBYSxDQUFDLG1CQUFtQixDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDckY7UUFDRCxJQUFJLElBQUksQ0FBQyxrQkFBa0IsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQy9DLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDL0M7UUFDRCxRQUFRLElBQUksQ0FBQyxNQUFNLENBQUMsZUFBZSxFQUFFO1lBQ25DLEtBQUssUUFBUTtnQkFDWCxJQUFJLENBQUMsZUFBZSxHQUFHLENBQUMsQ0FBQztnQkFDekIsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUI7OztnQkFBRSxjQUFNLE9BQUEsS0FBSSxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUMsbUJBQW1CLENBQUMsVUFBVSxFQUFFLEtBQUksQ0FBQyxjQUFjLENBQUUsRUFBeEYsQ0FBd0YsRUFBRSxDQUFDO2dCQUM5SCxNQUFNO1lBQ1IsS0FBSyxPQUFPO2dCQUNWLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCOzs7Z0JBQUUsY0FBTSxPQUFBLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxhQUFhLEVBQUUsS0FBSSxDQUFDLGNBQWMsQ0FBRSxFQUFqRSxDQUFpRSxFQUFFLENBQUM7Z0JBQ3ZHLElBQUksQ0FBQyxlQUFlLEdBQUcsQ0FBQyxDQUFDO2dCQUN6QixNQUFNO1NBQ1Q7SUFDSCxDQUFDO0lBcUVEOzs7OztPQUtHOzs7Ozs7Ozs7SUFDSywwQ0FBZTs7Ozs7Ozs7SUFBdkIsVUFBd0IsU0FBUyxFQUFFLEtBQUs7O1lBQ2xDLElBQUksR0FBRyxLQUFLLENBQUMsVUFBVTtRQUMzQixPQUFPLElBQUksSUFBSSxJQUFJLEVBQUU7WUFDbkIsSUFBSSxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxFQUFFO2dCQUN4RCxPQUFPLElBQUksQ0FBQzthQUNiO1lBQ0QsSUFBSSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7U0FDeEI7UUFDRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7Ozs7O0lBK2FPLG9DQUFTOzs7O0lBQWpCO1FBQ0UsZ0RBQWdEO1FBQ2hELGtEQUFrRDtRQUNsRCxvSEFBb0g7UUFFcEgsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFO1lBQ3hCLDJGQUEyRjtZQUMzRixJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLFFBQVEsQ0FBQyxDQUFDLDRFQUE0RTs7O2dCQUMxTCxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQztZQUU3RSxtRUFBbUU7WUFDbkUsNkhBQTZIO1lBQzdILElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDO1lBQ3hELElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDO1lBRXhELElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLEVBQUU7O29CQUN4QixpQkFBaUIsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7O29CQUN4RCxxQkFBcUIsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztnQkFFakcsSUFBSSxpQkFBaUIsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFO29CQUMzQixJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2lCQUN0QjtnQkFFRCxJQUFJLGlCQUFpQixDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUU7b0JBQzNCLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7aUJBQ3RCO2dCQUVELElBQUkscUJBQXFCLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZLEVBQUU7b0JBQy9DLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7aUJBQ25FO2dCQUVELElBQUkscUJBQXFCLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUU7b0JBQ2hELElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7aUJBQ3BFO2FBQ0Y7U0FDRjtRQUVELG9EQUFvRDtRQUNwRCxvREFBb0Q7UUFDcEQsb0RBQW9EO1FBQ3BELElBQUksSUFBSSxDQUFDLGVBQWUsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFOztnQkFDeEMsS0FBSyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUM7O2dCQUM5QyxXQUFXLEdBQUcsV0FBUyxLQUFLLE1BQUc7WUFDbkMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLGVBQWUsR0FBRyxLQUFLLENBQUM7WUFDaEUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxXQUFXLENBQUM7U0FDakU7Ozs7O1lBS0csV0FBVyxHQUFHLGlCQUFlLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsWUFBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFdBQVE7UUFDaEYsSUFBSSxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxXQUFXLENBQUM7SUFFakUsQ0FBQzs7Ozs7OztJQUlPLG1DQUFROzs7Ozs7SUFBaEIsVUFBaUIsVUFBaUIsRUFBRSxVQUFrQjtRQUNwRCxzRUFBc0U7UUFFdEUsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFO1lBQ25CLDJDQUEyQztZQUMzQyxPQUFPO1NBQ1I7UUFFRCxzREFBc0Q7UUFDdEQsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFO1lBQ3hCLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLENBQUMsK0JBQStCO1NBQzdEO1FBRUQsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ3BCLElBQUksQ0FBQyxhQUFhLEdBQUcsS0FBSyxDQUFDO1lBQzNCLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO1NBQ3pCOztZQUVHLFVBQVUsR0FBVTs7WUFFdEIsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDbEIsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDbkI7OztZQUVHLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSzs7O1lBRXpCLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztRQUV4Rix3T0FBd087UUFDeE8sUUFBUSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFFLENBQUMsQ0FBQztRQUN4RSxJQUFJLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQzs7WUFFbEIsV0FBVyxHQUFVOztZQUV2QixDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLFFBQVEsR0FBRyxZQUFZLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQztZQUMzRSxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLFFBQVEsR0FBRyxZQUFZLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQztTQUM1RTs7O1lBR0csV0FBVyxHQUFHLGlCQUFlLFdBQVcsQ0FBQyxDQUFDLFlBQU8sV0FBVyxDQUFDLENBQUMsV0FBUTtRQUMxRSxJQUFJLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLFdBQVcsQ0FBQzs7WUFDM0QsV0FBVyxHQUFHLFdBQVMsSUFBSSxDQUFDLEtBQUssTUFBRztRQUN4QyxJQUFJLENBQUMsY0FBYyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsZUFBZSxHQUFHLEtBQUssQ0FBQztRQUNoRSxJQUFJLENBQUMsY0FBYyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLFdBQVcsQ0FBQztRQUVoRSxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDakIsSUFBSSxJQUFJLENBQUMsbUJBQW1CLEVBQUU7Z0JBQzVCLENBQUMsbUJBQUssSUFBSSxDQUFDLG1CQUFtQixDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUEsQ0FBQyxDQUFDLFVBQVUsR0FBRyxNQUFNLENBQUM7YUFDekU7aUJBQ0k7Z0JBQ0gsQ0FBQyxtQkFBSyxJQUFJLENBQUMsbUJBQW1CLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBQSxDQUFDLENBQUMsVUFBVSxHQUFHLFdBQVcsQ0FBQzthQUM5RTtZQUNELElBQUksQ0FBQyxtQkFBbUIsR0FBRyxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQztTQUN0RDtRQUVELElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDO1FBQ2pDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDO1FBQ2pDLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3JELElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzFDLDhJQUE4STtRQUM5SSxrREFBa0Q7SUFDcEQsQ0FBQztJQU9ELG9EQUFvRDtJQUNwRCxvREFBb0Q7SUFDcEQsb0RBQW9EOzs7Ozs7OztJQUk1Qyx5Q0FBYzs7Ozs7Ozs7SUFBdEI7UUFDRSxPQUFPLENBQUMsT0FBTyxNQUFNLENBQUMsV0FBVyxLQUFLLFdBQVcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN6RyxDQUFDOzs7OztJQUtPLDBDQUFlOzs7O0lBQXZCO1FBQ0UsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNuQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ25DLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDO0lBQzdDLENBQUM7Ozs7OztJQUlPLGlDQUFNOzs7OztJQUFkLFVBQWUsUUFBYTtRQUMxQiw2Q0FBNkM7UUFDN0MsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN0RSxDQUFDOzs7OztJQUlPLHlDQUFjOzs7O0lBQXRCOzs7O1lBR00sTUFBTSxHQUFHOztZQUVYLENBQUMsRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLGFBQWEsQ0FBQyxXQUFXLEdBQUcsQ0FBQzs7O1lBR3JELENBQUMsRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLGFBQWEsQ0FBQyxZQUFZLEdBQUcsQ0FBQztZQUN0RCw2REFBNkQ7U0FDOUQ7UUFDRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDOzs7Ozs7SUFJTyxzQ0FBVzs7Ozs7SUFBbkIsVUFBb0IsU0FBYztRQUNoQyxrREFBa0Q7UUFDbEQsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsaUJBQWlCLEVBQUUsU0FBUyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztJQUMzRixDQUFDOzs7Ozs7SUFJTyx1Q0FBWTs7Ozs7SUFBcEIsVUFBcUIsUUFBYTtRQUNoQyxtREFBbUQ7UUFDbkQsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUM7SUFDekcsQ0FBQzs7Ozs7O0lBSU8sd0NBQWE7Ozs7O0lBQXJCLFVBQXNCLElBQVU7UUFDOUIsaUVBQWlFO1FBQ2pFLDZDQUE2QztRQUM3Qyx5REFBeUQ7UUFDekQsc0ZBQXNGO1FBQ3RGLHNGQUFzRjs7Ozs7OztZQUVsRixhQUFhLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUMsV0FBVzs7WUFDOUQsY0FBYyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsYUFBYSxDQUFDLFlBQVk7O1lBRWhFLFdBQVcsR0FBRyxJQUFJLENBQUMsS0FBSzs7WUFDeEIsWUFBWSxHQUFHLElBQUksQ0FBQyxNQUFNOztZQUUxQixhQUFhLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBRSxhQUFhLEdBQUcsV0FBVyxFQUFFLGNBQWMsR0FBRyxZQUFZLENBQUU7O1lBQ3RGLGNBQWMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQzs7WUFDakQsU0FBUyxHQUFHLGNBQWMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLHdCQUF3Qjs7WUFDakUsUUFBUSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDO1FBRTFDLE9BQU87WUFDSCxTQUFTLEVBQUUsU0FBUztZQUNwQixHQUFHLEVBQUU7Z0JBQ0QsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxRQUFRLEdBQUcsQ0FBQyxhQUFhLEdBQUcsV0FBVyxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUM7Z0JBQ3BFLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsUUFBUSxHQUFHLENBQUMsY0FBYyxHQUFHLFlBQVksR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDO2FBQ3pFO1NBQ0osQ0FBQztJQUNKLENBQUM7Ozs7Ozs7SUFJTyx5Q0FBYzs7Ozs7O0lBQXRCLFVBQXVCLE1BQW9CLEVBQUUsUUFBdUI7UUFDbEUsc0VBQXNFO1FBRDNCLHlCQUFBLEVBQUEsZUFBdUI7UUFHbEUscURBQXFEO1FBQ3JELG9EQUFvRDtRQUNwRCxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQztJQUN6QyxDQUFDOzs7Ozs7O0lBSU8sOENBQW1COzs7Ozs7SUFBM0IsVUFBNEIsS0FBYSxFQUFFLFVBQWlCO1FBQzFELHlFQUF5RTtRQUN6RSxtRkFBbUY7UUFDbkYsSUFBSSxDQUFDLGVBQWUsQ0FBRSxLQUFLLEVBQUUsVUFBVSxDQUFFLENBQUM7SUFDNUMsQ0FBQzs7Ozs7SUFJTyxpREFBc0I7Ozs7SUFBOUI7UUFDRSxrR0FBa0c7UUFDbEcsSUFBSSxDQUFDLGVBQWUsQ0FBRSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLG1CQUFtQixFQUFFLElBQUksQ0FBQyxjQUFjLENBQUUsQ0FBQztJQUNyRyxDQUFDOzs7OztJQUlPLG9EQUF5Qjs7OztJQUFqQztRQUNFLGdFQUFnRTtRQUNoRSxJQUFJLENBQUMsZUFBZSxDQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsbUJBQW1CLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBRSxDQUFDO0lBQ3JHLENBQUM7Ozs7O0lBSU8seUNBQWM7Ozs7SUFBdEI7UUFBQSxpQkFHQztRQUZDLElBQUksQ0FBQyxRQUFRLEdBQUcsV0FBVyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ2xDLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCOzs7UUFBRSxjQUFNLE9BQUEsS0FBSSxDQUFDLFdBQVcsR0FBRyxLQUFJLENBQUMsa0JBQWtCLENBQUMsS0FBSSxDQUFDLGFBQWEsQ0FBQyxFQUE5RCxDQUE4RCxFQUFFLENBQUM7SUFDdEcsQ0FBQztJQVFELG9EQUFvRDtJQUNwRCxvREFBb0Q7SUFDcEQsb0RBQW9EOzs7Ozs7Ozs7SUFJNUMsMENBQWU7Ozs7Ozs7OztJQUF2QixVQUF3QixhQUFvQjtRQUMxQyxzREFBc0Q7UUFDdEQsaUJBQWlCO1FBQ2pCLGlEQUFpRDs7Ozs7WUFFN0MsS0FBSzs7WUFBRSxXQUFXO1FBRXRCLElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRTtZQUN4QixLQUFLLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLFFBQVEsQ0FBQyxDQUFDOztnQkFDaEgsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUM7WUFDN0UsV0FBVyxHQUFHLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxnQkFBZ0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxnQkFBZ0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQztTQUNwRzthQUNJO1lBQ0gsS0FBSyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUM5QyxXQUFXLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7U0FDN0I7UUFFRCxPQUFPO1lBQ0wsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxDQUFDLEdBQUcsS0FBSyxHQUFHLFdBQVcsQ0FBQyxDQUFDO1lBQzFDLENBQUMsRUFBRSxhQUFhLENBQUMsQ0FBQyxHQUFHLEtBQUssR0FBRyxXQUFXLENBQUMsQ0FBQztTQUMzQyxDQUFDO0lBQ0osQ0FBQzs7Ozs7O0lBSU8sMkNBQWdCOzs7OztJQUF4QixVQUF5QixZQUFtQjs7OztZQUd0QyxLQUFLLEdBQUcsWUFBWTs7WUFDcEIsQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUM7O1lBQ3pDLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUc7UUFFckIsT0FBTztZQUNMLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM1QixDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDN0IsQ0FBQztJQUNKLENBQUM7Ozs7O0lBSU8sb0NBQVM7Ozs7SUFBakI7UUFDRSxnREFBZ0Q7UUFDaEQsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLGdCQUFnQixFQUFFO1lBQ2hDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1NBQzlDO2FBQ0ksSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsS0FBSyxJQUFJLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLEtBQUssSUFBSSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLEtBQUssSUFBSSxFQUFFO1lBQ3RILElBQUksQ0FBQyxjQUFjLENBQ2pCO2dCQUNFLFNBQVMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLGdCQUFnQjtnQkFDdkMsR0FBRyxFQUFFO29CQUNILENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVc7b0JBQzFCLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVc7aUJBQzNCO2FBQ0YsQ0FDRixDQUFDO1NBQ0g7YUFDSTtZQUNILE9BQU8sQ0FBQyxLQUFLLENBQUMsd05BQXdOLENBQUMsQ0FBQztZQUN4TyxPQUFPLENBQUMsR0FBRyxDQUFDLDJCQUEyQixHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztZQUN4RSxPQUFPLENBQUMsR0FBRyxDQUFDLHNCQUFzQixHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDOUQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxzQkFBc0IsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1NBQy9EO0lBQ0gsQ0FBQzs7Ozs7OztJQUlPLG9DQUFTOzs7Ozs7SUFBakIsVUFBa0IsU0FBZSxFQUFFLFFBQXVCO1FBQ3hELHNFQUFzRTtRQURyQyx5QkFBQSxFQUFBLGVBQXVCOzs7OztZQU1wRCxNQUFNLEdBQWlCLElBQUksQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDO1FBQ3hELHFEQUFxRDtRQUNyRCxvREFBb0Q7UUFDcEQsSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDekMsQ0FBQzs7Ozs7O0lBSU8saUNBQU07Ozs7O0lBQWQsVUFBZSxVQUFpQjtRQUM5QixzRUFBc0U7UUFDdEUsSUFBSSxDQUFDLGVBQWUsQ0FBRSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLG1CQUFtQixFQUFFLFVBQVUsQ0FBRSxDQUFDO0lBQzVGLENBQUM7Ozs7OztJQUlPLGtDQUFPOzs7OztJQUFmLFVBQWdCLFVBQWlCO1FBQy9CLDhDQUE4QztRQUM5QyxJQUFJLENBQUMsZUFBZSxDQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsbUJBQW1CLEVBQUUsVUFBVSxDQUFFLENBQUM7SUFDNUYsQ0FBQzs7Ozs7OztJQUlPLHFDQUFVOzs7Ozs7SUFBbEIsVUFBbUIsS0FBWSxFQUFFLFFBQXVCO1FBQ3RELGdFQUFnRTtRQURqQyx5QkFBQSxFQUFBLGVBQXVCOzs7Ozs7OztZQVNsRCxNQUFNLEdBQWlCO1lBQ3pCLEdBQUcsRUFBRTtnQkFDSCxDQUFDLEVBQUUsQ0FBRSxDQUFDLElBQUksQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDLENBQUUsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLO2dCQUNuRCxDQUFDLEVBQUUsQ0FBRSxDQUFDLElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDLENBQUUsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLO2FBQ3JEO1lBQ0QsU0FBUyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUztTQUMvQjtRQUVELElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3pDLENBQUM7Ozs7Ozs7SUFJTyxtQ0FBUTs7Ozs7O0lBQWhCLFVBQWlCLEtBQVksRUFBRSxRQUF1QjtRQUNwRCw4REFBOEQ7UUFEakMseUJBQUEsRUFBQSxlQUF1Qjs7Ozs7Ozs7WUFTaEQsTUFBTSxHQUFpQjtZQUN6QixHQUFHLEVBQUU7Z0JBQ0gsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxDQUFDO2dCQUN6QyxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUM7YUFDMUM7WUFDRCxTQUFTLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTO1NBQy9CO1FBQ0QsSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDekMsQ0FBQzs7Ozs7OztJQUlPLDJDQUFnQjs7Ozs7O0lBQXhCLFVBQXlCLEtBQVksRUFBRSxRQUF1QjtRQUM1RCxzRUFBc0U7UUFEakMseUJBQUEsRUFBQSxlQUF1Qjs7Ozs7Ozs7O1lBVXhELE1BQU0sR0FBaUI7WUFDekIsR0FBRyxFQUFFO2dCQUNILENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUM7Z0JBQzVCLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUM7YUFDN0I7WUFDRCxTQUFTLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTO1NBQy9CO1FBQ0QsSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDekMsQ0FBQzs7Ozs7OztJQUlPLDBDQUFlOzs7Ozs7SUFBdkIsVUFBd0IsWUFBbUIsRUFBRSxRQUF1QjtRQUNsRSxtRkFBbUY7UUFEeEMseUJBQUEsRUFBQSxlQUF1Qjs7Ozs7O1lBTzlELE1BQU0sR0FBRyxDQUFDOztZQUNWLE1BQU0sR0FBRyxDQUFDO1FBQ2QsSUFBSSxZQUFZLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUN4QixNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksR0FBRyxDQUFFLFlBQVksQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztTQUNwRTtRQUNELElBQUksWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDeEIsTUFBTSxHQUFHLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBRSxZQUFZLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7U0FDckU7O1lBRUcsTUFBTSxHQUFpQjtZQUN6QixHQUFHLEVBQUU7Z0JBQ0gsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNO2dCQUMzQixDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLE1BQU07YUFDNUI7WUFDRCxTQUFTLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTO1NBQy9CO1FBQ0QscURBQXFEO1FBQ3JELG9EQUFvRDtRQUNwRCxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBUUQsZ0ZBQWdGO0lBQ2hGLGdGQUFnRjtJQUNoRixnRkFBZ0Y7Ozs7Ozs7Ozs7SUFJeEUsMENBQWU7Ozs7Ozs7Ozs7SUFBdkIsVUFBd0IsV0FBeUIsRUFBRSxRQUFlO1FBQ2hFLHNEQUFzRDtRQUN0RCx1RUFBdUU7UUFDdkUsb0VBQW9FO1FBQ3BFLDZCQUE2QjtRQUM3Qix1R0FBdUc7UUFMekcsaUJBMkRDO1FBM0RrRCx5QkFBQSxFQUFBLGVBQWU7UUFPaEUsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFO1lBQ3hCLHNFQUFzRTtZQUN0RSxPQUFPO1NBQ1I7UUFFRCxJQUFJLENBQUMsbUJBQW1CLEdBQUcsS0FBSyxDQUFDO1FBQ2pDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEtBQUssV0FBVyxDQUFDLFNBQVMsRUFBRTtZQUNqRCxJQUFJLENBQUMsbUJBQW1CLEdBQUcsSUFBSSxDQUFDO1NBQ2pDOztZQUVHLGNBQWMsR0FBRyxXQUFXLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUzs7O1lBRTVELE9BQU8sR0FBVTs7WUFFbkIsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDbEIsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDbkI7UUFDRCxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ25DLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7Ozs7OztZQU0vQixXQUFXOzs7O1FBQUcsVUFBQyxTQUFpQjs7O2dCQUU5QixXQUFXLEdBQVU7O2dCQUV2QixDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRO2dCQUNsRSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRO2FBQ25FO1lBRUQsT0FBTyxFQUFFLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ2xELENBQUMsQ0FBQTtRQUVELDhDQUE4QztRQUM5QyxJQUFJLFFBQVEsRUFBRTtZQUNaLFFBQVEsR0FBRyxRQUFRLEdBQUcsSUFBSSxDQUFDO1NBQzVCO2FBQ0k7WUFDSCxRQUFRLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7U0FDaEQ7UUFDRCxJQUFJLENBQUMsZUFBZSxHQUFHO1lBQ3JCLGNBQWMsRUFBRSxjQUFjOztZQUM5QixXQUFXLEVBQUUsV0FBVzs7O1lBRXhCLFFBQVEsRUFBRSxRQUFROztZQUNsQixRQUFRLEVBQUUsR0FBRztTQUNkLENBQUM7UUFFRixJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7SUFFeEIsQ0FBQzs7Ozs7OztJQUlPLDBDQUFlOzs7Ozs7SUFBdkIsVUFBd0IsWUFBb0IsRUFBRSxVQUFpQjtRQUM3RCxzREFBc0Q7UUFEeEQsaUJBZ0ZDO1FBN0VDLElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRTtZQUN4Qiw4Q0FBOEM7WUFDOUMsT0FBTztTQUNSO1FBRUQsSUFBSSxDQUFDLG1CQUFtQixHQUFHLElBQUksQ0FBQztRQUVoQyw0QkFBNEI7UUFDNUIsWUFBWSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLHVCQUF1QixFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQ3BFLFlBQVksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxHQUFHLENBQUMsRUFBRSxZQUFZLENBQUMsQ0FBQzs7O1lBRzlELGNBQWMsR0FBRyxZQUFZLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTO1FBQ3ZELElBQUksQ0FBQyxjQUFjLEVBQUU7WUFDbkIsNkhBQTZIO1lBQzdILE9BQU87U0FDUjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQXVCRyxVQUFVLEdBQVU7O1lBRXRCLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ2xCLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ25COztZQUVHLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSzs7O1lBQ3pCLFNBQVMsR0FBRyxVQUFVLElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTs7O1lBRy9DLFdBQVc7Ozs7UUFBRyxVQUFDLFNBQWlCO1lBQ2xDLCtRQUErUTs7O2dCQUUzUSxXQUFXLEdBQUcsS0FBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUM7OztnQkFDekMsV0FBVyxHQUFVOztnQkFFdkIsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxXQUFXLEdBQUcsWUFBWSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUM7Z0JBQzVFLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLFlBQVksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDO2FBQzdFO1lBRUQsT0FBTzs7O2dCQUdMLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDO2dCQUMvQixDQUFDLEVBQUUsV0FBVyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQzthQUNoQyxDQUFDO1FBQ0osQ0FBQyxDQUFBO1FBRUQsOENBQThDO1FBQzlDLElBQUksQ0FBQyxlQUFlLEdBQUc7WUFDckIsY0FBYyxFQUFFLGNBQWM7O1lBQzlCLFdBQVcsRUFBRSxXQUFXOztZQUV4QixRQUFRLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJOztZQUM3QyxRQUFRLEVBQUUsR0FBRztTQUNkLENBQUM7UUFDRixJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7SUFFeEIsQ0FBQzs7Z0JBM3lDRixTQUFTLFNBQUU7O29CQUVWLFFBQVEsRUFBRSxVQUFVOztvQkFFcEIsUUFBUSxFQUFFLDBkQVNUO2lCQUNGOzs7O2dCQS9DcUQsVUFBVTtnQkFBb0IsTUFBTTs7O2tDQXNEdkYsU0FBUyxTQUFDLGNBQWMsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7Z0NBQzFDLFNBQVMsU0FBQyxZQUFZLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO2lDQUN4QyxTQUFTLFNBQUMsYUFBYSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtvQ0FDekMsU0FBUyxTQUFDLGdCQUFnQixFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTt5QkFFNUMsS0FBSzs7SUFxeENSLHVCQUFDO0NBQUEsQUEveUNELElBK3lDQztTQS94Q1ksZ0JBQWdCOzs7Ozs7SUFLM0IsMkNBQWlGOzs7OztJQUNqRix5Q0FBNkU7Ozs7O0lBQzdFLDBDQUErRTs7Ozs7SUFDL0UsNkNBQXFGOzs7OztJQUVyRixrQ0FBdUM7Ozs7O0lBRXZDLGdDQUEyQjs7Ozs7SUFDM0IsaUNBQTRCOzs7OztJQUM1QiwrQkFBd0I7Ozs7O0lBQ3hCLHlDQUE4Qjs7Ozs7SUFDOUIsd0NBQTZCOzs7OztJQUM3Qix1Q0FBNEI7Ozs7O0lBQzVCLHNDQUEyQjs7Ozs7SUFDM0IsOENBQW1DOzs7OztJQUNuQyw0Q0FBMEM7Ozs7O0lBQzFDLHNDQUEyQjs7Ozs7SUFDM0IsdUNBQWtDOzs7OztJQUNsQywyQ0FBOEM7Ozs7O0lBQzlDLDhDQUFtQzs7Ozs7SUFDbkMsOENBQXFDOzs7OztJQUNyQyxvQ0FBcUI7Ozs7O0lBQ3JCLG9DQUF5Qjs7Ozs7SUFDekIsK0NBQW1DOzs7OztJQUNuQyx1Q0FBNEI7Ozs7O0lBQzVCLG9DQUF5Qjs7Ozs7SUFDekIsaUNBQXNCOzs7OztJQUN0Qix1Q0FBMkI7Ozs7O0lBQzNCLDBDQUE4Qjs7Ozs7SUFDOUIsK0NBQWlDOzs7OztJQUNqQywrQ0FBb0M7Ozs7O0lBQ3BDLHlDQUE4Qjs7Ozs7SUFDOUIsMkNBQXVDOzs7OztJQUV2QyxvQ0FBeUI7Ozs7O0lBQ3pCLG9DQUF5Qjs7Ozs7SUFDekIsbURBQXdDOzs7OztJQXNLeEMsd0NBOENDOzs7OztJQXVCRCx1Q0FzQ0M7Ozs7O0lBSUQsd0NBc0JDOzs7OztJQUlELHVDQXNGQzs7Ozs7SUFJRCx1Q0FrREM7Ozs7O0lBSUQscUNBOENDOzs7OztJQUlELHNDQUdDOzs7OztJQUlELHNDQWNDOzs7OztJQUlELDBDQUVDOzs7OztJQXdCRCx5Q0E4R0M7Ozs7O0lBenJCYSw4QkFBc0I7Ozs7O0lBQ3RCLGdDQUFvQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3ksIEVsZW1lbnRSZWYsIFZpZXdDaGlsZCwgSW5wdXQsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUGFuWm9vbUNvbmZpZyB9IGZyb20gJy4vcGFuem9vbS1jb25maWcnO1xuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuL3Bhbnpvb20tcG9pbnQnO1xuaW1wb3J0IHsgUGFuWm9vbU1vZGVsIH0gZnJvbSAnLi9wYW56b29tLW1vZGVsJztcbmltcG9ydCB7IFBhblpvb21BUEkgfSBmcm9tICcuL3Bhbnpvb20tYXBpJztcbmltcG9ydCB7IFJlY3QgfSBmcm9tICcuL3Bhbnpvb20tcmVjdCc7XG5kZWNsYXJlIHZhciAkOiBhbnk7XG5cbi8qXG52YXIgb2xkQWRkRXZlbnRMaXN0ZW5lciA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuXG5FdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyOiBhbnksIG9wdGlvbnM6IGFueSA9IG51bGwpXG57XG4gIGNvbnNvbGUubG9nKCdldmVudE5hbWU6JywgZXZlbnROYW1lKTtcbiAgb2xkQWRkRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBldmVudEhhbmRsZXIoZXZlbnQpO1xuICB9LCBvcHRpb25zKTtcbn07XG4qL1xuXG5pbnRlcmZhY2UgWm9vbUFuaW1hdGlvbiB7XG4gIGRlbHRhWm9vbUxldmVsOiBudW1iZXI7XG4gIHBhblN0ZXBGdW5jOiBGdW5jdGlvbjtcbiAgZHVyYXRpb246IG51bWJlcjtcbiAgcHJvZ3Jlc3M6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFBvc2l0aW9uIHtcbiAgeD86IG51bWJlcjtcbiAgeT86IG51bWJlcjtcbiAgbGVuZ3RoPzogbnVtYmVyO1xufVxuXG5AQ29tcG9uZW50KCB7XG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpjb21wb25lbnQtc2VsZWN0b3JcbiAgc2VsZWN0b3I6ICdwYW4tem9vbScsXG4gIC8vIHdlIGRvbid0IHdhbnQgdG8ga2lsbCBjaGFuZ2UgZGV0ZWN0aW9uIGZvciBhbGwgZWxlbWVudHMgYmVuZWF0aCB0aGlzLCBzbyB3ZSBkb24ndCBzZXQgT25QdXNoLiAgQ2hpbGQgdmlld3MgY2FuIGltcGxlbWVudCBPblB1c2ggaWYgdGhlIGRldmVsb3BlciB3YW50cyB0by4gIFdlIGNhbiBnZXQgYXdheSB3aXRoIHRoaXMgYmVjYXVzZSB0aGUga3doZWVsIGRpcmVjdGl2ZSBydW5zIG91dHNpZGUgb2YgQW5ndWxhciwgc28gaXQgZG9lc250IHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvbi5cbiAgdGVtcGxhdGU6IGBcbjxkaXYgI2ZyYW1lRWxlbWVudCBjbGFzcz1cInBhbi16b29tLWZyYW1lXCIgc3R5bGU9XCJwb3NpdGlvbjpyZWxhdGl2ZTsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgb3ZlcmZsb3c6IGhpZGRlbjtcIj5cbiAgPGRpdiAjcGFuRWxlbWVudCBjbGFzcz1cInBhbkVsZW1lbnRcIiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogMHB4OyB0b3A6IDBweDtcIj5cbiAgICA8ZGl2ICN6b29tRWxlbWVudCBjbGFzcz1cInpvb21FbGVtZW50XCI+XG4gICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC9kaXY+XG48ZGl2ICNwYW56b29tT3ZlcmxheSBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyByaWdodDogMDsgYm90dG9tOiAwOyBvcGFjaXR5OiAwOyBkaXNwbGF5OiBub25lOyBwb2ludGVyLWV2ZW50czogbm9uZTtcIj48L2Rpdj5cbiAgYFxufSApXG5cbmV4cG9ydCBjbGFzcyBQYW5ab29tQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuXG4gIGNvbnN0cnVjdG9yICggcHJpdmF0ZSBlbDogRWxlbWVudFJlZixcbiAgICAgICAgICAgICAgICBwcml2YXRlIHpvbmU6IE5nWm9uZSApIHt9XG5cbiAgQFZpZXdDaGlsZCgnZnJhbWVFbGVtZW50JywgeyBzdGF0aWM6IHRydWUgfSkgcHJpdmF0ZSBmcmFtZUVsZW1lbnRSZWY6IEVsZW1lbnRSZWY7XG4gIEBWaWV3Q2hpbGQoJ3BhbkVsZW1lbnQnLCB7IHN0YXRpYzogdHJ1ZSB9KSBwcml2YXRlIHBhbkVsZW1lbnRSZWY6IEVsZW1lbnRSZWY7XG4gIEBWaWV3Q2hpbGQoJ3pvb21FbGVtZW50JywgeyBzdGF0aWM6IHRydWUgfSkgcHJpdmF0ZSB6b29tRWxlbWVudFJlZjogRWxlbWVudFJlZjtcbiAgQFZpZXdDaGlsZCgncGFuem9vbU92ZXJsYXknLCB7IHN0YXRpYzogdHJ1ZSB9KSBwcml2YXRlIHBhbnpvb21PdmVybGF5UmVmOiBFbGVtZW50UmVmO1xuXG4gIEBJbnB1dCgpIHByaXZhdGUgY29uZmlnOiBQYW5ab29tQ29uZmlnO1xuXG4gIHByaXZhdGUgYmFzZTogUGFuWm9vbU1vZGVsOyAvLyB0aGlzIGlzIHdoYXQgdGhlIHBhbi96b29tIHZpZXcgaXMgYmVmb3JlIGEgem9vbSBhbmltYXRpb24gYmVnaW5zIGFuZCBhZnRlciBpdCBlbmRzLiAgSXQgYWxzbyB1cGRhdGVzIHdpdGggZXZlcnkgbW91c2UgZHJhZyBvciBmcmVlWm9vbVxuICBwcml2YXRlIG1vZGVsOiBQYW5ab29tTW9kZWw7IC8vIHRoaXMgaXMgdXNlZCBmb3IgaW5jcmVtZW50YWwgY2hhbmdlcyB0byB0aGUgcGFuL3pvb20gdmlldyBkdXJpbmcgZWFjaCBhbmltYXRpb24gZnJhbWUuICBTZXR0aW5nIGl0IHdpbGwgdXBkYXRlIHRoZSBwYW4vem9vbSBjb29yZGluYXRlcyBvbiB0aGUgbmV4dCBjYWxsIHRvIHVwZGF0ZURPTSgpLiAgTm90IHVzZWQgZHVyaW5nIG1vdXNlIGRyYWcgb3IgZnJlZVpvb21cbiAgcHJpdmF0ZSBhcGk6IFBhblpvb21BUEk7XG4gIHByaXZhdGUgY29udGVudEhlaWdodDogbnVtYmVyO1xuICBwcml2YXRlIGNvbnRlbnRXaWR0aDogbnVtYmVyO1xuICBwcml2YXRlIGZyYW1lSGVpZ2h0OiBudW1iZXI7XG4gIHByaXZhdGUgZnJhbWVXaWR0aDogbnVtYmVyO1xuICBwcml2YXRlIGxhc3RNb3VzZUV2ZW50VGltZTogbnVtYmVyO1xuICBwcml2YXRlIHByZXZpb3VzUG9zaXRpb246IFBvc2l0aW9uID0gbnVsbDtcbiAgcHJpdmF0ZSBpc0RyYWdnaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgcGFuVmVsb2NpdHk6IFBvaW50ID0gbnVsbDtcbiAgcHJpdmF0ZSBhbmltYXRpb25QYXJhbXM6IFpvb21BbmltYXRpb24gPSBudWxsO1xuICBwcml2YXRlIGpRdWVyeUZyYW1lRWxlbWVudDogSlF1ZXJ5O1xuICBwcml2YXRlIGFuaW1hdGlvbkZyYW1lRnVuYzogRnVuY3Rpb247IC8vIHJlZmVyZW5jZSB0byB0aGUgYXBwcm9wcmlhdGUgZ2V0QW5pbWF0aW9uRnJhbWUgZnVuY3Rpb24gZm9yIHRoZSBjbGllbnQgYnJvd3NlclxuICBwcml2YXRlIGxhc3RUaWNrID0gMDtcbiAgcHJpdmF0ZSBpc0Nocm9tZSA9IGZhbHNlO1xuICBwcml2YXRlIHdpbGxDaGFuZ2VOZXh0RnJhbWUgPSB0cnVlOyAvLyB1c2VkIGZvciBzY2FsaW5nIGluIENocm9tZVxuICBwcml2YXRlIGFuaW1hdGlvbklkOiBudW1iZXI7XG4gIHByaXZhdGUgaXNNb2JpbGUgPSBmYWxzZTtcbiAgcHJpdmF0ZSBzY2FsZTogbnVtYmVyO1xuICBwcml2YXRlIGlzRmlyc3RTeW5jID0gdHJ1ZTtcbiAgcHJpdmF0ZSBsYXN0Q2xpY2tQb2ludDogUG9pbnQ7XG4gIHByaXZhdGUgYWNjZWxlcmF0ZWRGcmFtZVJlZjogYW55O1xuICBwcml2YXRlIHpvb21MZXZlbElzQ2hhbmdpbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBkcmFnRmluaXNoaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgZHJhZ01vdXNlQnV0dG9uOiBudW1iZXIgPSBudWxsO1xuXG4gIHByaXZhdGUgbWF4U2NhbGU6IG51bWJlcjsgLy8gdGhlIGhpZ2hlc3Qgc2NhbGUgKGZ1cnRoZXN0IHpvb21lZCBpbikgdGhhdCB3ZSB3aWxsIGFsbG93IGluIGZyZWUgem9vbSBtb2RlIChjYWxjdWxhdGVkKVxuICBwcml2YXRlIG1pblNjYWxlOiBudW1iZXI7IC8vIHRoZSBzbWFsbGVzdCBzY2FsZSAoZnVydGhlc3Qgem9vbWVkIG91dCkgdGhhdCB3ZSB3aWxsIGFsbG93IGluIGZyZWUgem9vbSBtb2RlIChjYWxjdWxhdGVkKVxuICBwcml2YXRlIG1pbmltdW1BbGxvd2VkWm9vbUxldmVsOiBudW1iZXI7XG5cblxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIC8vIGNvbnNvbGUubG9nKCdQYW5ab29tQ29tcG9uZW50OiBuZ09uSW5pdCgpOiBpbml0aWFsaXppbmcgUGFuWm9vbUNvbXBvbmVudCcpO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLmluaXRpYWxab29tVG9GaXQpIHtcbiAgICAgIHRoaXMuYmFzZSA9IHRoaXMuY2FsY1pvb21Ub0ZpdCh0aGlzLmNvbmZpZy5pbml0aWFsWm9vbVRvRml0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmJhc2UgPSB7XG4gICAgICAgIHpvb21MZXZlbDogdGhpcy5jb25maWcuaW5pdGlhbFpvb21MZXZlbCxcbiAgICAgICAgcGFuOiB7XG4gICAgICAgICAgeDogdGhpcy5jb25maWcuaW5pdGlhbFBhblgsXG4gICAgICAgICAgeTogdGhpcy5jb25maWcuaW5pdGlhbFBhbllcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLm1vZGVsID0ge1xuICAgICAgem9vbUxldmVsOiB0aGlzLmJhc2Uuem9vbUxldmVsLFxuICAgICAgaXNQYW5uaW5nOiBmYWxzZSwgLy8gT25seSB0cnVlIGlmIHBhbm5pbmcgaXMgYWN0dWFsbHkgdGFraW5nIHBsYWNlLCBub3QganVzdCBhZnRlciBtb3VzZWRvd25cbiAgICAgIHBhbjoge1xuICAgICAgICB4OiB0aGlzLmJhc2UucGFuLngsXG4gICAgICAgIHk6IHRoaXMuYmFzZS5wYW4ueVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmNvbmZpZy5tb2RlbENoYW5nZWQubmV4dCh0aGlzLm1vZGVsKTtcblxuICAgIC8vIGNyZWF0ZSBwdWJsaWMgQVBJXG4gICAgdGhpcy5hcGkgPSB7XG4gICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICBjaGFuZ2Vab29tTGV2ZWw6IHRoaXMuem9vbVRvTGV2ZWxBbmRQb2ludC5iaW5kKHRoaXMpLFxuICAgICAgem9vbUluOiB0aGlzLnpvb21JblRvTGFzdENsaWNrUG9pbnQuYmluZCh0aGlzKSxcbiAgICAgIHpvb21PdXQ6IHRoaXMuem9vbU91dEZyb21MYXN0Q2xpY2tQb2ludC5iaW5kKHRoaXMpLFxuICAgICAgem9vbVRvRml0OiB0aGlzLnpvb21Ub0ZpdC5iaW5kKHRoaXMpLFxuICAgICAgcmVzZXRWaWV3OiB0aGlzLnJlc2V0Vmlldy5iaW5kKHRoaXMpLFxuICAgICAgZ2V0Vmlld1Bvc2l0aW9uOiB0aGlzLmdldFZpZXdQb3NpdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgZ2V0TW9kZWxQb3NpdGlvbjogdGhpcy5nZXRNb2RlbFBvc2l0aW9uLmJpbmQodGhpcyksXG4gICAgICBwYW5Ub1BvaW50OiB0aGlzLnBhblRvUG9pbnQuYmluZCh0aGlzKSxcbiAgICAgIHBhbkRlbHRhOiB0aGlzLnBhbkRlbHRhLmJpbmQodGhpcyksXG4gICAgICBwYW5EZWx0YVBlcmNlbnQ6IHRoaXMucGFuRGVsdGFQZXJjZW50LmJpbmQodGhpcyksXG4gICAgICBwYW5EZWx0YUFic29sdXRlOiB0aGlzLnBhbkRlbHRhQWJzb2x1dGUuYmluZCh0aGlzKVxuICAgIH07XG5cbiAgICB0aGlzLmNvbmZpZy5hcGkubmV4dCh0aGlzLmFwaSk7XG5cbiAgICBpZiAodGhpcy5jb25maWcuZnJlZU1vdXNlV2hlZWwpIHtcbiAgICAgIHRoaXMuc2NhbGUgPSB0aGlzLmdldENzc1NjYWxlKHRoaXMuY29uZmlnLmluaXRpYWxab29tTGV2ZWwpO1xuICAgICAgbGV0IG1heFpvb21MZXZlbCA9IHRoaXMuY29uZmlnLnpvb21MZXZlbHMgLSAxO1xuICAgICAgdGhpcy5tYXhTY2FsZSA9IHRoaXMuZ2V0Q3NzU2NhbGUobWF4Wm9vbUxldmVsKTtcbiAgICAgIHRoaXMubWluU2NhbGUgPSB0aGlzLmdldENzc1NjYWxlKDApO1xuICAgIH1cblxuICAgIHRoaXMubWluaW11bUFsbG93ZWRab29tTGV2ZWwgPSAwO1xuICAgIGlmICh0aGlzLmNvbmZpZy5rZWVwSW5Cb3VuZHMpIHtcbiAgICAgIHRoaXMubWluaW11bUFsbG93ZWRab29tTGV2ZWwgPSB0aGlzLmNvbmZpZy5uZXV0cmFsWm9vbUxldmVsO1xuICAgICAgdGhpcy5taW5TY2FsZSA9IHRoaXMuZ2V0Q3NzU2NhbGUodGhpcy5jb25maWcubmV1dHJhbFpvb21MZXZlbCk7XG4gICAgfVxuXG4gICAgdGhpcy5hY2NlbGVyYXRlZEZyYW1lUmVmID0gdGhpcy56b29tRWxlbWVudFJlZjtcbiAgICAvLyBjb25zb2xlLmxvZygnZnJhbWVIZWlnaHQ6JywgdGhpcy5mcmFtZUhlaWdodCk7XG4gICAgLy8gY29uc29sZS5sb2coJ2ZyYW1lV2lkdGg6JywgdGhpcy5mcmFtZVdpZHRoKTtcblxuICAgICg8YW55PnRoaXMuYWNjZWxlcmF0ZWRGcmFtZVJlZi5uYXRpdmVFbGVtZW50LnN0eWxlKS53aWxsQ2hhbmdlID0gJ3RyYW5zZm9ybSc7XG4gICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuc2VhcmNoKCdDaHJvbWUnKSA+PSAwKSB7XG4gICAgICB0aGlzLmlzQ2hyb21lID0gdHJ1ZTtcbiAgICAgIHRoaXMuYWNjZWxlcmF0ZWRGcmFtZVJlZi5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVaKDApJztcbiAgICB9XG5cbiAgICB0aGlzLmFuaW1hdGlvblRpY2socGVyZm9ybWFuY2Uubm93KCkpO1xuICAgIHRoaXMuc2NhbGUgPSB0aGlzLmdldENzc1NjYWxlKHRoaXMuYmFzZS56b29tTGV2ZWwpO1xuICAgIHRoaXMuaXNGaXJzdFN5bmMgPSBmYWxzZTtcbiAgICBzd2l0Y2ggKHRoaXMuY29uZmlnLmRyYWdNb3VzZUJ1dHRvbikge1xuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIHRoaXMuZHJhZ01vdXNlQnV0dG9uID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICB0aGlzLmRyYWdNb3VzZUJ1dHRvbiA9IDE7XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhciggKCkgPT4gdGhpcy5mcmFtZUVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdhdXhjbGljaycsIHRoaXMucHJldmVudERlZmF1bHQgKSApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCAoKSA9PiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXMucHJldmVudERlZmF1bHQgKSApO1xuICAgICAgICB0aGlzLmRyYWdNb3VzZUJ1dHRvbiA9IDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5kcmFnTW91c2VCdXR0b24gPSAwOyAvLyBsZWZ0XG4gICAgfVxuXG5cbiAgfVxuXG5cblxuICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IG5nQWZ0ZXJWaWV3SW5pdCgpJyk7XG5cbiAgICB0aGlzLmpRdWVyeUZyYW1lRWxlbWVudCA9ICQoJy5wYW4tem9vbS1mcmFtZScpO1xuICAgIHRoaXMuY29udGVudEhlaWdodCA9ICQoJy56b29tRWxlbWVudCcpLmNoaWxkcmVuKCkuaGVpZ2h0KCk7XG4gICAgdGhpcy5jb250ZW50V2lkdGggPSAkKCcuem9vbUVsZW1lbnQnKS5jaGlsZHJlbigpLndpZHRoKCk7XG4gICAgdGhpcy5mcmFtZUhlaWdodCA9IHRoaXMualF1ZXJ5RnJhbWVFbGVtZW50LmhlaWdodCgpO1xuICAgIHRoaXMuZnJhbWVXaWR0aCA9IHRoaXMualF1ZXJ5RnJhbWVFbGVtZW50LndpZHRoKCk7XG5cbiAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoICgpID0+IHRoaXMuYW5pbWF0aW9uRnJhbWVGdW5jID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApO1xuICAgIC8vIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhciggKCkgPT4gdGhpcy53aGVlbEFuaW1hdGlvbkZyYW1lRnVuYyA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKTtcblxuXG4gICAgaWYgKHRoaXMuaXNNb2JpbGVEZXZpY2UoKSnCoHtcbiAgICAgIHRoaXMuaXNNb2JpbGUgPSB0cnVlO1xuICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCAoKSA9PiB0aGlzLmZyYW1lRWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uVG91Y2hTdGFydCApICk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCAoKSA9PiB0aGlzLmZyYW1lRWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZWRvd24gKSApO1xuICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCAoKSA9PiB0aGlzLmZyYW1lRWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgdGhpcy5vbkRibENsaWNrICkgKTtcbiAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhciggKCkgPT4gdGhpcy5mcmFtZUVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIChldmVudCkgPT4gdGhpcy5hbmltYXRpb25GcmFtZUZ1bmMoICgpID0+IHRoaXMub25Nb3VzZVdoZWVsKGV2ZW50KSApLCB7IHBhc3NpdmU6IHRydWUgfSApICk7XG4gICAgfVxuXG4gIH1cblxuXG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IG5nT25EZXN0cm95KCknKTtcbiAgICBpZiAodGhpcy5pc01vYmlsZSkge1xuICAgICAgdGhpcy5mcmFtZUVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuZnJhbWVFbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlZG93bik7XG4gICAgICB0aGlzLmZyYW1lRWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgKGV2ZW50KSA9PiB0aGlzLmFuaW1hdGlvbkZyYW1lRnVuYyggKCkgPT4gdGhpcy5vbk1vdXNlV2hlZWwoZXZlbnQpICksIHsgcGFzc2l2ZTogdHJ1ZSB9ICk7XG4gICAgICB0aGlzLmZyYW1lRWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgdGhpcy5vbkRibENsaWNrKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uRnJhbWVGdW5jICYmIHRoaXMuYW5pbWF0aW9uSWQpIHtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbklkKTtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLmNvbmZpZy5kcmFnTW91c2VCdXR0b24pIHtcbiAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgIHRoaXMuZHJhZ01vdXNlQnV0dG9uID0gMTtcbiAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCAoKSA9PiB0aGlzLmZyYW1lRWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2F1eGNsaWNrJywgdGhpcy5wcmV2ZW50RGVmYXVsdCApICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoICgpID0+IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcy5wcmV2ZW50RGVmYXVsdCApICk7XG4gICAgICAgIHRoaXMuZHJhZ01vdXNlQnV0dG9uID0gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cblxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gRU5EIE9GIExJRkVDWUNMRSBIT09LUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuXG5cblxuXG5cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gRVZFTlQgSEFORExFUlMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cblxuICBwcml2YXRlIG9uTW91c2VXaGVlbCA9IChldmVudDogV2hlZWxFdmVudCkgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKCdQYW5ab29tQ29tcG9uZW50OiBPbk1vdXNlV2hlZWwoKSBldmVudDonLCBldmVudCk7XG5cbiAgICBpZiAoIShldmVudCAmJiBldmVudC5wYWdlWCAmJiBldmVudC5wYWdlWSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBsZXQgZXZlbnQgPSBlLmV2ZW50O1xuICAgIGxldCBkZWx0YVkgPSBldmVudC5kZWx0YVk7XG5cbiAgICBpZiAodGhpcy5jb25maWcuem9vbU9uTW91c2VXaGVlbCkge1xuICAgICAgLy8gZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uUGFyYW1zKSB7XG4gICAgICAgIHJldHVybjsgLy8gYWxyZWFkeSB6b29taW5nXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5jb25maWcuaW52ZXJ0TW91c2VXaGVlbCkge1xuICAgICAgICBkZWx0YVkgPSAtZGVsdGFZO1xuICAgICAgfVxuXG4gICAgICAvLyBjb25zb2xlLmxvZygnZGVsdGFZOicsIGV2ZW50LmRlbHRhWSk7XG5cbiAgICAgIC8vIGxldCBzaWduID0gZXZlbnQuZGVsdGFZIC8gTWF0aC5hYnMoZXZlbnQuZGVsdGFZKTtcblxuICAgICAgbGV0IGNsaWNrUG9pbnQ6IFBvaW50ID0ge1xuICAgICAgICB4OiBldmVudC5wYWdlWCAtIHRoaXMualF1ZXJ5RnJhbWVFbGVtZW50Lm9mZnNldCgpLmxlZnQsXG4gICAgICAgIHk6IGV2ZW50LnBhZ2VZIC0gdGhpcy5qUXVlcnlGcmFtZUVsZW1lbnQub2Zmc2V0KCkudG9wXG4gICAgICB9O1xuXG4gICAgICB0aGlzLmxhc3RDbGlja1BvaW50ID0gY2xpY2tQb2ludDtcblxuICAgICAgaWYgKHRoaXMuY29uZmlnLmZyZWVNb3VzZVdoZWVsKSB7XG4gICAgICAgIC8vIGZyZWUgd2hlZWwgc2Nyb2xsXG4gICAgICAgIHRoaXMuZnJlZVpvb20oY2xpY2tQb2ludCwgZGVsdGFZKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBsZXQgc2lnbiA9IE1hdGguc2lnbihldmVudC5kZWx0YVkpO1xuICAgICAgICBpZiAoZGVsdGFZIDwgMCkge1xuICAgICAgICAgIHRoaXMuem9vbUluKGNsaWNrUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlbHRhWSA+IDApIHtcbiAgICAgICAgICB0aGlzLnpvb21PdXQoY2xpY2tQb2ludCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG5cbiAgLyoqXG4gICAqIE1ldGhvZCB3aWxsIGNoZWNrIGlmICdjaGlsZCcgbm9kZSBlbGVtZW50IGlzIGEgY2hpbGQgb2ZcbiAgICogcGFyZW50IG5vZGUgd2l0aCBjbGFzcyAnY2xhc3NOYW1lJ1xuICAgKiBAcGFyYW0gY2xhc3NOYW1lXG4gICAqIEBwYXJhbSBjaGlsZFxuICAgKi9cbiAgcHJpdmF0ZSBpc1BhcmVudEVsZW1lbnQoY2xhc3NOYW1lLCBjaGlsZCkge1xuICAgIGxldCBub2RlID0gY2hpbGQucGFyZW50Tm9kZTtcbiAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5jbGFzc0xpc3QgJiYgbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG5cblxuICBwcml2YXRlIG9uTW91c2Vkb3duID0gKGV2ZW50OiBhbnkpID0+IHtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogb25Nb3VzZWRvd24oKScsIGV2ZW50KTtcblxuICAgIC8qIENoZWNrIGlmIGNsaWNrZWQgbG9jYXRpb24gaXMgaW5zaWRlIGVsZW1lbnQgZnJvbSB3aGljaFxuICAgICAgIGRyYWdnaW5nIGlzIHByZXZlbnRlZC4gKi9cbiAgICBpZiAodGhpcy5jb25maWcubm9EcmFnRnJvbUVsZW1lbnRDbGFzc1xuICAgICAgICAmJiB0aGlzLmlzUGFyZW50RWxlbWVudCh0aGlzLmNvbmZpZy5ub0RyYWdGcm9tRWxlbWVudENsYXNzLCBldmVudC5zcmNFbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5idXR0b24gPT09IHRoaXMuZHJhZ01vdXNlQnV0dG9uIHx8IGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIC8vIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICB0aGlzLmRyYWdGaW5pc2hpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMucGFuVmVsb2NpdHkgPSBudWxsO1xuXG4gICAgICBpZiAodGhpcy5jb25maWcucGFuT25DbGlja0RyYWcpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91c1Bvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IGV2ZW50LnBhZ2VYLFxuICAgICAgICAgIHk6IGV2ZW50LnBhZ2VZXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGFzdE1vdXNlRXZlbnRUaW1lID0gZXZlbnQudGltZVN0YW1wO1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLm1vZGVsLmlzUGFubmluZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLmlzTW9iaWxlKSB7XG4gICAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCAoKSA9PiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMub25Ub3VjaEVuZCwgZmFsc2UgKSApOyAvLyBsZWF2ZSB0aGlzIG9uIGRvY3VtZW50XG4gICAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCAoKSA9PiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlLCB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmU6IGZhbHNlIH0gKSApOyAvLyBsZWF2ZSB0aGlzIG9uIGRvY3VtZW50XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCAoKSA9PiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLCB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmU6IGZhbHNlIH0gKSApOyAvLyBsZWF2ZSB0aGlzIG9uIGRvY3VtZW50XG4gICAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCAoKSA9PiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXAgKSApOyAvLyBsZWF2ZSB0aGlzIG9uIGRvY3VtZW50XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG5cblxuICBwcml2YXRlIG9uVG91Y2hTdGFydCA9IChldmVudDogVG91Y2hFdmVudCkgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKCdQYW5ab29tQ29tcG9uZW50OiBvblRvdWNoU3RhcnQoKScsIGV2ZW50KTtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogb25Ub3VjaFN0YXJ0KCk6IHRvdWNoZXM6JywgZXZlbnQudG91Y2hlcy5sZW5ndGgpO1xuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAvLyBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgLy8gbXVsdGlwbGUgdG91Y2hlcywgZ2V0IHJlYWR5IGZvciB6b29taW5nXG5cbiAgICAgIC8vIENhbGN1bGF0ZSB4IGFuZCB5IGRpc3RhbmNlIGJldHdlZW4gdG91Y2ggZXZlbnRzXG4gICAgICBsZXQgeCA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggLSBldmVudC50b3VjaGVzWzFdLnBhZ2VYO1xuICAgICAgbGV0IHkgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGxlbmd0aCBiZXR3ZWVuIHRvdWNoIHBvaW50cyB3aXRoIHB5dGhhZ29yYXNcbiAgICAgIC8vIFRoZXJlIGlzIG5vIHJlYXNvbiB0byB1c2UgTWF0aC5wb3cgYW5kIE1hdGguc3FydCBhcyB3ZVxuICAgICAgLy8gb25seSB3YW50IGEgcmVsYXRpdmUgbGVuZ3RoIGFuZCBub3QgdGhlIGV4YWN0IG9uZS5cbiAgICAgIHRoaXMucHJldmlvdXNQb3NpdGlvbiA9IHtcbiAgICAgICAgbGVuZ3RoOiB4ICogeCArIHkgKiB5XG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLm9uTW91c2Vkb3duKGV2ZW50KTtcbiAgfVxuXG5cblxuICBwcml2YXRlIG9uTW91c2VNb3ZlID0gKGV2ZW50OiBhbnkpID0+IHtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogb25Nb3VzZU1vdmUoKScsIGV2ZW50KTtcbiAgICAvLyBjb25zb2xlLmxvZyhgUGFuWm9vbUNvbXBvbmVudDogb25Nb3VzZU1vdmUoKTogZXZlbnQudGltZVN0YW1wOmAsIGV2ZW50LnRpbWVTdGFtcCk7XG4gICAgLy8gdGltZXN0YW1wIC0gMTA1ODcuODc5OTk5OTk5MTMyIC0gbWlsbGlzZWNvbmRzXG4gICAgLy8gQ2FsbGVkIHdoZW4gbW92aW5nIHRoZSBtb3VzZSB3aXRoIHRoZSBsZWZ0IGJ1dHRvbiBkb3duXG5cbiAgICAvLyBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgaWYgKCEoZXZlbnQgJiYgZXZlbnQucGFnZVggJiYgZXZlbnQucGFnZVkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IG5vdyA9IGV2ZW50LnRpbWVTdGFtcDtcbiAgICBsZXQgdGltZVNpbmNlTGFzdE1vdXNlRXZlbnQgPSAobm93IC0gdGhpcy5sYXN0TW91c2VFdmVudFRpbWUpIC8gMTAwMDsgLy8gb3JpZ1xuICAgIC8vIGxldCB0aW1lU2luY2VMYXN0TW91c2VFdmVudCA9IChub3cgLSB0aGlzLmxhc3RNb3VzZUV2ZW50VGltZSk7XG4gICAgdGhpcy5sYXN0TW91c2VFdmVudFRpbWUgPSBub3c7XG4gICAgbGV0IGRyYWdEZWx0YSA9IHtcbiAgICAgIC8vIGEgcmVwcmVzZW50YXRpb24gb2YgaG93IGZhciBlYWNoIGNvb3JkaW5hdGUgaGFzIG1vdmVkIHNpbmNlIHRoZSBsYXN0IHRpbWUgaXQgd2FzIG1vdmVkXG4gICAgICB4OiBldmVudC5wYWdlWCAtIHRoaXMucHJldmlvdXNQb3NpdGlvbi54LFxuICAgICAgeTogZXZlbnQucGFnZVkgLSB0aGlzLnByZXZpb3VzUG9zaXRpb24ueVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5jb25maWcua2VlcEluQm91bmRzKSB7XG4gICAgICBsZXQgdG9wTGVmdENvcm5lclZpZXcgPSB0aGlzLmdldFZpZXdQb3NpdGlvbiggeyB4OiAwLCB5OiAwIH0gKTtcbiAgICAgIGxldCBib3R0b21SaWdodENvcm5lclZpZXcgPSB0aGlzLmdldFZpZXdQb3NpdGlvbiggeyB4OiB0aGlzLmNvbnRlbnRXaWR0aCwgeTogdGhpcy5jb250ZW50SGVpZ2h0IH0gKTtcblxuXG4gICAgICBpZiAodG9wTGVmdENvcm5lclZpZXcueCA+IDAgJiYgZHJhZ0RlbHRhLnggPiAwKSB7XG4gICAgICAgIGRyYWdEZWx0YS54ICo9IE1hdGgubWluKDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucG93KHRvcExlZnRDb3JuZXJWaWV3LngsIC10aGlzLmNvbmZpZy5rZWVwSW5Cb3VuZHNEcmFnUHVsbGJhY2spXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRvcExlZnRDb3JuZXJWaWV3LnkgPiAwICYmIGRyYWdEZWx0YS55ID4gMCkge1xuICAgICAgICBkcmFnRGVsdGEueSAqPSBNYXRoLm1pbigxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucG93KHRvcExlZnRDb3JuZXJWaWV3LnksIC10aGlzLmNvbmZpZy5rZWVwSW5Cb3VuZHNEcmFnUHVsbGJhY2spXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChib3R0b21SaWdodENvcm5lclZpZXcueCA8IHRoaXMuY29udGVudFdpZHRoICYmIGRyYWdEZWx0YS54IDwgMCkge1xuICAgICAgICBkcmFnRGVsdGEueCAqPSBNYXRoLm1pbigxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucG93KHRoaXMuY29udGVudFdpZHRoIC0gYm90dG9tUmlnaHRDb3JuZXJWaWV3LngsIC10aGlzLmNvbmZpZy5rZWVwSW5Cb3VuZHNEcmFnUHVsbGJhY2spXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJvdHRvbVJpZ2h0Q29ybmVyVmlldy55IDwgdGhpcy5jb250ZW50SGVpZ2h0ICYmIGRyYWdEZWx0YS55IDwgMCkge1xuICAgICAgICBkcmFnRGVsdGEueSAqPSBNYXRoLm1pbigxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5wb3codGhpcy5jb250ZW50SGVpZ2h0IC0gYm90dG9tUmlnaHRDb3JuZXJWaWV3LnksIC10aGlzLmNvbmZpZy5rZWVwSW5Cb3VuZHNEcmFnUHVsbGJhY2spXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBub3cgcGFuIHRoZSB2aWV3XG4gICAgbGV0IGRlbHRhOiBQb2ludCA9IHtcbiAgICAgIHg6IGRyYWdEZWx0YS54IHx8IDAsXG4gICAgICB5OiBkcmFnRGVsdGEueSB8fCAwXG4gICAgfTtcbiAgICB0aGlzLm1vZGVsLnBhbi54ICs9IGRlbHRhLng7XG4gICAgdGhpcy5tb2RlbC5wYW4ueSArPSBkZWx0YS55O1xuICAgIHRoaXMuc3luY0Jhc2VUb01vZGVsKCk7XG4gICAgdGhpcy5hbmltYXRpb25UaWNrKHBlcmZvcm1hbmNlLm5vdygpKTtcblxuICAgIGlmICghdGhpcy5tb2RlbC5pc1Bhbm5pbmcpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCBpbXByb3ZlIHRoZSBwZXJmb3JtYW5jZSxcbiAgICAgIC8vIGJlY2F1c2UgdGhlIGJyb3dzZXIgc3RvcHMgZXZhbHVhdGluZyBoaXRzIGFnYWluc3QgdGhlIGVsZW1lbnRzIGRpc3BsYXllZCBpbnNpZGUgdGhlIHBhbiB6b29tIHZpZXcuXG4gICAgICAvLyBCZXNpZGVzIHRoaXMsIG1vdXNlIGV2ZW50cyB3aWxsIG5vdCBiZSBzZW50IHRvIGFueSBvdGhlciBlbGVtZW50cyxcbiAgICAgIC8vIHRoaXMgcHJldmVudHMgaXNzdWVzIGxpa2Ugc2VsZWN0aW5nIGVsZW1lbnRzIHdoaWxlIGRyYWdnaW5nLlxuICAgICAgdGhpcy5wYW56b29tT3ZlcmxheVJlZi5uYXRpdmVFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH1cblxuICAgIHRoaXMubW9kZWwuaXNQYW5uaW5nID0gdHJ1ZTtcblxuICAgIC8vIHNldCB0aGVzZSBmb3IgdGhlIGFuaW1hdGlvbiBzbG93IGRvd24gb25jZSBkcmFnIHN0b3BzXG4gICAgLy8gcGFuVmVsb2NpdHkgaXMgYSBtZWFzdXJlbWVudCBvZiBzcGVlZCBmb3IgeCBhbmQgeSBjb29yZGluYXRlcywgaW4gcGl4ZWxzIHBlciBtb3VzZSBtb3ZlIGV2ZW50LiAgSXQgaXMgYSBtZWFzdXJlIG9mIGhvdyBmYXN0IHRoZSBtb3VzZSBpcyBtb3ZpbmdcbiAgICB0aGlzLnBhblZlbG9jaXR5ID0ge1xuICAgICAgeDogZHJhZ0RlbHRhLnggLyB0aW1lU2luY2VMYXN0TW91c2VFdmVudCxcbiAgICAgIHk6IGRyYWdEZWx0YS55IC8gdGltZVNpbmNlTGFzdE1vdXNlRXZlbnRcbiAgICB9O1xuICAgIC8vIGNvbnNvbGUubG9nKGBQYW5ab29tQ29tcG9uZW50OiBvbk1vdXNlTW92ZSgpOiBwYW5WZWxvY2l0eTpgLCB0aGlzLnBhblZlbG9jaXR5KTtcblxuICAgIHRoaXMucHJldmlvdXNQb3NpdGlvbiA9IHtcbiAgICAgIHg6IGV2ZW50LnBhZ2VYLFxuICAgICAgeTogZXZlbnQucGFnZVlcbiAgICB9O1xuXG4gIH1cblxuXG5cbiAgcHJpdmF0ZSBvblRvdWNoTW92ZSA9IChldmVudDogYW55KSA9PiB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IG9uVG91Y2hNb3ZlKCknKTtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogb25Ub3VjaE1vdmUoKTogZXZlbnQ6JywgZXZlbnQpO1xuXG4gICAgLy8gZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAvLyBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gc2luZ2xlIHRvdWNoLCBlbXVsYXRlIG1vdXNlIG1vdmVcbiAgICAgIHRoaXMub25Nb3VzZU1vdmUoZXZlbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIG11bHRpcGxlIHRvdWNoZXMsIHpvb20gaW4vb3V0XG4gICAgICAvLyBjb25zb2xlLmxvZygncGluY2ggem9vbWluZycpO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgeCBhbmQgeSBkaXN0YW5jZSBiZXR3ZWVuIHRvdWNoIGV2ZW50c1xuICAgICAgbGV0IHggPSBldmVudC50b3VjaGVzWzBdLnBhZ2VYIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWDtcbiAgICAgIGxldCB5ID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWSAtIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVk7XG4gICAgICAvLyBDYWxjdWxhdGUgbGVuZ3RoIGJldHdlZW4gdG91Y2ggcG9pbnRzIHdpdGggcHl0aGFnb3Jhc1xuICAgICAgLy8gVGhlcmUgaXMgbm8gcmVhc29uIHRvIHVzZSBNYXRoLnBvdyBhbmQgTWF0aC5zcXJ0IGFzIHdlXG4gICAgICAvLyBvbmx5IHdhbnQgYSByZWxhdGl2ZSBsZW5ndGggYW5kIG5vdCB0aGUgZXhhY3Qgb25lLlxuICAgICAgbGV0IGxlbmd0aCA9IHggKiB4ICsgeSAqIHk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBkZWx0YSBiZXR3ZWVuIGN1cnJlbnQgcG9zaXRpb24gYW5kIGxhc3QgcG9zaXRpb25cbiAgICAgIGxldCBkZWx0YSA9IGxlbmd0aCAtIHRoaXMucHJldmlvdXNQb3NpdGlvbi5sZW5ndGg7XG5cbiAgICAgIC8vIE5haXZlIGh5c3RlcmVzaXNcbiAgICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPCAxMDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDYWxjdWxhdGUgY2VudGVyIGJldHdlZW4gdG91Y2ggcG9pbnRzXG4gICAgICBsZXQgY2VudGVyWCA9IGV2ZW50LnRvdWNoZXNbMV0ucGFnZVggKyB4IC8gMjtcbiAgICAgIGxldCBjZW50ZXJZID0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWSArIHkgLyAyO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgem9vbSBjZW50ZXJcbiAgICAgIGxldCBjbGlja1BvaW50ID0ge1xuICAgICAgICB4OiBjZW50ZXJYIC0gdGhpcy5qUXVlcnlGcmFtZUVsZW1lbnQub2Zmc2V0KCkubGVmdCxcbiAgICAgICAgeTogY2VudGVyWSAtIHRoaXMualF1ZXJ5RnJhbWVFbGVtZW50Lm9mZnNldCgpLnRvcFxuICAgICAgfTtcbiAgICAgIHRoaXMubGFzdENsaWNrUG9pbnQgPSBjbGlja1BvaW50O1xuXG4gICAgICB0aGlzLmNoYW5nZVpvb21MZXZlbCggdGhpcy5iYXNlLnpvb21MZXZlbCArIGRlbHRhICogMC4wMDAxLCBjbGlja1BvaW50KTtcbiAgICAgIC8vIHRoaXMuZnJlZVpvb20oIGNsaWNrUG9pbnQsIGRlbHRhKTtcblxuICAgICAgLy8gVXBkYXRlIGxlbmd0aCBmb3IgbmV4dCBtb3ZlIGV2ZW50XG4gICAgICB0aGlzLnByZXZpb3VzUG9zaXRpb24gPSB7XG4gICAgICAgIGxlbmd0aDogbGVuZ3RoXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG5cblxuICBwcml2YXRlIG9uTW91c2VVcCA9IChldmVudCkgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKCdQYW5ab29tQ29tcG9uZW50OiBvbk1vdXNldXAoKScsIGV2ZW50KTtcblxuICAgIGlmIChldmVudC5idXR0b24gIT09IHRoaXMuZHJhZ01vdXNlQnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAvLyBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIGxldCBub3cgPSBldmVudC50aW1lU3RhbXA7XG4gICAgbGV0IHRpbWVTaW5jZUxhc3RNb3VzZUV2ZW50ID0gKG5vdyAtIHRoaXMubGFzdE1vdXNlRXZlbnRUaW1lKSAvIDEwMDA7IC8vIG9yaWdcblxuICAgIGlmICh0aGlzLnBhblZlbG9jaXR5ICYmICh0aGlzLnBhblZlbG9jaXR5LnggIT09IDAgfHwgdGhpcy5wYW5WZWxvY2l0eS55ICE9PSAwKSApIHtcbiAgICAgIC8vIGFwcGx5IHN0cm9uZyBpbml0aWFsIGRhbXBlbmluZyBpZiB0aGUgbW91c2UgdXAgb2NjdXJlZCBtdWNoIGxhdGVyIHRoYW4gdGhlIGxhc3QgbW91c2UgbW92ZSwgaW5kaWNhdGluZyB0aGF0IHRoZSBtb3VzZSBoYXNuJ3QgbW92ZWQgcmVjZW50bHlcbiAgICAgIC8vIFRCRCAtIGV4cGVyaW1lbnQgd2l0aCB0aGlzIGZvcm11bGFcbiAgICAgIGxldCBpbml0aWFsTXVsdGlwbGllciA9IE1hdGgubWF4KFxuICAgICAgICAwLFxuICAgICAgICAtMC4yICsgTWF0aC5wb3codGltZVNpbmNlTGFzdE1vdXNlRXZlbnQgKyAxLCAtNClcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnBhblZlbG9jaXR5LnggKj0gaW5pdGlhbE11bHRpcGxpZXI7XG4gICAgICAgIHRoaXMucGFuVmVsb2NpdHkueSAqPSBpbml0aWFsTXVsdGlwbGllcjtcbiAgICAgICAgdGhpcy5kcmFnRmluaXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coYFBhblpvb21Db21wb25lbnQ6IG9uTW91c2VVcCgpOiBwYW5WZWxvY2l0eTpgLCB0aGlzLnBhblZlbG9jaXR5KTtcbiAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCAoKSA9PiB0aGlzLmFuaW1hdGlvbklkID0gdGhpcy5hbmltYXRpb25GcmFtZUZ1bmModGhpcy5hbmltYXRpb25UaWNrKSApO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuZHJhZ0ZpbmlzaGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhblZlbG9jaXR5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAvLyB0aGlzLm1vZGVsLmlzUGFubmluZyA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5pc01vYmlsZSkge1xuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoICgpID0+IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kKSApO1xuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoICgpID0+IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25Ub3VjaE1vdmUsIDxhbnk+eyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiBmYWxzZSB9ICkgKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoICgpID0+IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUsIDxhbnk+eyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiBmYWxzZSB9ICkpO1xuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoICgpID0+IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcCwgPGFueT57IHBhc3NpdmU6IHRydWUgfSApKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIG92ZXJsYXkgdG8gbm9uLWJsb2NraW5nIGFnYWluOlxuICAgIHRoaXMucGFuem9vbU92ZXJsYXlSZWYubmF0aXZlRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9XG5cblxuXG4gIHByaXZhdGUgb25Ub3VjaEVuZCA9IChldmVudDogYW55KSA9PiB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IG9uVG91Y2hFbmQoKScpO1xuICAgIHRoaXMub25Nb3VzZVVwKGV2ZW50KTtcbiAgfVxuXG5cblxuICBwcml2YXRlIG9uRGJsQ2xpY2sgPSAoZXZlbnQ6IGFueSkgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKCdQYW5ab29tQ29tcG9uZW50OiBvbkRibENsaWNrKCknKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGlmICghdGhpcy5jb25maWcuem9vbU9uRG91YmxlQ2xpY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgY2xpY2tQb2ludDogUG9pbnQgPSB7XG4gICAgICB4OiBldmVudC5wYWdlWCAtIHRoaXMualF1ZXJ5RnJhbWVFbGVtZW50Lm9mZnNldCgpLmxlZnQsXG4gICAgICB5OiBldmVudC5wYWdlWSAtIHRoaXMualF1ZXJ5RnJhbWVFbGVtZW50Lm9mZnNldCgpLnRvcFxuICAgIH07XG4gICAgdGhpcy5sYXN0Q2xpY2tQb2ludCA9IGNsaWNrUG9pbnQ7XG4gICAgdGhpcy56b29tSW4oY2xpY2tQb2ludCk7XG4gIH1cblxuXG5cbiAgcHJpdmF0ZSBwcmV2ZW50RGVmYXVsdCA9IChldmVudDogYW55KSA9PiB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG5cblxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIEVORCBFVkVOVCBIQU5ETEVSUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuXG5cblxuXG5cblxuXG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gQVBQTFkgQU5JTUFUSU9OUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG5cbiAgcHJpdmF0ZSBhbmltYXRpb25UaWNrID0gKHRpbWVzdGFtcDogbnVtYmVyKSA9PiB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IGFuaW1hdGlvblRpY2soKScpO1xuICAgIC8vIHRpbWVzdGFtcCBsb29rcyBsaWtlIDc2OTE2Ljk2My4gIFRoZSB1bml0IGlzIG1pbGxpc2Vjb25kcyBhbmQgc2hvdWxkIGJlIGFjY3VyYXRlIHRvIDUgwrVzIChtaWNyb3NlY29uZHMpXG5cbiAgICBsZXQgZGVsdGFUaW1lID0gMDtcbiAgICBpZiAodGhpcy5sYXN0VGljayAhPT0gMCkge1xuICAgICAgZGVsdGFUaW1lID0gKHRpbWVzdGFtcCAtIHRoaXMubGFzdFRpY2spOyAvLyBvcmlnIC0gbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IGFuaW1hdGlvblRpY2tcbiAgICB9XG4gICAgdGhpcy5sYXN0VGljayA9IHRpbWVzdGFtcDtcblxuICAgIGlmICh0aGlzLmFuaW1hdGlvblBhcmFtcykge1xuICAgICAgLy8gd2hlbiB3ZSdyZSBydW5uaW5nIGFuIGFuaW1hdGlvbiAoYnV0IG5vdCB3YWl0aW5nIGZvciBhIHJlbGVhc2VkIGRyYWcgdG8gaGFsdClcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdQYW5ab29tQ29tcG9uZW50OiBhbmltYXRpb25UaWNrKCk6IG1vZGVsIGlzIHpvb21pbmcnKTtcblxuICAgICAgdGhpcy5hbmltYXRpb25QYXJhbXMucHJvZ3Jlc3MgKz0gTWF0aC5hYnMoZGVsdGFUaW1lIC8gdGhpcy5hbmltYXRpb25QYXJhbXMuZHVyYXRpb24pO1xuXG4gICAgICBpZiAodGhpcy5hbmltYXRpb25QYXJhbXMucHJvZ3Jlc3MgPj0gMS4wKSB7XG4gICAgICAgIC8vIE9ubHkgd2hlbiB0aGUgYW5pbWF0aW9uIGhhcyBmaW5pc2hlZCwgc3luYyB0aGUgYmFzZSB0byB0aGUgbW9kZWwuXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uUGFyYW1zLnByb2dyZXNzID0gMS4wO1xuICAgICAgICB0aGlzLnVwZGF0ZURPTSgpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvblBhcmFtcyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFuVmVsb2NpdHkgJiYgdGhpcy5kcmFnRmluaXNoaW5nKSB7XG4gICAgICAvLyBUaGlzIGlzIHdoZW4gd2UndmUgcGFubmVkIGFuZCByZWxlYXNlZCB0aGUgbW91c2UgYnV0dG9uIGFuZCB0aGUgdmlldyBpcyBcImZyZWUtZmxvYXRpbmdcIiB1bnRpbCBpdCBzbG93cyB0byBhIGhhbHQuICBEb24ndCBsZXQgdGhlIHdoaWxlIGxvb3AgZm9vbCB5b3UgLSB0aGlzIG9ubHkgYXBwbGllcyBpdCBmb3IgdGhlIGN1cnJlbnQgZnJhbWUuXG4gICAgICAvLyBQcmV2ZW50IG92ZXJzaG9vdGluZyBpZiBkZWx0YSB0aW1lIGlzIGxhcmdlIGZvciBzb21lIHJlYXNvbi4gV2UgYXBwbHkgdGhlIHNpbXBsZSBzb2x1dGlvbiBvZiBzbGljaW5nIGRlbHRhIHRpbWUgaW50byBzbWFsbGVyIHBpZWNlcyBhbmQgYXBwbHlpbmcgZWFjaCBvbmVcbiAgICAgIGlmIChkZWx0YVRpbWUgPiAwKSB7XG4gICAgICAgIGRlbHRhVGltZSA9IGRlbHRhVGltZSAvIDEwMDA7XG4gICAgICB9XG4gICAgICB3aGlsZSAoZGVsdGFUaW1lID4gMCkge1xuICAgICAgICBsZXQgZFRpbWUgPSBNYXRoLm1pbiguMDIsIGRlbHRhVGltZSk7XG4gICAgICAgIGRlbHRhVGltZSA9IGRlbHRhVGltZSAtIGRUaW1lO1xuXG4gICAgICAgIHRoaXMubW9kZWwucGFuLnggPSB0aGlzLm1vZGVsLnBhbi54ICsgdGhpcy5wYW5WZWxvY2l0eS54ICogZFRpbWU7XG4gICAgICAgIHRoaXMucGFuVmVsb2NpdHkueCA9IHRoaXMucGFuVmVsb2NpdHkueCAqICgxIC0gdGhpcy5jb25maWcuZnJpY3Rpb24gKiBkVGltZSk7XG5cbiAgICAgICAgdGhpcy5tb2RlbC5wYW4ueSA9IHRoaXMubW9kZWwucGFuLnkgKyB0aGlzLnBhblZlbG9jaXR5LnkgKiBkVGltZTtcbiAgICAgICAgdGhpcy5wYW5WZWxvY2l0eS55ID0gdGhpcy5wYW5WZWxvY2l0eS55ICogKDEgLSB0aGlzLmNvbmZpZy5mcmljdGlvbiAqIGRUaW1lKTtcblxuICAgICAgICBsZXQgc3BlZWQgPSB0aGlzLmxlbmd0aCh0aGlzLnBhblZlbG9jaXR5KTtcblxuICAgICAgICBpZiAoc3BlZWQgPCB0aGlzLmNvbmZpZy5oYWx0U3BlZWQpIHtcbiAgICAgICAgICB0aGlzLm1vZGVsLmlzUGFubmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMucGFuVmVsb2NpdHkgPSBudWxsO1xuICAgICAgICAgIHRoaXMuZHJhZ0ZpbmlzaGluZyA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb25maWcua2VlcEluQm91bmRzIHx8IHRoaXMuZHJhZ0ZpbmlzaGluZykge1xuICAgICAgLy8gQ2hlY2tzIHRoYXQga2VlcEluQm91bmRzIGlzIHNldCBhbmQgdGhhdCB0aGUgbW91c2UgYnV0dG9uIGlzbid0IHByZXNzZWQsIGFuZCBpZiBzbywgaXQgc3RvcHMgdGhlIGNvbnRlbnRzIGZyb20gZ29pbmcgb3V0IG9mIHZpZXdcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdQYW5ab29tQ29tcG9uZW50OiBhbmltYXRpb25UaWNrKCk6IGtlZXBJbkJvdW5kcycpO1xuICAgICAgbGV0IHRvcExlZnRDb3JuZXJWaWV3ID0gdGhpcy5nZXRWaWV3UG9zaXRpb24oeyB4OiAwLCB5OiAwIH0pO1xuICAgICAgbGV0IGJvdHRvbVJpZ2h0Q29ybmVyVmlldyA9IHRoaXMuZ2V0Vmlld1Bvc2l0aW9uKHsgeDogdGhpcy5jb250ZW50V2lkdGgsIHk6IHRoaXMuY29udGVudEhlaWdodCB9KTtcblxuICAgICAgaWYgKHRvcExlZnRDb3JuZXJWaWV3LnggPiAwKSB7XG4gICAgICAgIHRoaXMuYmFzZS5wYW4ueCAtPSB0aGlzLmNvbmZpZy5rZWVwSW5Cb3VuZHNSZXN0b3JlRm9yY2UgKiB0b3BMZWZ0Q29ybmVyVmlldy54O1xuICAgICAgfVxuXG4gICAgICBpZiAodG9wTGVmdENvcm5lclZpZXcueSA+IDApIHtcbiAgICAgICAgdGhpcy5iYXNlLnBhbi55IC09IHRoaXMuY29uZmlnLmtlZXBJbkJvdW5kc1Jlc3RvcmVGb3JjZSAqIHRvcExlZnRDb3JuZXJWaWV3Lnk7XG4gICAgICB9XG5cbiAgICAgIGlmIChib3R0b21SaWdodENvcm5lclZpZXcueCA8IHRoaXMuY29udGVudFdpZHRoKSB7XG4gICAgICAgIHRoaXMuYmFzZS5wYW4ueCAtPSB0aGlzLmNvbmZpZy5rZWVwSW5Cb3VuZHNSZXN0b3JlRm9yY2UgKiAoYm90dG9tUmlnaHRDb3JuZXJWaWV3LnggLSB0aGlzLmNvbnRlbnRXaWR0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChib3R0b21SaWdodENvcm5lclZpZXcueSA8IHRoaXMuY29udGVudEhlaWdodCkge1xuICAgICAgICB0aGlzLmJhc2UucGFuLnkgLT0gdGhpcy5jb25maWcua2VlcEluQm91bmRzUmVzdG9yZUZvcmNlICogKGJvdHRvbVJpZ2h0Q29ybmVyVmlldy55IC0gdGhpcy5jb250ZW50SGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZURPTSgpO1xuICAgIHRoaXMuY29uZmlnLm1vZGVsQ2hhbmdlZC5uZXh0KHRoaXMubW9kZWwpO1xuXG5cbiAgICBpZiAoIHRoaXMuYW5pbWF0aW9uUGFyYW1zIHx8ICh0aGlzLnBhblZlbG9jaXR5ICYmIHRoaXMuZHJhZ0ZpbmlzaGluZykgKSB7XG4gICAgICAvLyBBcmUgd2UgaW4gYW4gYW5pbWF0aW9uPyAgSWYgc28sIHJ1biB0aGUgbmV4dCBmcmFtZVxuXG4gICAgICBpZiAodGhpcy5pc0Nocm9tZSAmJiB0aGlzLnpvb21MZXZlbElzQ2hhbmdpbmcpIHtcbiAgICAgICAgLy8gcnVuIHdpbGwtY2hhbmdlIHRvZ2dsZSBoYWNrIG9uIENocm9tZSB0byB0cmlnZ2VyIHJlLXJhc3Rlcml6YXRpb25cbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi91cGRhdGVzLzIwMTYvMDkvcmUtcmFzdGVyaW5nLWNvbXBvc2l0ZVxuICAgICAgICBpZiAodGhpcy53aWxsQ2hhbmdlTmV4dEZyYW1lKSB7XG4gICAgICAgICAgKDxhbnk+dGhpcy5hY2NlbGVyYXRlZEZyYW1lUmVmLm5hdGl2ZUVsZW1lbnQuc3R5bGUpLndpbGxDaGFuZ2UgPSAnYXV0byc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgKDxhbnk+dGhpcy5hY2NlbGVyYXRlZEZyYW1lUmVmLm5hdGl2ZUVsZW1lbnQuc3R5bGUpLndpbGxDaGFuZ2UgPSAndHJhbnNmb3JtJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndpbGxDaGFuZ2VOZXh0RnJhbWUgPSAhdGhpcy53aWxsQ2hhbmdlTmV4dEZyYW1lO1xuICAgICAgfVxuICAgICAgLy8gY29uc29sZS5sb2coJ2NhbGxpbmcgbmV4dCB0aWNrJyk7XG4gICAgICB0aGlzLmFuaW1hdGlvbkZyYW1lRnVuYyh0aGlzLmFuaW1hdGlvblRpY2spOyAvLyBDYWxsIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZVxuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLnBhblZlbG9jaXR5ICYmICF0aGlzLmRyYWdGaW5pc2hpbmcpIHtcbiAgICAgIC8vIHdlJ3JlIGp1c3QgbW91c2UtcGFubmluZyB0aGUgZnJhbWUuICBXZSBkb24ndCBuZWVkIGFub3RoZXIgdGlja1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIEFuaW1hdGlvbiBoYXMgZW5kZWRcbiAgICAgIHRoaXMuc3luY0Jhc2VUb01vZGVsKCk7XG4gICAgICB0aGlzLnNjYWxlID0gdGhpcy5nZXRDc3NTY2FsZSh0aGlzLmJhc2Uuem9vbUxldmVsKTtcbiAgICAgIHRoaXMud2lsbENoYW5nZU5leHRGcmFtZSA9IHRydWU7XG4gICAgICAoPGFueT50aGlzLmFjY2VsZXJhdGVkRnJhbWVSZWYubmF0aXZlRWxlbWVudC5zdHlsZSkud2lsbENoYW5nZSA9ICd0cmFuc2Zvcm0nO1xuICAgICAgdGhpcy56b29tTGV2ZWxJc0NoYW5naW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmxhc3RUaWNrID0gMDtcbiAgICB9XG5cbiAgfVxuXG5cblxuICBwcml2YXRlIHVwZGF0ZURPTSgpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogdXBkYXRlRE9NKCknKTtcbiAgICAvLyBDYWxsZWQgYnkgbmdBZnRlclZpZXdJbml0KCkgYW5kIGFuaW1hdGlvblRpY2soKVxuICAgIC8vIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgZ2V0IGNhbGxlZCBieSBmcmVlWm9vbSgpLCB3aGljaCBvcGVyYXRlcyBpbmRlcGVuZGVudGx5IG9mIGFuaW1hdGlvblRpY2soKSBhbmQgdXBkYXRlRE9NKCkuXG5cbiAgICBpZiAodGhpcy5hbmltYXRpb25QYXJhbXMpIHtcbiAgICAgIC8vIHdlJ3JlIHJ1bm5pbmcgYW4gYW5pbWF0aW9uIHNlcXVlbmNlIChidXQgbm90IGZyZWVab29taW5nIG9yIHBhbm5pbmcgd2l0aCBvbk1vdXNlTW92ZSgpIClcbiAgICAgIHRoaXMubW9kZWwuem9vbUxldmVsID0gdGhpcy5iYXNlLnpvb21MZXZlbCArIHRoaXMuYW5pbWF0aW9uUGFyYW1zLmRlbHRhWm9vbUxldmVsICogdGhpcy5hbmltYXRpb25QYXJhbXMucHJvZ3Jlc3M7IC8vIGNhbGN1bGF0ZSBob3cgZmFyIHdlIG5lZWQgdG8gem9vbSBpbiBvciBvdXQgZm9yIHRoZSBjdXJyZW50IGFuaW1hdGlvblRpY2tcbiAgICAgIGxldCBkZWx0YVRyYW5zbGF0aW9uID0gdGhpcy5hbmltYXRpb25QYXJhbXMucGFuU3RlcEZ1bmModGhpcy5tb2RlbC56b29tTGV2ZWwpOyAvLyBjYWxjdWxhdGUgaG93IGZhciB0byBwYW4gdGhlIHZpZXcgdG8gYmFzZWQgb24gb3VyIHRyYW5zbGF0ZWQgY29vcmRpbmF0ZXNcblxuICAgICAgLy8gc3luYyB0aGUgbW9kZWwgcGFuIGNvb3JkaW5hdGVzIHRvIG91ciB0cmFuc2xhdGVkIHBhbiBjb29yZGluYXRlc1xuICAgICAgLy8gd2UgZG8gdGhpcyBieSBhZGRpbmcgaG93IGZhciB3ZSB3YW50IHRvIG1vdmUgaW4gZWFjaCBkaXJlY3Rpb24gdG8gb3VyIG91ciBleGlzdGluZyBiYXNlIHBhbiBjb29yZGluYXRlcyAod2hlcmUgd2Ugc3RhcnRlZClcbiAgICAgIHRoaXMubW9kZWwucGFuLnggPSB0aGlzLmJhc2UucGFuLnggKyBkZWx0YVRyYW5zbGF0aW9uLng7XG4gICAgICB0aGlzLm1vZGVsLnBhbi55ID0gdGhpcy5iYXNlLnBhbi55ICsgZGVsdGFUcmFuc2xhdGlvbi55O1xuXG4gICAgICBpZiAodGhpcy5jb25maWcua2VlcEluQm91bmRzKSB7XG4gICAgICAgIGxldCB0b3BMZWZ0Q29ybmVyVmlldyA9IHRoaXMuZ2V0Vmlld1Bvc2l0aW9uKHsgeDogMCwgeTogMCB9KTtcbiAgICAgICAgbGV0IGJvdHRvbVJpZ2h0Q29ybmVyVmlldyA9IHRoaXMuZ2V0Vmlld1Bvc2l0aW9uKHsgeDogdGhpcy5jb250ZW50V2lkdGgsIHk6IHRoaXMuY29udGVudEhlaWdodCB9KTtcblxuICAgICAgICBpZiAodG9wTGVmdENvcm5lclZpZXcueCA+IDApIHtcbiAgICAgICAgICB0aGlzLm1vZGVsLnBhbi54ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3BMZWZ0Q29ybmVyVmlldy55ID4gMCkge1xuICAgICAgICAgIHRoaXMubW9kZWwucGFuLnkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJvdHRvbVJpZ2h0Q29ybmVyVmlldy54IDwgdGhpcy5jb250ZW50V2lkdGgpIHtcbiAgICAgICAgICB0aGlzLm1vZGVsLnBhbi54IC09IChib3R0b21SaWdodENvcm5lclZpZXcueCAtIHRoaXMuY29udGVudFdpZHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChib3R0b21SaWdodENvcm5lclZpZXcueSA8IHRoaXMuY29udGVudEhlaWdodCkge1xuICAgICAgICAgIHRoaXMubW9kZWwucGFuLnkgLT0gKGJvdHRvbVJpZ2h0Q29ybmVyVmlldy55IC0gdGhpcy5jb250ZW50SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLyBBUFBMWSBTQ0FMSU5HIC8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGlmICh0aGlzLmFuaW1hdGlvblBhcmFtcyB8fCB0aGlzLmlzRmlyc3RTeW5jKSB7XG4gICAgICBsZXQgc2NhbGUgPSB0aGlzLmdldENzc1NjYWxlKHRoaXMubW9kZWwuem9vbUxldmVsKTtcbiAgICAgIGxldCBzY2FsZVN0cmluZyA9IGBzY2FsZSgke3NjYWxlfSlgO1xuICAgICAgdGhpcy56b29tRWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwIDAnO1xuICAgICAgdGhpcy56b29tRWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IHNjYWxlU3RyaW5nO1xuICAgIH1cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vIEFQUExZIFBBTiBBTklNQVRJT04gLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGxldCB0cmFuc2xhdGUzZCA9IGB0cmFuc2xhdGUzZCgke3RoaXMubW9kZWwucGFuLnh9cHgsICR7dGhpcy5tb2RlbC5wYW4ueX1weCwgMClgO1xuICAgIHRoaXMucGFuRWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zbGF0ZTNkO1xuXG4gIH1cblxuXG5cbiAgcHJpdmF0ZSBmcmVlWm9vbShjbGlja1BvaW50OiBQb2ludCwgd2hlZWxEZWx0YTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IGZyZWVab29tKCk6IHRoaXMuYmFzZTonLCB0aGlzLmJhc2UpO1xuXG4gICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgLy8gZG9uJ3QgYWxsb3cgem9vbWluZyBpZiB0aGUgbW91c2UgaXMgZG93blxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIG5vdyBoYW5kbGUgaW50ZXJydXB0aW9uIG9mIGFuIGluLXByb2dyZXNzIGFuaW1hdGlvblxuICAgIGlmICh0aGlzLmFuaW1hdGlvblBhcmFtcykge1xuICAgICAgdGhpcy5hbmltYXRpb25QYXJhbXMgPSBudWxsOyAvLyBjYW5jZWwgYW4gZXhpc3RpbmcgYW5pbWF0aW9uXG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFuVmVsb2NpdHkpIHtcbiAgICAgIHRoaXMuZHJhZ0ZpbmlzaGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5wYW5WZWxvY2l0eSA9IG51bGw7XG4gICAgfVxuXG4gICAgbGV0IGN1cnJlbnRQYW46IFBvaW50ID0ge1xuICAgICAgLy8gdGhlIGN1cnJlbnQgYmFzZSBjb29yZGluYXRlc1xuICAgICAgeDogdGhpcy5iYXNlLnBhbi54LFxuICAgICAgeTogdGhpcy5iYXNlLnBhbi55XG4gICAgfTtcbiAgICAvLyAhISFzb21ldGhpbmcsIHNvbWV3aGVyZSBpcyBwb3RlbnRpYWxseSBpbnZhbGlkYXRpbmcgdGhlIGJhc2UgcGFuISEhXG4gICAgbGV0IGN1cnJlbnRTY2FsZSA9IHRoaXMuc2NhbGU7IC8vIGdldCB0aGUgY3VycmVudCBDU1Mgc2NhbGUgKHNjYWxlMClcblxuICAgIGxldCBuZXdTY2FsZSA9IHRoaXMuc2NhbGUgKyAod2hlZWxEZWx0YSAqIHRoaXMuY29uZmlnLmZyZWVNb3VzZVdoZWVsRmFjdG9yICogdGhpcy5zY2FsZSk7XG5cbiAgICAvLyB0YWtlcyBlaXRoZXIgdGhlIG1pbmltdW0gc2NhbGUgKGZ1cnRoZXN0IGFsbG93YWJsZSB6b29tZWQgb3V0KSBvciB0aGUgY2FsY3VsYXRlZCBjdXJyZW50IHNjYWxlLCB3aGljaGV2ZXIgaXMgZ3JlYXRlciwgdW5sZXNzIGNhbGN1bGF0ZWQgY3VycmVudCBzY2FsZSBleGNlZWRzIG1heFNjYWxlIChmdXJ0aGVzdCBhbGxvd2FibGUgem9vbWVkIGluKSwgaW4gd2hpY2ggY2FzZSBtYXhTY2FsZSBpcyB1c2VkXG4gICAgbmV3U2NhbGUgPSBNYXRoLm1heCh0aGlzLm1pblNjYWxlLCBNYXRoLm1pbiggdGhpcy5tYXhTY2FsZSwgbmV3U2NhbGUgKSk7XG4gICAgdGhpcy5zY2FsZSA9IG5ld1NjYWxlO1xuXG4gICAgbGV0IHRhcmdldFBvaW50OiBQb2ludCA9IHtcbiAgICAgIC8vIFRoZSB0YXJnZXQgcG9pbnQgdG8gem9vbSB0by4gIEl0IG11c3Qgc3RheSB0aGUgc2FtZSBhcyB0aGUgdW50cmFuc2xhdGVkIHBvaW50XG4gICAgICB4OiBjbGlja1BvaW50LnggLSAobmV3U2NhbGUgLyBjdXJyZW50U2NhbGUpICogKGNsaWNrUG9pbnQueCAtIGN1cnJlbnRQYW4ueCksXG4gICAgICB5OiBjbGlja1BvaW50LnkgLSAobmV3U2NhbGUgLyBjdXJyZW50U2NhbGUpICogKGNsaWNrUG9pbnQueSAtIGN1cnJlbnRQYW4ueSlcbiAgICB9O1xuXG4gICAgLy8gQXBwbHkgUGFuICYgU2NhbGVcbiAgICBsZXQgdHJhbnNsYXRlM2QgPSBgdHJhbnNsYXRlM2QoJHt0YXJnZXRQb2ludC54fXB4LCAke3RhcmdldFBvaW50Lnl9cHgsIDApYDtcbiAgICB0aGlzLnBhbkVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2xhdGUzZDtcbiAgICBsZXQgc2NhbGVTdHJpbmcgPSBgc2NhbGUoJHt0aGlzLnNjYWxlfSlgO1xuICAgIHRoaXMuem9vbUVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAwJztcbiAgICB0aGlzLnpvb21FbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gc2NhbGVTdHJpbmc7XG5cbiAgICBpZiAodGhpcy5pc0Nocm9tZSkge1xuICAgICAgaWYgKHRoaXMud2lsbENoYW5nZU5leHRGcmFtZSkge1xuICAgICAgICAoPGFueT50aGlzLmFjY2VsZXJhdGVkRnJhbWVSZWYubmF0aXZlRWxlbWVudC5zdHlsZSkud2lsbENoYW5nZSA9ICdhdXRvJztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAoPGFueT50aGlzLmFjY2VsZXJhdGVkRnJhbWVSZWYubmF0aXZlRWxlbWVudC5zdHlsZSkud2lsbENoYW5nZSA9ICd0cmFuc2Zvcm0nO1xuICAgICAgfVxuICAgICAgdGhpcy53aWxsQ2hhbmdlTmV4dEZyYW1lID0gIXRoaXMud2lsbENoYW5nZU5leHRGcmFtZTtcbiAgICB9XG5cbiAgICB0aGlzLm1vZGVsLnBhbi54ID0gdGFyZ2V0UG9pbnQueDtcbiAgICB0aGlzLm1vZGVsLnBhbi55ID0gdGFyZ2V0UG9pbnQueTtcbiAgICB0aGlzLm1vZGVsLnpvb21MZXZlbCA9IHRoaXMuZ2V0Wm9vbUxldmVsKHRoaXMuc2NhbGUpO1xuICAgIHRoaXMuc3luY0Jhc2VUb01vZGVsKCk7XG4gICAgdGhpcy5jb25maWcubW9kZWxDaGFuZ2VkLm5leHQodGhpcy5tb2RlbCk7XG4gICAgLy8gY29uc29sZS5sb2coYFBhblpvb21Db21wb25lbnQ6IGZyZWVab29tKCk6IGJhc2VBZnRlclpvb206IHg6ICR7dGhpcy5iYXNlLnBhbi54fSB5OiAke3RoaXMuYmFzZS5wYW4ueX0gem9vbWxldmVsOiAke3RoaXMuYmFzZS56b29tTGV2ZWx9YCApO1xuICAgIC8vIGNvbnNvbGUubG9nKCd6b29tTGV2ZWw6JywgdGhpcy5iYXNlLnpvb21MZXZlbCk7XG4gIH1cblxuXG5cblxuXG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8vLy8vLy8vLy8vLy8vIEhFTFBFUiBGVU5DVElPTlMgLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG5cbiAgcHJpdmF0ZSBpc01vYmlsZURldmljZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKHR5cGVvZiB3aW5kb3cub3JpZW50YXRpb24gIT09ICd1bmRlZmluZWQnKSB8fCAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdJRU1vYmlsZScpICE9PSAtMSk7XG4gIH1cblxuXG5cblxuICBwcml2YXRlIHN5bmNCYXNlVG9Nb2RlbCgpIHtcbiAgICB0aGlzLmJhc2UucGFuLnggPSB0aGlzLm1vZGVsLnBhbi54O1xuICAgIHRoaXMuYmFzZS5wYW4ueSA9IHRoaXMubW9kZWwucGFuLnk7XG4gICAgdGhpcy5iYXNlLnpvb21MZXZlbCA9IHRoaXMubW9kZWwuem9vbUxldmVsO1xuICB9XG5cblxuXG4gIHByaXZhdGUgbGVuZ3RoKHZlY3RvcjJkOiBhbnkpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogbGVuZ3RoKCknKTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHZlY3RvcjJkLnggKiB2ZWN0b3IyZC54ICsgdmVjdG9yMmQueSAqIHZlY3RvcjJkLnkpO1xuICB9XG5cblxuXG4gIHByaXZhdGUgZ2V0Q2VudGVyUG9pbnQoKTogUG9pbnQge1xuICAgIC8vIGNvbnNvbGUubG9nKCdQYW5ab29tQ29tcG9uZW50OiBnZXRDZW50ZXJQb2ludCgpJyk7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IGdldENlbnRlclBvaW50KCk6IHByb2plY3RlZENvbnRlbnRSZWY6JywgdGhpcy5wcm9qZWN0ZWRDb250ZW50UmVmKTtcbiAgICBsZXQgY2VudGVyID0ge1xuICAgICAgLy8geDogdGhpcy5qUXVlcnlGcmFtZUVsZW1lbnQud2lkdGgoKSAvIDIsXG4gICAgICB4OiB0aGlzLmZyYW1lRWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoIC8gMixcbiAgICAgIC8vIHg6IHRoaXMucHJvamVjdGVkQ29udGVudFJlZi5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoIC8gMixcbiAgICAgIC8vIHk6IHRoaXMualF1ZXJ5RnJhbWVFbGVtZW50LmhlaWdodCgpIC8gMlxuICAgICAgeTogdGhpcy5mcmFtZUVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5vZmZzZXRIZWlnaHQgLyAyXG4gICAgICAvLyB5OiB0aGlzLnByb2plY3RlZENvbnRlbnRSZWYubmF0aXZlRWxlbWVudC5vZmZzZXRIZWlnaHQgLyAyXG4gICAgfTtcbiAgICByZXR1cm4gY2VudGVyO1xuICB9XG5cblxuXG4gIHByaXZhdGUgZ2V0Q3NzU2NhbGUoem9vbUxldmVsOiBhbnkpOiBudW1iZXIge1xuICAgIC8vIGNvbnNvbGUubG9nKCdQYW5ab29tQ29tcG9uZW50OiBnZXRDc3NTY2FsZSgpJyk7XG4gICAgcmV0dXJuIE1hdGgucG93KHRoaXMuY29uZmlnLnNjYWxlUGVyWm9vbUxldmVsLCB6b29tTGV2ZWwgLSB0aGlzLmNvbmZpZy5uZXV0cmFsWm9vbUxldmVsKTtcbiAgfVxuXG5cblxuICBwcml2YXRlIGdldFpvb21MZXZlbChjc3NTY2FsZTogYW55KSB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IGdldFpvb21MZXZlbCgpJyk7XG4gICAgcmV0dXJuIE1hdGgubG9nMTAoY3NzU2NhbGUpIC8gTWF0aC5sb2cxMCh0aGlzLmNvbmZpZy5zY2FsZVBlclpvb21MZXZlbCkgKyB0aGlzLmNvbmZpZy5uZXV0cmFsWm9vbUxldmVsO1xuICB9XG5cblxuXG4gIHByaXZhdGUgY2FsY1pvb21Ub0ZpdChyZWN0OiBSZWN0KTogUGFuWm9vbU1vZGVsIHtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogY2FsY1pvb21Ub0ZpdCgpOiByZWN0OicsIHJlY3QpO1xuICAgIC8vIGxldCAoVywgSCkgZGVub3RlIHRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydFxuICAgIC8vIGxldCAodywgaCkgZGVub3RlIHRoZSBzaXplIG9mIHRoZSByZWN0YW5nbGUgdG8gem9vbSB0b1xuICAgIC8vIHRoZW4gd2UgbXVzdCBDU1Mgc2NhbGUgYnkgdGhlIG1pbiBvZiBXL3cgYW5kIEgvaCBpbiBvcmRlciB0byBqdXN0IGZpdCB0aGUgcmVjdGFuZ2xlXG4gICAgLy8gcmV0dXJucyB0aGUgdGFyZ2V0IGxlZnQgYW5kIHRvcCBjb29yZGluYXRlcyBmb3IgdGhlIHBhbkVsZW1lbnQgYW5kIHRhcmdldCB6b29tTGV2ZWxcblxuICAgIGxldCB2aWV3cG9ydFdpZHRoID0gdGhpcy5mcmFtZUVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICBsZXQgdmlld3BvcnRIZWlnaHQgPSB0aGlzLmZyYW1lRWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICAgIGxldCB0YXJnZXRXaWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgbGV0IHRhcmdldEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuXG4gICAgbGV0IGNzc1NjYWxlRXhhY3QgPSBNYXRoLm1pbiggdmlld3BvcnRXaWR0aCAvIHRhcmdldFdpZHRoLCB2aWV3cG9ydEhlaWdodCAvIHRhcmdldEhlaWdodCApO1xuICAgIGxldCB6b29tTGV2ZWxFeGFjdCA9IHRoaXMuZ2V0Wm9vbUxldmVsKGNzc1NjYWxlRXhhY3QpO1xuICAgIGxldCB6b29tTGV2ZWwgPSB6b29tTGV2ZWxFeGFjdCAqIHRoaXMuY29uZmlnLnpvb21Ub0ZpdFpvb21MZXZlbEZhY3RvcjtcbiAgICBsZXQgY3NzU2NhbGUgPSB0aGlzLmdldENzc1NjYWxlKHpvb21MZXZlbCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB6b29tTGV2ZWw6IHpvb21MZXZlbCxcbiAgICAgICAgcGFuOiB7XG4gICAgICAgICAgICB4OiAtcmVjdC54ICogY3NzU2NhbGUgKyAodmlld3BvcnRXaWR0aCAtIHRhcmdldFdpZHRoICogY3NzU2NhbGUpIC8gMixcbiAgICAgICAgICAgIHk6IC1yZWN0LnkgKiBjc3NTY2FsZSArICh2aWV3cG9ydEhlaWdodCAtIHRhcmdldEhlaWdodCAqIGNzc1NjYWxlKSAvIDJcbiAgICAgICAgfVxuICAgIH07XG4gIH1cblxuXG5cbiAgcHJpdmF0ZSB6b29tVG9GaXRNb2RlbCh0YXJnZXQ6IFBhblpvb21Nb2RlbCwgZHVyYXRpb246IG51bWJlciA9IG51bGwpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogem9vbVRvRml0TW9kZWwoKTogdGFyZ2V0OicsIHRhcmdldCk7XG5cbiAgICAvLyB0YXJnZXQucGFuLnggaXMgdGhlIHBhbkVsZW1lbnQgbGVmdCBzdHlsZSBwcm9wZXJ0eVxuICAgIC8vIHRhcmdldC5wYW4ueSBpcyB0aGUgcGFuRWxlbWVudCB0b3Agc3R5bGUgcHJvcGVydHlcbiAgICB0aGlzLmFuaW1hdGVUb1RhcmdldCh0YXJnZXQsIGR1cmF0aW9uKTtcbiAgfVxuXG5cblxuICBwcml2YXRlIHpvb21Ub0xldmVsQW5kUG9pbnQobGV2ZWw6IG51bWJlciwgY2xpY2tQb2ludDogUG9pbnQpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogem9vbVRvTGV2ZWxBbmRQb2ludCgpOiBsZXZlbDonLCBsZXZlbCk7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IHpvb21Ub0xldmVsQW5kUG9pbnQoKTogY2xpY2tQb2ludDonLCBjbGlja1BvaW50KTtcbiAgICB0aGlzLmNoYW5nZVpvb21MZXZlbCggbGV2ZWwsIGNsaWNrUG9pbnQgKTtcbiAgfVxuXG5cblxuICBwcml2YXRlIHpvb21JblRvTGFzdENsaWNrUG9pbnQoKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IHpvb21JblRvTGFzdENsaWNrUG9pbnQoKTogbGFzdENsaWNrUG9pbnQnLCB0aGlzLmxhc3RDbGlja1BvaW50KTtcbiAgICB0aGlzLmNoYW5nZVpvb21MZXZlbCggdGhpcy5iYXNlLnpvb21MZXZlbCArIHRoaXMuY29uZmlnLnpvb21CdXR0b25JbmNyZW1lbnQsIHRoaXMubGFzdENsaWNrUG9pbnQgKTtcbiAgfVxuXG5cblxuICBwcml2YXRlIHpvb21PdXRGcm9tTGFzdENsaWNrUG9pbnQoKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IHpvb21PdXRGcm9tTGFzdENsaWNrUG9pbnQoKScpO1xuICAgIHRoaXMuY2hhbmdlWm9vbUxldmVsKCB0aGlzLmJhc2Uuem9vbUxldmVsIC0gdGhpcy5jb25maWcuem9vbUJ1dHRvbkluY3JlbWVudCwgdGhpcy5sYXN0Q2xpY2tQb2ludCApO1xuICB9XG5cblxuXG4gIHByaXZhdGUgc3RhcnRBbmltYXRpb24oKSB7XG4gICAgdGhpcy5sYXN0VGljayA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhciggKCkgPT4gdGhpcy5hbmltYXRpb25JZCA9IHRoaXMuYW5pbWF0aW9uRnJhbWVGdW5jKHRoaXMuYW5pbWF0aW9uVGljaykgKTtcbiAgfVxuXG5cblxuXG5cblxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLyBBUEkgTUVUSE9EUyAvLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuXG4gIHByaXZhdGUgZ2V0Vmlld1Bvc2l0aW9uKG1vZGVsUG9zaXRpb246IFBvaW50KTogUG9pbnQge1xuICAgIC8vIGNvbnNvbGUubG9nKCdQYW5ab29tQ29tcG9uZW50OiBnZXRWaWV3UG9zaXRpb24oKScpO1xuICAgIC8vIHAnID0gcCAqIHMgKyB0XG4gICAgLy8gdmlld1Bvc2l0aW9uID0gbW9kZWxQb3NpdGlvbiAqIHNjYWxlICsgYmFzZVBhblxuXG4gICAgbGV0IHNjYWxlLCB0cmFuc2xhdGlvbjtcblxuICAgIGlmICh0aGlzLmFuaW1hdGlvblBhcmFtcykge1xuICAgICAgc2NhbGUgPSB0aGlzLmdldENzc1NjYWxlKHRoaXMuYmFzZS56b29tTGV2ZWwgKyB0aGlzLmFuaW1hdGlvblBhcmFtcy5kZWx0YVpvb21MZXZlbCAqIHRoaXMuYW5pbWF0aW9uUGFyYW1zLnByb2dyZXNzKTtcbiAgICAgIGxldCBkZWx0YVRyYW5zbGF0aW9uID0gdGhpcy5hbmltYXRpb25QYXJhbXMucGFuU3RlcEZ1bmModGhpcy5tb2RlbC56b29tTGV2ZWwpO1xuICAgICAgdHJhbnNsYXRpb24gPSB7IHg6IHRoaXMuYmFzZS5wYW4ueCArIGRlbHRhVHJhbnNsYXRpb24ueCwgeTogdGhpcy5iYXNlLnBhbi55ICsgZGVsdGFUcmFuc2xhdGlvbi55IH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc2NhbGUgPSB0aGlzLmdldENzc1NjYWxlKHRoaXMuYmFzZS56b29tTGV2ZWwpO1xuICAgICAgdHJhbnNsYXRpb24gPSB0aGlzLmJhc2UucGFuO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB4OiBtb2RlbFBvc2l0aW9uLnggKiBzY2FsZSArIHRyYW5zbGF0aW9uLngsXG4gICAgICB5OiBtb2RlbFBvc2l0aW9uLnkgKiBzY2FsZSArIHRyYW5zbGF0aW9uLnlcbiAgICB9O1xuICB9XG5cblxuXG4gIHByaXZhdGUgZ2V0TW9kZWxQb3NpdGlvbih2aWV3UG9zaXRpb246IFBvaW50KSB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IGdldE1vZGVsUG9zaXRpb24oKScpO1xuICAgIC8vIHAgPSAoMS9zKShwJyAtIHQpXG4gICAgbGV0IHBtYXJrID0gdmlld1Bvc2l0aW9uO1xuICAgIGxldCBzID0gdGhpcy5nZXRDc3NTY2FsZSh0aGlzLmJhc2Uuem9vbUxldmVsKTtcbiAgICBsZXQgdCA9IHRoaXMuYmFzZS5wYW47XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogKDEgLyBzKSAqIChwbWFyay54IC0gdC54KSxcbiAgICAgIHk6ICgxIC8gcykgKiAocG1hcmsueSAtIHQueSlcbiAgICB9O1xuICB9XG5cblxuXG4gIHByaXZhdGUgcmVzZXRWaWV3KCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdQYW5ab29tQ29tcG9uZW50OiByZXNldFZpZXcoKScpO1xuICAgIGlmICh0aGlzLmNvbmZpZy5pbml0aWFsWm9vbVRvRml0KSB7XG4gICAgICB0aGlzLnpvb21Ub0ZpdCh0aGlzLmNvbmZpZy5pbml0aWFsWm9vbVRvRml0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5jb25maWcuaW5pdGlhbFBhblggIT09IG51bGwgJiYgdGhpcy5jb25maWcuaW5pdGlhbFBhblkgIT09IG51bGwgJiYgdGhpcy5jb25maWcuaW5pdGlhbFpvb21MZXZlbCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy56b29tVG9GaXRNb2RlbChcbiAgICAgICAge1xuICAgICAgICAgIHpvb21MZXZlbDogdGhpcy5jb25maWcuaW5pdGlhbFpvb21MZXZlbCxcbiAgICAgICAgICBwYW46IHtcbiAgICAgICAgICAgIHg6IHRoaXMuY29uZmlnLmluaXRpYWxQYW5YLFxuICAgICAgICAgICAgeTogdGhpcy5jb25maWcuaW5pdGlhbFBhbllcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignUGFuWm9vbUNvbXBvbmVudDogcmVzZXRWaWV3KCkgY291bGQgbm90IHJlc2V0IHZpZXcgYXMgc29tZSB2YXJzIHdlcmUgbm90IHNldC4gIFRoZSBjdWxwcml0cyBhcmUgZWl0aGVyIGNvbmZpZy5pbml0aWFsWm9vbUxldmVsLCBjb25maWcuaW5pdGlhbFBhblgsIG9yIGNvbmZpZy5pbml0aWFsUGFuWS4gIE9yIGp1c3Qgc2V0IHBhbnpvb21Db25maWcuaW5pdGlhbFpvb21Ub0ZpdCcpO1xuICAgICAgY29uc29sZS5sb2coJ2NvbmZpZy5pbml0aWFsWm9vbUxldmVsOiAnICsgdGhpcy5jb25maWcuaW5pdGlhbFpvb21MZXZlbCk7XG4gICAgICBjb25zb2xlLmxvZygnY29uZmlnLmluaXRpYWxQYW5YOiAnICsgdGhpcy5jb25maWcuaW5pdGlhbFBhblgpO1xuICAgICAgY29uc29sZS5sb2coJ2NvbmZpZy5pbml0aWFsUGFuWTogJyArIHRoaXMuY29uZmlnLmluaXRpYWxQYW5ZKTtcbiAgICB9XG4gIH1cblxuXG5cbiAgcHJpdmF0ZSB6b29tVG9GaXQocmVjdGFuZ2xlOiBSZWN0LCBkdXJhdGlvbjogbnVtYmVyID0gbnVsbCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdQYW5ab29tQ29tcG9uZW50OiB6b29tVG9GaXQoKTogcmVjdGFuZ2xlJywgcmVjdGFuZ2xlKTtcblxuICAgIC8vIHdoZW4gYSB1c2VyIGNsaWNrcyBhIHpvb20gdG8gZml0IGJ1dHRvblxuICAgIC8vIGV4YW1wbGUgcmVjdGFuZ2xlOiB7IFwieFwiOiAwLCBcInlcIjogMTAwLCBcIndpZHRoXCI6IDEwMCwgXCJoZWlnaHRcIjogMTAwIH1cblxuICAgIGxldCB0YXJnZXQ6IFBhblpvb21Nb2RlbCA9IHRoaXMuY2FsY1pvb21Ub0ZpdChyZWN0YW5nbGUpO1xuICAgIC8vIHRhcmdldC5wYW4ueCBpcyB0aGUgcGFuRWxlbWVudCBsZWZ0IHN0eWxlIHByb3BlcnR5XG4gICAgLy8gdGFyZ2V0LnBhbi55IGlzIHRoZSBwYW5FbGVtZW50IHRvcCBzdHlsZSBwcm9wZXJ0eVxuICAgIHRoaXMuYW5pbWF0ZVRvVGFyZ2V0KHRhcmdldCwgZHVyYXRpb24pO1xuICB9XG5cblxuXG4gIHByaXZhdGUgem9vbUluKGNsaWNrUG9pbnQ6IFBvaW50KSB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IHpvb21JbigpOiBjbGlja1BvaW50OicsIGNsaWNrUG9pbnQpO1xuICAgIHRoaXMuY2hhbmdlWm9vbUxldmVsKCB0aGlzLmJhc2Uuem9vbUxldmVsICsgdGhpcy5jb25maWcuem9vbUJ1dHRvbkluY3JlbWVudCwgY2xpY2tQb2ludCApO1xuICB9XG5cblxuXG4gIHByaXZhdGUgem9vbU91dChjbGlja1BvaW50OiBQb2ludCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdQYW5ab29tQ29tcG9uZW50OiB6b29tT3V0KCknKTtcbiAgICB0aGlzLmNoYW5nZVpvb21MZXZlbCggdGhpcy5iYXNlLnpvb21MZXZlbCAtIHRoaXMuY29uZmlnLnpvb21CdXR0b25JbmNyZW1lbnQsIGNsaWNrUG9pbnQgKTtcbiAgfVxuXG5cblxuICBwcml2YXRlIHBhblRvUG9pbnQocG9pbnQ6IFBvaW50LCBkdXJhdGlvbjogbnVtYmVyID0gbnVsbCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdQYW5ab29tQ29tcG9uZW50OiBwYW5Ub1BvaW50KCk6IHBvaW50OicsIHBvaW50KTtcblxuICAgIC8vIEFQSSBjYWxsIHRvIGFuaW1hdGUgdGhlIHZpZXcgc28gdGhhdCB0aGUgY2VudHJlIHBvaW50IG9mIHRoZSB2aWV3IGlzIGF0IHRoZVxuICAgIC8vIHBvaW50IHBhcmFtZXRlciBjb29yZGluYXRlcywgcmVsYXRpdmUgdG8gdGhlIG9yaWdpbmFsLCB1bnpvb21lZFxuICAgIC8vIGNvbnRlbnQgd2lkdGggYW5kIGhlaWdodFxuICAgIC8vIGV4YW1wbGUgcG9pbnQ6IHsgXCJ4XCI6IDAsIFwieVwiOiAwIH0gLy8gbWFrZXMgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgY29udGVudFxuICAgIC8vIHRoZSBjZW50cmUgb2YgdGhlIHZpZXdcblxuICAgIGxldCB0YXJnZXQ6IFBhblpvb21Nb2RlbCA9IHtcbiAgICAgIHBhbjoge1xuICAgICAgICB4OiAoICh0aGlzLmZyYW1lV2lkdGggLyAyKSApIC0gcG9pbnQueCAqIHRoaXMuc2NhbGUsXG4gICAgICAgIHk6ICggKHRoaXMuZnJhbWVIZWlnaHQgLyAyKSApIC0gcG9pbnQueSAqIHRoaXMuc2NhbGVcbiAgICAgIH0sXG4gICAgICB6b29tTGV2ZWw6IHRoaXMuYmFzZS56b29tTGV2ZWxcbiAgICB9O1xuXG4gICAgdGhpcy5hbmltYXRlVG9UYXJnZXQodGFyZ2V0LCBkdXJhdGlvbik7XG4gIH1cblxuXG5cbiAgcHJpdmF0ZSBwYW5EZWx0YShkZWx0YTogUG9pbnQsIGR1cmF0aW9uOiBudW1iZXIgPSBudWxsKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IHBhbkRlbHRhKCk6IGRlbHRhOicsIGRlbHRhKTtcblxuICAgIC8vIEFQSSBjYWxsIHRvIHBhbiB0aGUgdmlldyBsZWZ0LCByaWdodCwgdXAsIG9yIGRvd24sIGJhc2VkIG9uIGEgbnVtYmVyIG9mIHBpeGVsc1xuICAgIC8vIG9mIHRoZSBvcmlnaW5hbCwgdW56b29tZWQgY29udGVudC5cbiAgICAvLyBQb3NpdGl2ZSBpcyByaWdodCBhbmQgZG93blxuICAgIC8vIE5lZ2F0aXZlIGlzIGxlZnQgYW5kIHVwXG4gICAgLy8gZXhhbXBsZSBwb2ludDogeyBcInhcIjogMTAwLCBcInlcIjogLTUwIH0gLy8gbW92ZXMgdGhlIHZpZXcgcmlnaHQgNTBweCBhbmQgdXAgNTBweFxuXG4gICAgbGV0IHRhcmdldDogUGFuWm9vbU1vZGVsID0ge1xuICAgICAgcGFuOiB7XG4gICAgICAgIHg6IHRoaXMuYmFzZS5wYW4ueCAtIHRoaXMuc2NhbGUgKiBkZWx0YS54LFxuICAgICAgICB5OiB0aGlzLmJhc2UucGFuLnkgLSB0aGlzLnNjYWxlICogZGVsdGEueVxuICAgICAgfSxcbiAgICAgIHpvb21MZXZlbDogdGhpcy5iYXNlLnpvb21MZXZlbFxuICAgIH07XG4gICAgdGhpcy5hbmltYXRlVG9UYXJnZXQodGFyZ2V0LCBkdXJhdGlvbik7XG4gIH1cblxuXG5cbiAgcHJpdmF0ZSBwYW5EZWx0YUFic29sdXRlKGRlbHRhOiBQb2ludCwgZHVyYXRpb246IG51bWJlciA9IG51bGwpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogcGFuRGVsdGFBYnNvbHV0ZSgpOiBkZWx0YTonLCBkZWx0YSk7XG5cbiAgICAvLyBBUEkgY2FsbCB0byBwYW4gdGhlIHZpZXcgbGVmdCwgcmlnaHQsIHVwLCBvciBkb3duLCBiYXNlZCBvbiBhIG51bWJlciBvZiBwaXhlbHNcbiAgICAvLyBUaGlzIG1ldGhvZCBkb2Vzbid0IGFkanVzdCBmb3Igc2NhbGUuICBJJ20gbm90IHN1cmUgd2h5IHlvdSdkIHdhbnQgdGhpc1xuICAgIC8vIGJ1dCBoYXZlIGl0IGhlcmUganVzdCBpbiBjYXNlIHNvbWVvbmUgbmVlZHMgaXRcbiAgICAvLyBQb3NpdGl2ZSBpcyByaWdodCBhbmQgZG93blxuICAgIC8vIE5lZ2F0aXZlIGlzIGxlZnQgYW5kIHVwXG4gICAgLy8gZXhhbXBsZSBwb2ludDogeyBcInhcIjogMTAwLCBcInlcIjogLTUwIH0gLy8gbW92ZXMgdGhlIHZpZXcgcmlnaHQgNTBweCBhbmQgdXAgNTBweFxuXG4gICAgbGV0IHRhcmdldDogUGFuWm9vbU1vZGVsID0ge1xuICAgICAgcGFuOiB7XG4gICAgICAgIHg6IHRoaXMuYmFzZS5wYW4ueCAtIGRlbHRhLngsXG4gICAgICAgIHk6IHRoaXMuYmFzZS5wYW4ueSAtIGRlbHRhLnlcbiAgICAgIH0sXG4gICAgICB6b29tTGV2ZWw6IHRoaXMuYmFzZS56b29tTGV2ZWxcbiAgICB9O1xuICAgIHRoaXMuYW5pbWF0ZVRvVGFyZ2V0KHRhcmdldCwgZHVyYXRpb24pO1xuICB9XG5cblxuXG4gIHByaXZhdGUgcGFuRGVsdGFQZXJjZW50KGRlbHRhUGVyY2VudDogUG9pbnQsIGR1cmF0aW9uOiBudW1iZXIgPSBudWxsKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IHBhbkRlbHRhUGVyY2VudCgpOiBkZWx0YVBlcmNlbnQ6JywgZGVsdGFQZXJjZW50KTtcblxuICAgIC8vIEFQSSBjYWxsIHRvIHBhbiB0aGUgdmlldyB1cCwgZG93biwgbGVmdCwgb3IgcmlnaHQsIGJhc2VkIG9uIGEgcGVyY2VudGFnZVxuICAgIC8vIG9mIHRoZSBvcmlnaW5hbCwgdW56b29tZWQgY29udGVudCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgLy8gZXhhbXBsZSBwb2ludDogeyBcInhcIjogMTAsIFwieVwiOiAtMjAgfVxuXG4gICAgbGV0IGRlbHRhWCA9IDA7XG4gICAgbGV0IGRlbHRhWSA9IDA7XG4gICAgaWYgKGRlbHRhUGVyY2VudC54ICE9PSAwKSB7XG4gICAgICBkZWx0YVggPSB0aGlzLmNvbnRlbnRXaWR0aCAqICggZGVsdGFQZXJjZW50LnggLyAxMDAgKSAqIHRoaXMuc2NhbGU7XG4gICAgfVxuICAgIGlmIChkZWx0YVBlcmNlbnQueSAhPT0gMCkge1xuICAgICAgZGVsdGFZID0gdGhpcy5jb250ZW50SGVpZ2h0ICogKCBkZWx0YVBlcmNlbnQueSAvIDEwMCApICogdGhpcy5zY2FsZTtcbiAgICB9XG5cbiAgICBsZXQgdGFyZ2V0OiBQYW5ab29tTW9kZWwgPSB7XG4gICAgICBwYW46IHtcbiAgICAgICAgeDogdGhpcy5iYXNlLnBhbi54IC0gZGVsdGFYLFxuICAgICAgICB5OiB0aGlzLmJhc2UucGFuLnkgLSBkZWx0YVlcbiAgICAgIH0sXG4gICAgICB6b29tTGV2ZWw6IHRoaXMuYmFzZS56b29tTGV2ZWxcbiAgICB9O1xuICAgIC8vIHRhcmdldC5wYW4ueCBpcyB0aGUgcGFuRWxlbWVudCBsZWZ0IHN0eWxlIHByb3BlcnR5XG4gICAgLy8gdGFyZ2V0LnBhbi55IGlzIHRoZSBwYW5FbGVtZW50IHRvcCBzdHlsZSBwcm9wZXJ0eVxuICAgIHRoaXMuYW5pbWF0ZVRvVGFyZ2V0KHRhcmdldCwgZHVyYXRpb24pO1xuICB9XG5cblxuXG5cblxuXG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gQU5JTUFUSU9OIEJVSUxERVJTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG5cbiAgcHJpdmF0ZSBhbmltYXRlVG9UYXJnZXQodGFyZ2V0TW9kZWw6IFBhblpvb21Nb2RlbCwgZHVyYXRpb24gPSBudWxsKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IGFuaW1hdGVUb1RhcmdldCgpJyk7XG4gICAgLy8gd2hhdCB0aGlzIGZ1bmN0aW9uIHJlYWxseSBkb2VzIGlzIHRha2UgYSB0YXJnZXQgbW9kZWwsIGFuZCB0aGVuIHNldHNcbiAgICAvLyB0aGlzLmFuaW1hdGlvblBhcmFtcyB3aXRoIHRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgd2hvbGUgYW5pbWF0aW9uLFxuICAgIC8vIG5hbWVseSB0aGUgZGVsdGEgem9vbUxldmVsXG4gICAgLy8gaXQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBjYWxsZXIgdG8ga2ljayBvZmYgdGhlIGFuaW1hdGlvbiB3aXRoIGEgY2FsbCB0byBhbmltYXRpb25GcmFtZUZ1bmMoKVxuXG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uUGFyYW1zKSB7XG4gICAgICAvLyBtYWtlIHRoZSB1c2VyIHdhaXQgZm9yIGV4aXN0aW5nIGFuaW1hdGlvbiB0byBmaW5pc2ggYmVmb3JlIGNsaWNraW5nXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy56b29tTGV2ZWxJc0NoYW5naW5nID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuYmFzZS56b29tTGV2ZWwgIT09IHRhcmdldE1vZGVsLnpvb21MZXZlbCkge1xuICAgICAgdGhpcy56b29tTGV2ZWxJc0NoYW5naW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZXQgZGVsdGFab29tTGV2ZWwgPSB0YXJnZXRNb2RlbC56b29tTGV2ZWwgLSB0aGlzLmJhc2Uuem9vbUxldmVsOyAvLyBkZWx0YVpvb21MZXZlbCBpcyB0aGUgbnVtYmVyIG9mIHpvb20gbGV2ZWxzIHdlIGFyZSBjaGFuZ2luZyBoZXJlXG5cbiAgICBsZXQgb2xkQmFzZTogUG9pbnQgPSB7XG4gICAgICAvLyB0aGUgY3VycmVudCBiYXNlIGNvb3JkaW5hdGVzXG4gICAgICB4OiB0aGlzLmJhc2UucGFuLngsXG4gICAgICB5OiB0aGlzLmJhc2UucGFuLnlcbiAgICB9O1xuICAgIHRoaXMubW9kZWwucGFuLnggPSB0aGlzLmJhc2UucGFuLng7XG4gICAgdGhpcy5tb2RlbC5wYW4ueSA9IHRoaXMuYmFzZS5wYW4ueTtcbiAgICAvKnRoaXMubGFzdENsaWNrUG9pbnQgPSB7XG4gICAgICB4OiB0aGlzLmJhc2UucGFuLngsXG4gICAgICB5OiB0aGlzLmJhc2UucGFuLnlcbiAgICB9OyovXG5cbiAgICBsZXQgcGFuU3RlcEZ1bmMgPSAoem9vbUxldmVsOiBudW1iZXIpID0+IHtcbiAgICAgIC8vIHRoaXMgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgZHVyaW5nIGV2ZXJ5IGFuaW1hdGlvbiB0aWNrIGluIHVwZGF0ZURPTSgpLCB0byBjYWxjdWxhdGUgd2hlcmUgdG8gbW92ZSB0aGUgbW9kZWwgcGFuIGNvb3JkaW5hdGVzIHRvIChpLmUuIHRoZSB0cmFuc2xhdGlvbikgZm9yIHRoYXQgdGljaywgem9vbUxldmVsIGlzIGlnbm9yZWQgd2l0aGluIGFuaW1hdGVUb1RhcmdldCgpXG4gICAgICBsZXQgdGFyZ2V0UG9pbnQ6IFBvaW50ID0ge1xuICAgICAgICAvLyBUaGUgdGFyZ2V0IHBvaW50IHRvIHpvb20gdG8gZm9yIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBmcmFtZS4gIEl0IG11c3Qgc3RheSB0aGUgc2FtZSBhcyB0aGUgdW50cmFuc2xhdGVkIHBvaW50XG4gICAgICAgIHg6IChvbGRCYXNlLnggLSB0YXJnZXRNb2RlbC5wYW4ueCkgKiB0aGlzLmFuaW1hdGlvblBhcmFtcy5wcm9ncmVzcyxcbiAgICAgICAgeTogKG9sZEJhc2UueSAtIHRhcmdldE1vZGVsLnBhbi55KSAqIHRoaXMuYW5pbWF0aW9uUGFyYW1zLnByb2dyZXNzXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4geyB4OiAtdGFyZ2V0UG9pbnQueCwgeTogLXRhcmdldFBvaW50LnkgfTtcbiAgICB9O1xuXG4gICAgLy8gbm93IHNldCB0aGUgcGFyYW1ldGVycyBvZiBvdXIgbmV3IGFuaW1hdGlvblxuICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgZHVyYXRpb24gPSBkdXJhdGlvbiAqIDEwMDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZHVyYXRpb24gPSB0aGlzLmNvbmZpZy56b29tU3RlcER1cmF0aW9uICogMTAwMDtcbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb25QYXJhbXMgPSB7XG4gICAgICBkZWx0YVpvb21MZXZlbDogZGVsdGFab29tTGV2ZWwsIC8vIGhvdyBtYW55IHpvb29tIGxldmVscyB0byB6b29tIGluIG9yIG91dFxuICAgICAgcGFuU3RlcEZ1bmM6IHBhblN0ZXBGdW5jLCAvLyBhIGZ1bmN0aW9uIHdoaWNoIHJ1bnMgb24gZXZlcnkgYW5pbWF0aW9uIHRpY2ssIHdoaWNoIGNhbGNzIGhvdyBtdWNoIHRvIHBhbiB0aGUgdmlldyBvbiBldmVyeSBmcmFtZVxuICAgICAgLy8gZHVyYXRpb246IGR1cmF0aW9uIHx8IHRoaXMuY29uZmlnLnpvb21TdGVwRHVyYXRpb24sIC8vIGhvdyBsb25nIHRoZSBhbmltYXRpb24gc2hvdWxkIHRha2VcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiwgLy8gaG93IGxvbmcgdGhlIGFuaW1hdGlvbiBzaG91bGQgdGFrZVxuICAgICAgcHJvZ3Jlc3M6IDAuMFxuICAgIH07XG5cbiAgICB0aGlzLnN0YXJ0QW5pbWF0aW9uKCk7XG5cbiAgfVxuXG5cblxuICBwcml2YXRlIGNoYW5nZVpvb21MZXZlbChuZXdab29tTGV2ZWw6IG51bWJlciwgY2xpY2tQb2ludDogUG9pbnQpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogY2hhbmdlWm9vbUxldmVsKCknKTtcblxuICAgIGlmICh0aGlzLmFuaW1hdGlvblBhcmFtcykge1xuICAgICAgLy8gbGV0J3MgbGV0IGFueSBjdXJyZW50IGFuaW1hdGlvbiBqdXN0IGZpbmlzaFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuem9vbUxldmVsSXNDaGFuZ2luZyA9IHRydWU7XG5cbiAgICAvLyBrZWVwIHpvb20gbGV2ZWwgaW4gYm91bmRzXG4gICAgbmV3Wm9vbUxldmVsID0gTWF0aC5tYXgodGhpcy5taW5pbXVtQWxsb3dlZFpvb21MZXZlbCwgbmV3Wm9vbUxldmVsKTtcbiAgICBuZXdab29tTGV2ZWwgPSBNYXRoLm1pbih0aGlzLmNvbmZpZy56b29tTGV2ZWxzIC0gMSwgbmV3Wm9vbUxldmVsKTtcbiAgICAvLyBjb25zb2xlLmxvZygnbmV3Wm9vbUxldmVsOicsIG5ld1pvb21MZXZlbCk7XG5cbiAgICBsZXQgZGVsdGFab29tTGV2ZWwgPSBuZXdab29tTGV2ZWwgLSB0aGlzLmJhc2Uuem9vbUxldmVsOyAvLyBkZWx0YVpvb21MZXZlbCBpcyB0aGUgbnVtYmVyIG9mIHpvb20gbGV2ZWxzIHdlIGFyZSBjaGFuZ2luZyBoZXJlXG4gICAgaWYgKCFkZWx0YVpvb21MZXZlbCkge1xuICAgICAgLy8gYSBkZWx0YVpvb21MZXZlbCBvZiB6ZXJvIG1lYW5zIHRoYXQgd2UgYXJlbid0IGNoYW5naW5nIHpvb20sIGJlY2F1c2Ugd2UncmUgZWl0aGVyIHpvb21lZCBhbGwgdGhlIHdheSBpbiBvciBhbGwgdGhlIHdheSBvdXRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIExldCBwIGJlIHRoZSB2ZWN0b3IgdG8gdGhlIGNsaWNrZWQgcG9pbnQgaW4gdmlldyBjb29yZHMgYW5kIGxldCBwJyBiZSB0aGUgc2FtZSBwb2ludCBpbiBtb2RlbCBjb29yZHMuIExldCBzIGJlIGEgc2NhbGUgZmFjdG9yXG4gICAgLy8gYW5kIGxldCB0IGJlIGEgdHJhbnNsYXRpb24gdmVjdG9yLiBMZXQgdGhlIHRyYW5zZm9ybWF0aW9uIGJlIGRlZmluZWQgYXM6XG4gICAgLy9cbiAgICAvLyAgcCcgPSBwICogcyArIHRcbiAgICAvL1xuICAgIC8vIEFuZCBjb252ZXJzZWx5OlxuICAgIC8vXG4gICAgLy8gIHAgPSAoMS9zKShwJyAtIHQpXG4gICAgLy9cbiAgICAvLyBOb3cgdXNlIHN1YnNjcmlwdGlvbiAwIHRvIGRlbm90ZSB0aGUgdmFsdWUgYmVmb3JlIHRyYW5zZm9ybSBhbmQgem9vbSBhbmQgbGV0IDEgZGVub3RlIHRoZSB2YWx1ZSBhZnRlciB0cmFuc2Zvcm0uIFNjYWxlXG4gICAgLy8gY2hhbmdlcyBmcm9tIHMwIHRvIHMxLiBUcmFuc2xhdGlvbiBjaGFuZ2VzIGZyb20gdDAgdG8gdDEuIEJ1dCBrZWVwIHAgYW5kIHAnIGZpeGVkIHNvIHRoYXQgdGhlIHZpZXcgY29vcmRpbmF0ZSBwJyBzdGlsbFxuICAgIC8vIGNvcnJlc3BvbmRzIHRvIHRoZSBtb2RlbCBjb29yZGluYXRlIHAuIFRoaXMgY2FuIGJlIGV4cHJlc3NlZCBhcyBhbiBlcXVhdGlvbiByZWx5aW5nIHVwb24gc29sZWx5IHVwb24gcCcsIHMwLCBzMSwgdDAsIGFuZCB0MTpcbiAgICAvL1xuICAgIC8vICAoMS9zMCkocCAtIHQwKSA9ICgxL3MxKShwIC0gdDEpXG4gICAgLy9cbiAgICAvLyBFdmVyeSB2YXJpYWJsZSBidXQgdDEgaXMga25vd24sIHRodXMgaXQgaXMgZWFzaWx5IGlzb2xhdGVkIHRvOlxuICAgIC8vXG4gICAgLy8gIHQxID0gcCcgLSAoczEvczApKihwJyAtIHQwKVxuICAgIC8vXG5cbiAgICBsZXQgY3VycmVudFBhbjogUG9pbnQgPSB7XG4gICAgICAvLyB0MCAtIHRoZSBjdXJyZW50IGJhc2UgY29vcmRpbmF0ZXNcbiAgICAgIHg6IHRoaXMuYmFzZS5wYW4ueCxcbiAgICAgIHk6IHRoaXMuYmFzZS5wYW4ueVxuICAgIH07XG5cbiAgICBsZXQgY3VycmVudFNjYWxlID0gdGhpcy5zY2FsZTsgLy8gczAgLSBnZXQgdGhlIGN1cnJlbnQgQ1NTIHNjYWxlIChzY2FsZTApXG4gICAgbGV0IGRlc3RQb2ludCA9IGNsaWNrUG9pbnQgfHwgdGhpcy5nZXRDZW50ZXJQb2ludCgpOyAvLyBwbWFyayAtIHRoZSBwb2ludCB3ZSBhcmUgYWltaW5nIHRvIHpvb20gdG8gKGVpdGhlciB0aGUgY2xpY2sgcG9pbnQgb3IgdGhlIGNlbnRyZSBvZiB0aGUgcGFnZSlcblxuXG4gICAgbGV0IHBhblN0ZXBGdW5jID0gKHpvb21MZXZlbDogbnVtYmVyKSA9PiB7XG4gICAgICAvLyB0aGlzIGZ1bmN0aW9uIGdldHMgY2FsbGVkIGR1cmluZyBldmVyeSBhbmltYXRpb24gdGljaywgdG8gY2FsY3VsYXRlIHdoZXJlIHRvIG1vdmUgdGhlIG1vZGVsIHBhbiBjb29yZGluYXRlcyB0byAoaS5lLiB0aGUgdHJhbnNsYXRpb24pIGZvciB0aGF0IHRpY2ssIHdoZXJlIHpvb21MZXZlbCBpcyBjYWxjdWxhdGVkIGZyb20gdGhlIGN1cnJlbnQgem9vbUxldmVsICsgdGhlIHRhcmdldCB6b29tTGV2ZWwgKiB0aGUgcHJvZ3Jlc3Mgb2YgdGhlIGN1cnJlbnQgYW5pbWF0aW9uXG5cbiAgICAgIGxldCB0YXJnZXRTY2FsZSA9IHRoaXMuZ2V0Q3NzU2NhbGUoem9vbUxldmVsKTsgLy8gczEgLSB0aGUgc2NhbGUgdG8gdHJhbnNsYXRlIHRvIGZvciB0aGUgY3VycmVudCBhbmltYXRpb24gdGlja1xuICAgICAgbGV0IHRhcmdldFBvaW50OiBQb2ludCA9IHtcbiAgICAgICAgLy8gdDEgLSBUaGUgdGFyZ2V0IHBvaW50IHRvIHBhbiB0by4gIEl0IG11c3Qgc3RheSB0aGUgc2FtZSBhcyB0aGUgdW50cmFuc2xhdGVkIHBvaW50XG4gICAgICAgIHg6IGRlc3RQb2ludC54IC0gKHRhcmdldFNjYWxlIC8gY3VycmVudFNjYWxlKSAqIChkZXN0UG9pbnQueCAtIGN1cnJlbnRQYW4ueCksXG4gICAgICAgIHk6IGRlc3RQb2ludC55IC0gKHRhcmdldFNjYWxlIC8gY3VycmVudFNjYWxlKSAqIChkZXN0UG9pbnQueSAtIGN1cnJlbnRQYW4ueSlcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIG5vdyByZXR1cm4gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvdXIgaW5pdGlhbCBjbGljayBwb2ludCBhbmQgb3VyIHRyYW5zbGF0ZWQgKHpvb21lZCkgY2xpY2sgcG9pbnRcbiAgICAgICAgLy8gdGhlc2UgYXJlIG5vdCBhYnNvbHV0ZSBjb29yZGluYXRlcyAtIGp1c3QgaG93IGZhciB0byBtb3ZlIHRoZW1cbiAgICAgICAgeDogdGFyZ2V0UG9pbnQueCAtIGN1cnJlbnRQYW4ueCxcbiAgICAgICAgeTogdGFyZ2V0UG9pbnQueSAtIGN1cnJlbnRQYW4ueVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gbm93IHNldCB0aGUgcGFyYW1ldGVycyBvZiBvdXIgbmV3IGFuaW1hdGlvblxuICAgIHRoaXMuYW5pbWF0aW9uUGFyYW1zID0ge1xuICAgICAgZGVsdGFab29tTGV2ZWw6IGRlbHRhWm9vbUxldmVsLCAvLyB0aGUgZGVzdGluYXRpb24gem9vbSBsZXZlbCBmb3IgdGhpcyB6b29tIG9wZXJhdGlvbiAod2hlbiB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlZClcbiAgICAgIHBhblN0ZXBGdW5jOiBwYW5TdGVwRnVuYyxcbiAgICAgIC8vIGR1cmF0aW9uOiB0aGlzLmNvbmZpZy56b29tU3RlcER1cmF0aW9uLCAvLyBob3cgbG9uZyB0aGUgYW5pbWF0aW9uIHNob3VsZCB0YWtlXG4gICAgICBkdXJhdGlvbjogdGhpcy5jb25maWcuem9vbVN0ZXBEdXJhdGlvbiAqIDEwMDAsIC8vIGhvdyBsb25nIHRoZSBhbmltYXRpb24gc2hvdWxkIHRha2VcbiAgICAgIHByb2dyZXNzOiAwLjBcbiAgICB9O1xuICAgIHRoaXMuc3RhcnRBbmltYXRpb24oKTtcblxuICB9XG5cblxuXG59XG4iXX0=