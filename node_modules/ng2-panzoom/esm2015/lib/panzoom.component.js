/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ElementRef, ViewChild, Input, NgZone } from '@angular/core';
import { PanZoomConfig } from './panzoom-config';
/**
 * @record
 */
function ZoomAnimation() { }
if (false) {
    /** @type {?} */
    ZoomAnimation.prototype.deltaZoomLevel;
    /** @type {?} */
    ZoomAnimation.prototype.panStepFunc;
    /** @type {?} */
    ZoomAnimation.prototype.duration;
    /** @type {?} */
    ZoomAnimation.prototype.progress;
}
/**
 * @record
 */
function Position() { }
if (false) {
    /** @type {?|undefined} */
    Position.prototype.x;
    /** @type {?|undefined} */
    Position.prototype.y;
    /** @type {?|undefined} */
    Position.prototype.length;
}
export class PanZoomComponent {
    /**
     * @param {?} el
     * @param {?} zone
     */
    constructor(el, zone) {
        this.el = el;
        this.zone = zone;
        this.previousPosition = null;
        this.isDragging = false;
        this.panVelocity = null;
        this.animationParams = null;
        // reference to the appropriate getAnimationFrame function for the client browser
        this.lastTick = 0;
        this.isChrome = false;
        this.willChangeNextFrame = true; // used for scaling in Chrome
        this.isMobile = false;
        this.isFirstSync = true;
        this.zoomLevelIsChanging = false;
        this.dragFinishing = false;
        this.dragMouseButton = null;
        //////////////////////////// END OF LIFECYCLE HOOKS ////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        ///////////////////////////////// EVENT HANDLERS ///////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        this.onMouseWheel = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            // console.log('PanZoomComponent: OnMouseWheel() event:', event);
            if (!(event && event.pageX && event.pageY)) {
                return;
            }
            // let event = e.event;
            /** @type {?} */
            let deltaY = event.deltaY;
            if (this.config.zoomOnMouseWheel) {
                // event.preventDefault();
                if (this.animationParams) {
                    return; // already zooming
                }
                if (!this.config.invertMouseWheel) {
                    deltaY = -deltaY;
                }
                // console.log('deltaY:', event.deltaY);
                // let sign = event.deltaY / Math.abs(event.deltaY);
                /** @type {?} */
                let clickPoint = {
                    x: event.pageX - this.jQueryFrameElement.offset().left,
                    y: event.pageY - this.jQueryFrameElement.offset().top
                };
                this.lastClickPoint = clickPoint;
                if (this.config.freeMouseWheel) {
                    // free wheel scroll
                    this.freeZoom(clickPoint, deltaY);
                }
                else {
                    // let sign = Math.sign(event.deltaY);
                    if (deltaY < 0) {
                        this.zoomIn(clickPoint);
                    }
                    else if (deltaY > 0) {
                        this.zoomOut(clickPoint);
                    }
                }
            }
        });
        this.onMousedown = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            // console.log('PanZoomComponent: onMousedown()', event);
            /* Check if clicked location is inside element from which
               dragging is prevented. */
            if (this.config.noDragFromElementClass
                && this.isParentElement(this.config.noDragFromElementClass, event.srcElement)) {
                return;
            }
            if (event.button === this.dragMouseButton || event.type === 'touchstart') {
                event.preventDefault();
                // event.stopPropagation();
                this.dragFinishing = false;
                this.panVelocity = null;
                if (this.config.panOnClickDrag) {
                    this.previousPosition = {
                        x: event.pageX,
                        y: event.pageY
                    };
                    this.lastMouseEventTime = event.timeStamp;
                    this.isDragging = true;
                    this.model.isPanning = false;
                    if (this.isMobile) {
                        this.zone.runOutsideAngular((/**
                         * @return {?}
                         */
                        () => document.addEventListener('touchend', this.onTouchEnd, false))); // leave this on document
                        this.zone.runOutsideAngular((/**
                         * @return {?}
                         */
                        () => document.addEventListener('touchmove', this.onTouchMove, { passive: true, capture: false }))); // leave this on document
                    }
                    else {
                        this.zone.runOutsideAngular((/**
                         * @return {?}
                         */
                        () => document.addEventListener('mousemove', this.onMouseMove, { passive: true, capture: false }))); // leave this on document
                        this.zone.runOutsideAngular((/**
                         * @return {?}
                         */
                        () => document.addEventListener('mouseup', this.onMouseUp))); // leave this on document
                    }
                }
                return false;
            }
        });
        this.onTouchStart = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            // console.log('PanZoomComponent: onTouchStart()', event);
            // console.log('PanZoomComponent: onTouchStart(): touches:', event.touches.length);
            event.preventDefault();
            // event.stopPropagation();
            if (event.touches.length !== 1) {
                // multiple touches, get ready for zooming
                // Calculate x and y distance between touch events
                /** @type {?} */
                let x = event.touches[0].pageX - event.touches[1].pageX;
                /** @type {?} */
                let y = event.touches[0].pageY - event.touches[1].pageY;
                // Calculate length between touch points with pythagoras
                // There is no reason to use Math.pow and Math.sqrt as we
                // only want a relative length and not the exact one.
                this.previousPosition = {
                    length: x * x + y * y
                };
            }
            this.onMousedown(event);
        });
        this.onMouseMove = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            // console.log('PanZoomComponent: onMouseMove()', event);
            // console.log(`PanZoomComponent: onMouseMove(): event.timeStamp:`, event.timeStamp);
            // timestamp - 10587.879999999132 - milliseconds
            // Called when moving the mouse with the left button down
            // event.preventDefault();
            // event.stopPropagation();
            if (!(event && event.pageX && event.pageY)) {
                return;
            }
            /** @type {?} */
            let now = event.timeStamp;
            /** @type {?} */
            let timeSinceLastMouseEvent = (now - this.lastMouseEventTime) / 1000;
            // let timeSinceLastMouseEvent = (now - this.lastMouseEventTime);
            this.lastMouseEventTime = now;
            /** @type {?} */
            let dragDelta = {
                // a representation of how far each coordinate has moved since the last time it was moved
                x: event.pageX - this.previousPosition.x,
                y: event.pageY - this.previousPosition.y
            };
            if (this.config.keepInBounds) {
                /** @type {?} */
                let topLeftCornerView = this.getViewPosition({ x: 0, y: 0 });
                /** @type {?} */
                let bottomRightCornerView = this.getViewPosition({ x: this.contentWidth, y: this.contentHeight });
                if (topLeftCornerView.x > 0 && dragDelta.x > 0) {
                    dragDelta.x *= Math.min(1, Math.pow(topLeftCornerView.x, -this.config.keepInBoundsDragPullback));
                }
                if (topLeftCornerView.y > 0 && dragDelta.y > 0) {
                    dragDelta.y *= Math.min(1, Math.pow(topLeftCornerView.y, -this.config.keepInBoundsDragPullback));
                }
                if (bottomRightCornerView.x < this.contentWidth && dragDelta.x < 0) {
                    dragDelta.x *= Math.min(1, Math.pow(this.contentWidth - bottomRightCornerView.x, -this.config.keepInBoundsDragPullback));
                }
                if (bottomRightCornerView.y < this.contentHeight && dragDelta.y < 0) {
                    dragDelta.y *= Math.min(1, Math.pow(this.contentHeight - bottomRightCornerView.y, -this.config.keepInBoundsDragPullback));
                }
            }
            // now pan the view
            /** @type {?} */
            let delta = {
                x: dragDelta.x || 0,
                y: dragDelta.y || 0
            };
            this.model.pan.x += delta.x;
            this.model.pan.y += delta.y;
            this.syncBaseToModel();
            this.animationTick(performance.now());
            if (!this.model.isPanning) {
                // This will improve the performance,
                // because the browser stops evaluating hits against the elements displayed inside the pan zoom view.
                // Besides this, mouse events will not be sent to any other elements,
                // this prevents issues like selecting elements while dragging.
                this.panzoomOverlayRef.nativeElement.style.display = 'block';
            }
            this.model.isPanning = true;
            // set these for the animation slow down once drag stops
            // panVelocity is a measurement of speed for x and y coordinates, in pixels per mouse move event.  It is a measure of how fast the mouse is moving
            this.panVelocity = {
                x: dragDelta.x / timeSinceLastMouseEvent,
                y: dragDelta.y / timeSinceLastMouseEvent
            };
            // console.log(`PanZoomComponent: onMouseMove(): panVelocity:`, this.panVelocity);
            this.previousPosition = {
                x: event.pageX,
                y: event.pageY
            };
        });
        this.onTouchMove = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            // console.log('PanZoomComponent: onTouchMove()');
            // console.log('PanZoomComponent: onTouchMove(): event:', event);
            // event.preventDefault();
            // event.stopPropagation();
            if (event.touches.length === 1) {
                // single touch, emulate mouse move
                this.onMouseMove(event);
            }
            else {
                // multiple touches, zoom in/out
                // console.log('pinch zooming');
                // Calculate x and y distance between touch events
                /** @type {?} */
                let x = event.touches[0].pageX - event.touches[1].pageX;
                /** @type {?} */
                let y = event.touches[0].pageY - event.touches[1].pageY;
                // Calculate length between touch points with pythagoras
                // There is no reason to use Math.pow and Math.sqrt as we
                // only want a relative length and not the exact one.
                /** @type {?} */
                let length = x * x + y * y;
                // Calculate delta between current position and last position
                /** @type {?} */
                let delta = length - this.previousPosition.length;
                // Naive hysteresis
                if (Math.abs(delta) < 100) {
                    return;
                }
                // Calculate center between touch points
                /** @type {?} */
                let centerX = event.touches[1].pageX + x / 2;
                /** @type {?} */
                let centerY = event.touches[1].pageY + y / 2;
                // Calculate zoom center
                /** @type {?} */
                let clickPoint = {
                    x: centerX - this.jQueryFrameElement.offset().left,
                    y: centerY - this.jQueryFrameElement.offset().top
                };
                this.lastClickPoint = clickPoint;
                this.changeZoomLevel(this.base.zoomLevel + delta * 0.0001, clickPoint);
                // this.freeZoom( clickPoint, delta);
                // Update length for next move event
                this.previousPosition = {
                    length: length
                };
            }
        });
        this.onMouseUp = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            // console.log('PanZoomComponent: onMouseup()', event);
            if (event.button !== this.dragMouseButton) {
                return;
            }
            event.preventDefault();
            // event.stopPropagation();
            /** @type {?} */
            let now = event.timeStamp;
            /** @type {?} */
            let timeSinceLastMouseEvent = (now - this.lastMouseEventTime) / 1000;
            if (this.panVelocity && (this.panVelocity.x !== 0 || this.panVelocity.y !== 0)) {
                // apply strong initial dampening if the mouse up occured much later than the last mouse move, indicating that the mouse hasn't moved recently
                // TBD - experiment with this formula
                /** @type {?} */
                let initialMultiplier = Math.max(0, -0.2 + Math.pow(timeSinceLastMouseEvent + 1, -4));
                this.panVelocity.x *= initialMultiplier;
                this.panVelocity.y *= initialMultiplier;
                this.dragFinishing = true;
                // console.log(`PanZoomComponent: onMouseUp(): panVelocity:`, this.panVelocity);
                this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                () => this.animationId = this.animationFrameFunc(this.animationTick)));
            }
            else {
                this.dragFinishing = false;
                this.panVelocity = null;
            }
            this.isDragging = false;
            // this.model.isPanning = false;
            if (this.isMobile) {
                this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                () => document.removeEventListener('touchend', this.onTouchEnd)));
                this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                () => document.removeEventListener('touchmove', this.onTouchMove, (/** @type {?} */ ({ passive: true, capture: false })))));
            }
            else {
                this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                () => document.removeEventListener('mousemove', this.onMouseMove, (/** @type {?} */ ({ passive: true, capture: false })))));
                this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                () => document.removeEventListener('mouseup', this.onMouseUp, (/** @type {?} */ ({ passive: true })))));
            }
            // Set the overlay to non-blocking again:
            this.panzoomOverlayRef.nativeElement.style.display = 'none';
        });
        this.onTouchEnd = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            // console.log('PanZoomComponent: onTouchEnd()');
            this.onMouseUp(event);
        });
        this.onDblClick = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            // console.log('PanZoomComponent: onDblClick()');
            event.preventDefault();
            // event.stopPropagation();
            if (!this.config.zoomOnDoubleClick) {
                return;
            }
            /** @type {?} */
            let clickPoint = {
                x: event.pageX - this.jQueryFrameElement.offset().left,
                y: event.pageY - this.jQueryFrameElement.offset().top
            };
            this.lastClickPoint = clickPoint;
            this.zoomIn(clickPoint);
        });
        this.preventDefault = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            event.preventDefault();
        });
        ////////////////////////////////////////////////////////////////////////////////
        ///////////////////////////// END EVENT HANDLERS ///////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        ///////////////////////////// APPLY ANIMATIONS /////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        this.animationTick = (/**
         * @param {?} timestamp
         * @return {?}
         */
        (timestamp) => {
            // console.log('PanZoomComponent: animationTick()');
            // timestamp looks like 76916.963.  The unit is milliseconds and should be accurate to 5 µs (microseconds)
            // console.log('PanZoomComponent: animationTick()');
            // timestamp looks like 76916.963.  The unit is milliseconds and should be accurate to 5 µs (microseconds)
            /** @type {?} */
            let deltaTime = 0;
            if (this.lastTick !== 0) {
                deltaTime = (timestamp - this.lastTick); // orig - milliseconds since the last animationTick
            }
            this.lastTick = timestamp;
            if (this.animationParams) {
                // when we're running an animation (but not waiting for a released drag to halt)
                // console.log('PanZoomComponent: animationTick(): model is zooming');
                this.animationParams.progress += Math.abs(deltaTime / this.animationParams.duration);
                if (this.animationParams.progress >= 1.0) {
                    // Only when the animation has finished, sync the base to the model.
                    this.animationParams.progress = 1.0;
                    this.updateDOM();
                    this.animationParams = null;
                }
            }
            if (this.panVelocity && this.dragFinishing) {
                // This is when we've panned and released the mouse button and the view is "free-floating" until it slows to a halt.  Don't let the while loop fool you - this only applies it for the current frame.
                // Prevent overshooting if delta time is large for some reason. We apply the simple solution of slicing delta time into smaller pieces and applying each one
                if (deltaTime > 0) {
                    deltaTime = deltaTime / 1000;
                }
                while (deltaTime > 0) {
                    /** @type {?} */
                    let dTime = Math.min(.02, deltaTime);
                    deltaTime = deltaTime - dTime;
                    this.model.pan.x = this.model.pan.x + this.panVelocity.x * dTime;
                    this.panVelocity.x = this.panVelocity.x * (1 - this.config.friction * dTime);
                    this.model.pan.y = this.model.pan.y + this.panVelocity.y * dTime;
                    this.panVelocity.y = this.panVelocity.y * (1 - this.config.friction * dTime);
                    /** @type {?} */
                    let speed = this.length(this.panVelocity);
                    if (speed < this.config.haltSpeed) {
                        this.model.isPanning = false;
                        this.panVelocity = null;
                        this.dragFinishing = false;
                        break;
                    }
                }
            }
            if (this.config.keepInBounds || this.dragFinishing) {
                // Checks that keepInBounds is set and that the mouse button isn't pressed, and if so, it stops the contents from going out of view
                // console.log('PanZoomComponent: animationTick(): keepInBounds');
                /** @type {?} */
                let topLeftCornerView = this.getViewPosition({ x: 0, y: 0 });
                /** @type {?} */
                let bottomRightCornerView = this.getViewPosition({ x: this.contentWidth, y: this.contentHeight });
                if (topLeftCornerView.x > 0) {
                    this.base.pan.x -= this.config.keepInBoundsRestoreForce * topLeftCornerView.x;
                }
                if (topLeftCornerView.y > 0) {
                    this.base.pan.y -= this.config.keepInBoundsRestoreForce * topLeftCornerView.y;
                }
                if (bottomRightCornerView.x < this.contentWidth) {
                    this.base.pan.x -= this.config.keepInBoundsRestoreForce * (bottomRightCornerView.x - this.contentWidth);
                }
                if (bottomRightCornerView.y < this.contentHeight) {
                    this.base.pan.y -= this.config.keepInBoundsRestoreForce * (bottomRightCornerView.y - this.contentHeight);
                }
            }
            this.updateDOM();
            this.config.modelChanged.next(this.model);
            if (this.animationParams || (this.panVelocity && this.dragFinishing)) {
                // Are we in an animation?  If so, run the next frame
                if (this.isChrome && this.zoomLevelIsChanging) {
                    // run will-change toggle hack on Chrome to trigger re-rasterization
                    // see https://developers.google.com/web/updates/2016/09/re-rastering-composite
                    if (this.willChangeNextFrame) {
                        ((/** @type {?} */ (this.acceleratedFrameRef.nativeElement.style))).willChange = 'auto';
                    }
                    else {
                        ((/** @type {?} */ (this.acceleratedFrameRef.nativeElement.style))).willChange = 'transform';
                    }
                    this.willChangeNextFrame = !this.willChangeNextFrame;
                }
                // console.log('calling next tick');
                this.animationFrameFunc(this.animationTick); // Call the next animation frame
            }
            else if (this.panVelocity && !this.dragFinishing) {
                // we're just mouse-panning the frame.  We don't need another tick
                return;
            }
            else {
                // Animation has ended
                this.syncBaseToModel();
                this.scale = this.getCssScale(this.base.zoomLevel);
                this.willChangeNextFrame = true;
                ((/** @type {?} */ (this.acceleratedFrameRef.nativeElement.style))).willChange = 'transform';
                this.zoomLevelIsChanging = false;
                this.lastTick = 0;
            }
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // console.log('PanZoomComponent: ngOnInit(): initializing PanZoomComponent');
        if (this.config.initialZoomToFit) {
            this.base = this.calcZoomToFit(this.config.initialZoomToFit);
        }
        else {
            this.base = {
                zoomLevel: this.config.initialZoomLevel,
                pan: {
                    x: this.config.initialPanX,
                    y: this.config.initialPanY
                }
            };
        }
        this.model = {
            zoomLevel: this.base.zoomLevel,
            isPanning: false,
            // Only true if panning is actually taking place, not just after mousedown
            pan: {
                x: this.base.pan.x,
                y: this.base.pan.y
            }
        };
        this.config.modelChanged.next(this.model);
        // create public API
        this.api = {
            model: this.model,
            config: this.config,
            changeZoomLevel: this.zoomToLevelAndPoint.bind(this),
            zoomIn: this.zoomInToLastClickPoint.bind(this),
            zoomOut: this.zoomOutFromLastClickPoint.bind(this),
            zoomToFit: this.zoomToFit.bind(this),
            resetView: this.resetView.bind(this),
            getViewPosition: this.getViewPosition.bind(this),
            getModelPosition: this.getModelPosition.bind(this),
            panToPoint: this.panToPoint.bind(this),
            panDelta: this.panDelta.bind(this),
            panDeltaPercent: this.panDeltaPercent.bind(this),
            panDeltaAbsolute: this.panDeltaAbsolute.bind(this)
        };
        this.config.api.next(this.api);
        if (this.config.freeMouseWheel) {
            this.scale = this.getCssScale(this.config.initialZoomLevel);
            /** @type {?} */
            let maxZoomLevel = this.config.zoomLevels - 1;
            this.maxScale = this.getCssScale(maxZoomLevel);
            this.minScale = this.getCssScale(0);
        }
        this.minimumAllowedZoomLevel = 0;
        if (this.config.keepInBounds) {
            this.minimumAllowedZoomLevel = this.config.neutralZoomLevel;
            this.minScale = this.getCssScale(this.config.neutralZoomLevel);
        }
        this.acceleratedFrameRef = this.zoomElementRef;
        // console.log('frameHeight:', this.frameHeight);
        // console.log('frameWidth:', this.frameWidth);
        ((/** @type {?} */ (this.acceleratedFrameRef.nativeElement.style))).willChange = 'transform';
        if (navigator.userAgent.search('Chrome') >= 0) {
            this.isChrome = true;
            this.acceleratedFrameRef.nativeElement.style.transform = 'translateZ(0)';
        }
        this.animationTick(performance.now());
        this.scale = this.getCssScale(this.base.zoomLevel);
        this.isFirstSync = false;
        switch (this.config.dragMouseButton) {
            case 'left':
                this.dragMouseButton = 0;
                break;
            case 'middle':
                this.dragMouseButton = 1;
                this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                () => this.frameElementRef.nativeElement.addEventListener('auxclick', this.preventDefault)));
                break;
            case 'right':
                this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                () => document.addEventListener('contextmenu', this.preventDefault)));
                this.dragMouseButton = 2;
                break;
            default:
                this.dragMouseButton = 0; // left
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // console.log('PanZoomComponent: ngAfterViewInit()');
        this.jQueryFrameElement = $('.pan-zoom-frame');
        this.contentHeight = $('.zoomElement').children().height();
        this.contentWidth = $('.zoomElement').children().width();
        this.frameHeight = this.jQueryFrameElement.height();
        this.frameWidth = this.jQueryFrameElement.width();
        this.zone.runOutsideAngular((/**
         * @return {?}
         */
        () => this.animationFrameFunc = window.requestAnimationFrame));
        // this.zone.runOutsideAngular( () => this.wheelAnimationFrameFunc = window.requestAnimationFrame );
        if (this.isMobileDevice()) {
            this.isMobile = true;
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            () => this.frameElementRef.nativeElement.addEventListener('touchstart', this.onTouchStart)));
        }
        else {
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            () => this.frameElementRef.nativeElement.addEventListener('mousedown', this.onMousedown)));
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            () => this.frameElementRef.nativeElement.addEventListener('dblclick', this.onDblClick)));
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            () => this.frameElementRef.nativeElement.addEventListener('wheel', (/**
             * @param {?} event
             * @return {?}
             */
            (event) => this.animationFrameFunc((/**
             * @return {?}
             */
            () => this.onMouseWheel(event)))), { passive: true })));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // console.log('PanZoomComponent: ngOnDestroy()');
        if (this.isMobile) {
            this.frameElementRef.nativeElement.removeEventListener('touchstart', this.onTouchStart);
        }
        else {
            this.frameElementRef.nativeElement.removeEventListener('mousedown', this.onMousedown);
            this.frameElementRef.nativeElement.removeEventListener('wheel', (/**
             * @param {?} event
             * @return {?}
             */
            (event) => this.animationFrameFunc((/**
             * @return {?}
             */
            () => this.onMouseWheel(event)))), { passive: true });
            this.frameElementRef.nativeElement.removeEventListener('dblclick', this.onDblClick);
        }
        if (this.animationFrameFunc && this.animationId) {
            window.cancelAnimationFrame(this.animationId);
        }
        switch (this.config.dragMouseButton) {
            case 'middle':
                this.dragMouseButton = 1;
                this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                () => this.frameElementRef.nativeElement.removeEventListener('auxclick', this.preventDefault)));
                break;
            case 'right':
                this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                () => document.removeEventListener('contextmenu', this.preventDefault)));
                this.dragMouseButton = 2;
                break;
        }
    }
    /**
     * Method will check if 'child' node element is a child of
     * parent node with class 'className'
     * @private
     * @param {?} className
     * @param {?} child
     * @return {?}
     */
    isParentElement(className, child) {
        /** @type {?} */
        let node = child.parentNode;
        while (node != null) {
            if (node.classList && node.classList.contains(className)) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    }
    /**
     * @private
     * @return {?}
     */
    updateDOM() {
        // console.log('PanZoomComponent: updateDOM()');
        // Called by ngAfterViewInit() and animationTick()
        // This function does not get called by freeZoom(), which operates independently of animationTick() and updateDOM().
        if (this.animationParams) {
            // we're running an animation sequence (but not freeZooming or panning with onMouseMove() )
            this.model.zoomLevel = this.base.zoomLevel + this.animationParams.deltaZoomLevel * this.animationParams.progress; // calculate how far we need to zoom in or out for the current animationTick
            // calculate how far we need to zoom in or out for the current animationTick
            /** @type {?} */
            let deltaTranslation = this.animationParams.panStepFunc(this.model.zoomLevel);
            // sync the model pan coordinates to our translated pan coordinates
            // we do this by adding how far we want to move in each direction to our our existing base pan coordinates (where we started)
            this.model.pan.x = this.base.pan.x + deltaTranslation.x;
            this.model.pan.y = this.base.pan.y + deltaTranslation.y;
            if (this.config.keepInBounds) {
                /** @type {?} */
                let topLeftCornerView = this.getViewPosition({ x: 0, y: 0 });
                /** @type {?} */
                let bottomRightCornerView = this.getViewPosition({ x: this.contentWidth, y: this.contentHeight });
                if (topLeftCornerView.x > 0) {
                    this.model.pan.x = 0;
                }
                if (topLeftCornerView.y > 0) {
                    this.model.pan.y = 0;
                }
                if (bottomRightCornerView.x < this.contentWidth) {
                    this.model.pan.x -= (bottomRightCornerView.x - this.contentWidth);
                }
                if (bottomRightCornerView.y < this.contentHeight) {
                    this.model.pan.y -= (bottomRightCornerView.y - this.contentHeight);
                }
            }
        }
        ////////////////////////////////////////////////////
        //////////////////// APPLY SCALING /////////////////
        ////////////////////////////////////////////////////
        if (this.animationParams || this.isFirstSync) {
            /** @type {?} */
            let scale = this.getCssScale(this.model.zoomLevel);
            /** @type {?} */
            let scaleString = `scale(${scale})`;
            this.zoomElementRef.nativeElement.style.transformOrigin = '0 0';
            this.zoomElementRef.nativeElement.style.transform = scaleString;
        }
        ////////////////////////////////////////////////////
        //////////////// APPLY PAN ANIMATION ///////////////
        ////////////////////////////////////////////////////
        /** @type {?} */
        let translate3d = `translate3d(${this.model.pan.x}px, ${this.model.pan.y}px, 0)`;
        this.panElementRef.nativeElement.style.transform = translate3d;
    }
    /**
     * @private
     * @param {?} clickPoint
     * @param {?} wheelDelta
     * @return {?}
     */
    freeZoom(clickPoint, wheelDelta) {
        // console.log('PanZoomComponent: freeZoom(): this.base:', this.base);
        if (this.isDragging) {
            // don't allow zooming if the mouse is down
            return;
        }
        // now handle interruption of an in-progress animation
        if (this.animationParams) {
            this.animationParams = null; // cancel an existing animation
        }
        if (this.panVelocity) {
            this.dragFinishing = false;
            this.panVelocity = null;
        }
        /** @type {?} */
        let currentPan = {
            // the current base coordinates
            x: this.base.pan.x,
            y: this.base.pan.y
        };
        // !!!something, somewhere is potentially invalidating the base pan!!!
        /** @type {?} */
        let currentScale = this.scale;
        // get the current CSS scale (scale0)
        /** @type {?} */
        let newScale = this.scale + (wheelDelta * this.config.freeMouseWheelFactor * this.scale);
        // takes either the minimum scale (furthest allowable zoomed out) or the calculated current scale, whichever is greater, unless calculated current scale exceeds maxScale (furthest allowable zoomed in), in which case maxScale is used
        newScale = Math.max(this.minScale, Math.min(this.maxScale, newScale));
        this.scale = newScale;
        /** @type {?} */
        let targetPoint = {
            // The target point to zoom to.  It must stay the same as the untranslated point
            x: clickPoint.x - (newScale / currentScale) * (clickPoint.x - currentPan.x),
            y: clickPoint.y - (newScale / currentScale) * (clickPoint.y - currentPan.y)
        };
        // Apply Pan & Scale
        /** @type {?} */
        let translate3d = `translate3d(${targetPoint.x}px, ${targetPoint.y}px, 0)`;
        this.panElementRef.nativeElement.style.transform = translate3d;
        /** @type {?} */
        let scaleString = `scale(${this.scale})`;
        this.zoomElementRef.nativeElement.style.transformOrigin = '0 0';
        this.zoomElementRef.nativeElement.style.transform = scaleString;
        if (this.isChrome) {
            if (this.willChangeNextFrame) {
                ((/** @type {?} */ (this.acceleratedFrameRef.nativeElement.style))).willChange = 'auto';
            }
            else {
                ((/** @type {?} */ (this.acceleratedFrameRef.nativeElement.style))).willChange = 'transform';
            }
            this.willChangeNextFrame = !this.willChangeNextFrame;
        }
        this.model.pan.x = targetPoint.x;
        this.model.pan.y = targetPoint.y;
        this.model.zoomLevel = this.getZoomLevel(this.scale);
        this.syncBaseToModel();
        this.config.modelChanged.next(this.model);
        // console.log(`PanZoomComponent: freeZoom(): baseAfterZoom: x: ${this.base.pan.x} y: ${this.base.pan.y} zoomlevel: ${this.base.zoomLevel}` );
        // console.log('zoomLevel:', this.base.zoomLevel);
    }
    ////////////////////////////////////////////////////
    //////////////// HELPER FUNCTIONS //////////////////
    ////////////////////////////////////////////////////
    /**
     * @private
     * @return {?}
     */
    isMobileDevice() {
        return (typeof window.orientation !== 'undefined') || (navigator.userAgent.indexOf('IEMobile') !== -1);
    }
    /**
     * @private
     * @return {?}
     */
    syncBaseToModel() {
        this.base.pan.x = this.model.pan.x;
        this.base.pan.y = this.model.pan.y;
        this.base.zoomLevel = this.model.zoomLevel;
    }
    /**
     * @private
     * @param {?} vector2d
     * @return {?}
     */
    length(vector2d) {
        // console.log('PanZoomComponent: length()');
        return Math.sqrt(vector2d.x * vector2d.x + vector2d.y * vector2d.y);
    }
    /**
     * @private
     * @return {?}
     */
    getCenterPoint() {
        // console.log('PanZoomComponent: getCenterPoint()');
        // console.log('PanZoomComponent: getCenterPoint(): projectedContentRef:', this.projectedContentRef);
        /** @type {?} */
        let center = {
            // x: this.jQueryFrameElement.width() / 2,
            x: this.frameElementRef.nativeElement.offsetWidth / 2,
            // x: this.projectedContentRef.nativeElement.offsetWidth / 2,
            // y: this.jQueryFrameElement.height() / 2
            y: this.frameElementRef.nativeElement.offsetHeight / 2
            // y: this.projectedContentRef.nativeElement.offsetHeight / 2
        };
        return center;
    }
    /**
     * @private
     * @param {?} zoomLevel
     * @return {?}
     */
    getCssScale(zoomLevel) {
        // console.log('PanZoomComponent: getCssScale()');
        return Math.pow(this.config.scalePerZoomLevel, zoomLevel - this.config.neutralZoomLevel);
    }
    /**
     * @private
     * @param {?} cssScale
     * @return {?}
     */
    getZoomLevel(cssScale) {
        // console.log('PanZoomComponent: getZoomLevel()');
        return Math.log10(cssScale) / Math.log10(this.config.scalePerZoomLevel) + this.config.neutralZoomLevel;
    }
    /**
     * @private
     * @param {?} rect
     * @return {?}
     */
    calcZoomToFit(rect) {
        // console.log('PanZoomComponent: calcZoomToFit(): rect:', rect);
        // let (W, H) denote the size of the viewport
        // let (w, h) denote the size of the rectangle to zoom to
        // then we must CSS scale by the min of W/w and H/h in order to just fit the rectangle
        // returns the target left and top coordinates for the panElement and target zoomLevel
        // console.log('PanZoomComponent: calcZoomToFit(): rect:', rect);
        // let (W, H) denote the size of the viewport
        // let (w, h) denote the size of the rectangle to zoom to
        // then we must CSS scale by the min of W/w and H/h in order to just fit the rectangle
        // returns the target left and top coordinates for the panElement and target zoomLevel
        /** @type {?} */
        let viewportWidth = this.frameElementRef.nativeElement.offsetWidth;
        /** @type {?} */
        let viewportHeight = this.frameElementRef.nativeElement.offsetHeight;
        /** @type {?} */
        let targetWidth = rect.width;
        /** @type {?} */
        let targetHeight = rect.height;
        /** @type {?} */
        let cssScaleExact = Math.min(viewportWidth / targetWidth, viewportHeight / targetHeight);
        /** @type {?} */
        let zoomLevelExact = this.getZoomLevel(cssScaleExact);
        /** @type {?} */
        let zoomLevel = zoomLevelExact * this.config.zoomToFitZoomLevelFactor;
        /** @type {?} */
        let cssScale = this.getCssScale(zoomLevel);
        return {
            zoomLevel: zoomLevel,
            pan: {
                x: -rect.x * cssScale + (viewportWidth - targetWidth * cssScale) / 2,
                y: -rect.y * cssScale + (viewportHeight - targetHeight * cssScale) / 2
            }
        };
    }
    /**
     * @private
     * @param {?} target
     * @param {?=} duration
     * @return {?}
     */
    zoomToFitModel(target, duration = null) {
        // console.log('PanZoomComponent: zoomToFitModel(): target:', target);
        // target.pan.x is the panElement left style property
        // target.pan.y is the panElement top style property
        this.animateToTarget(target, duration);
    }
    /**
     * @private
     * @param {?} level
     * @param {?} clickPoint
     * @return {?}
     */
    zoomToLevelAndPoint(level, clickPoint) {
        // console.log('PanZoomComponent: zoomToLevelAndPoint(): level:', level);
        // console.log('PanZoomComponent: zoomToLevelAndPoint(): clickPoint:', clickPoint);
        this.changeZoomLevel(level, clickPoint);
    }
    /**
     * @private
     * @return {?}
     */
    zoomInToLastClickPoint() {
        // console.log('PanZoomComponent: zoomInToLastClickPoint(): lastClickPoint', this.lastClickPoint);
        this.changeZoomLevel(this.base.zoomLevel + this.config.zoomButtonIncrement, this.lastClickPoint);
    }
    /**
     * @private
     * @return {?}
     */
    zoomOutFromLastClickPoint() {
        // console.log('PanZoomComponent: zoomOutFromLastClickPoint()');
        this.changeZoomLevel(this.base.zoomLevel - this.config.zoomButtonIncrement, this.lastClickPoint);
    }
    /**
     * @private
     * @return {?}
     */
    startAnimation() {
        this.lastTick = performance.now();
        this.zone.runOutsideAngular((/**
         * @return {?}
         */
        () => this.animationId = this.animationFrameFunc(this.animationTick)));
    }
    ////////////////////////////////////////////////////
    /////////////////// API METHODS ////////////////////
    ////////////////////////////////////////////////////
    /**
     * @private
     * @param {?} modelPosition
     * @return {?}
     */
    getViewPosition(modelPosition) {
        // console.log('PanZoomComponent: getViewPosition()');
        // p' = p * s + t
        // viewPosition = modelPosition * scale + basePan
        // console.log('PanZoomComponent: getViewPosition()');
        // p' = p * s + t
        // viewPosition = modelPosition * scale + basePan
        /** @type {?} */
        let scale;
        /** @type {?} */
        let translation;
        if (this.animationParams) {
            scale = this.getCssScale(this.base.zoomLevel + this.animationParams.deltaZoomLevel * this.animationParams.progress);
            /** @type {?} */
            let deltaTranslation = this.animationParams.panStepFunc(this.model.zoomLevel);
            translation = { x: this.base.pan.x + deltaTranslation.x, y: this.base.pan.y + deltaTranslation.y };
        }
        else {
            scale = this.getCssScale(this.base.zoomLevel);
            translation = this.base.pan;
        }
        return {
            x: modelPosition.x * scale + translation.x,
            y: modelPosition.y * scale + translation.y
        };
    }
    /**
     * @private
     * @param {?} viewPosition
     * @return {?}
     */
    getModelPosition(viewPosition) {
        // console.log('PanZoomComponent: getModelPosition()');
        // p = (1/s)(p' - t)
        /** @type {?} */
        let pmark = viewPosition;
        /** @type {?} */
        let s = this.getCssScale(this.base.zoomLevel);
        /** @type {?} */
        let t = this.base.pan;
        return {
            x: (1 / s) * (pmark.x - t.x),
            y: (1 / s) * (pmark.y - t.y)
        };
    }
    /**
     * @private
     * @return {?}
     */
    resetView() {
        // console.log('PanZoomComponent: resetView()');
        if (this.config.initialZoomToFit) {
            this.zoomToFit(this.config.initialZoomToFit);
        }
        else if (this.config.initialPanX !== null && this.config.initialPanY !== null && this.config.initialZoomLevel !== null) {
            this.zoomToFitModel({
                zoomLevel: this.config.initialZoomLevel,
                pan: {
                    x: this.config.initialPanX,
                    y: this.config.initialPanY
                }
            });
        }
        else {
            console.error('PanZoomComponent: resetView() could not reset view as some vars were not set.  The culprits are either config.initialZoomLevel, config.initialPanX, or config.initialPanY.  Or just set panzoomConfig.initialZoomToFit');
            console.log('config.initialZoomLevel: ' + this.config.initialZoomLevel);
            console.log('config.initialPanX: ' + this.config.initialPanX);
            console.log('config.initialPanY: ' + this.config.initialPanY);
        }
    }
    /**
     * @private
     * @param {?} rectangle
     * @param {?=} duration
     * @return {?}
     */
    zoomToFit(rectangle, duration = null) {
        // console.log('PanZoomComponent: zoomToFit(): rectangle', rectangle);
        // console.log('PanZoomComponent: zoomToFit(): rectangle', rectangle);
        // when a user clicks a zoom to fit button
        // example rectangle: { "x": 0, "y": 100, "width": 100, "height": 100 }
        /** @type {?} */
        let target = this.calcZoomToFit(rectangle);
        // target.pan.x is the panElement left style property
        // target.pan.y is the panElement top style property
        this.animateToTarget(target, duration);
    }
    /**
     * @private
     * @param {?} clickPoint
     * @return {?}
     */
    zoomIn(clickPoint) {
        // console.log('PanZoomComponent: zoomIn(): clickPoint:', clickPoint);
        this.changeZoomLevel(this.base.zoomLevel + this.config.zoomButtonIncrement, clickPoint);
    }
    /**
     * @private
     * @param {?} clickPoint
     * @return {?}
     */
    zoomOut(clickPoint) {
        // console.log('PanZoomComponent: zoomOut()');
        this.changeZoomLevel(this.base.zoomLevel - this.config.zoomButtonIncrement, clickPoint);
    }
    /**
     * @private
     * @param {?} point
     * @param {?=} duration
     * @return {?}
     */
    panToPoint(point, duration = null) {
        // console.log('PanZoomComponent: panToPoint(): point:', point);
        // console.log('PanZoomComponent: panToPoint(): point:', point);
        // API call to animate the view so that the centre point of the view is at the
        // point parameter coordinates, relative to the original, unzoomed
        // content width and height
        // example point: { "x": 0, "y": 0 } // makes the top-left corner of the content
        // the centre of the view
        /** @type {?} */
        let target = {
            pan: {
                x: ((this.frameWidth / 2)) - point.x * this.scale,
                y: ((this.frameHeight / 2)) - point.y * this.scale
            },
            zoomLevel: this.base.zoomLevel
        };
        this.animateToTarget(target, duration);
    }
    /**
     * @private
     * @param {?} delta
     * @param {?=} duration
     * @return {?}
     */
    panDelta(delta, duration = null) {
        // console.log('PanZoomComponent: panDelta(): delta:', delta);
        // console.log('PanZoomComponent: panDelta(): delta:', delta);
        // API call to pan the view left, right, up, or down, based on a number of pixels
        // of the original, unzoomed content.
        // Positive is right and down
        // Negative is left and up
        // example point: { "x": 100, "y": -50 } // moves the view right 50px and up 50px
        /** @type {?} */
        let target = {
            pan: {
                x: this.base.pan.x - this.scale * delta.x,
                y: this.base.pan.y - this.scale * delta.y
            },
            zoomLevel: this.base.zoomLevel
        };
        this.animateToTarget(target, duration);
    }
    /**
     * @private
     * @param {?} delta
     * @param {?=} duration
     * @return {?}
     */
    panDeltaAbsolute(delta, duration = null) {
        // console.log('PanZoomComponent: panDeltaAbsolute(): delta:', delta);
        // console.log('PanZoomComponent: panDeltaAbsolute(): delta:', delta);
        // API call to pan the view left, right, up, or down, based on a number of pixels
        // This method doesn't adjust for scale.  I'm not sure why you'd want this
        // but have it here just in case someone needs it
        // Positive is right and down
        // Negative is left and up
        // example point: { "x": 100, "y": -50 } // moves the view right 50px and up 50px
        /** @type {?} */
        let target = {
            pan: {
                x: this.base.pan.x - delta.x,
                y: this.base.pan.y - delta.y
            },
            zoomLevel: this.base.zoomLevel
        };
        this.animateToTarget(target, duration);
    }
    /**
     * @private
     * @param {?} deltaPercent
     * @param {?=} duration
     * @return {?}
     */
    panDeltaPercent(deltaPercent, duration = null) {
        // console.log('PanZoomComponent: panDeltaPercent(): deltaPercent:', deltaPercent);
        // console.log('PanZoomComponent: panDeltaPercent(): deltaPercent:', deltaPercent);
        // API call to pan the view up, down, left, or right, based on a percentage
        // of the original, unzoomed content width and height
        // example point: { "x": 10, "y": -20 }
        /** @type {?} */
        let deltaX = 0;
        /** @type {?} */
        let deltaY = 0;
        if (deltaPercent.x !== 0) {
            deltaX = this.contentWidth * (deltaPercent.x / 100) * this.scale;
        }
        if (deltaPercent.y !== 0) {
            deltaY = this.contentHeight * (deltaPercent.y / 100) * this.scale;
        }
        /** @type {?} */
        let target = {
            pan: {
                x: this.base.pan.x - deltaX,
                y: this.base.pan.y - deltaY
            },
            zoomLevel: this.base.zoomLevel
        };
        // target.pan.x is the panElement left style property
        // target.pan.y is the panElement top style property
        this.animateToTarget(target, duration);
    }
    ////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////// ANIMATION BUILDERS ///////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////
    /**
     * @private
     * @param {?} targetModel
     * @param {?=} duration
     * @return {?}
     */
    animateToTarget(targetModel, duration = null) {
        // console.log('PanZoomComponent: animateToTarget()');
        // what this function really does is take a target model, and then sets
        // this.animationParams with the parameters for the whole animation,
        // namely the delta zoomLevel
        // it is the responsibility of the caller to kick off the animation with a call to animationFrameFunc()
        if (this.animationParams) {
            // make the user wait for existing animation to finish before clicking
            return;
        }
        this.zoomLevelIsChanging = false;
        if (this.base.zoomLevel !== targetModel.zoomLevel) {
            this.zoomLevelIsChanging = true;
        }
        /** @type {?} */
        let deltaZoomLevel = targetModel.zoomLevel - this.base.zoomLevel;
        // deltaZoomLevel is the number of zoom levels we are changing here
        /** @type {?} */
        let oldBase = {
            // the current base coordinates
            x: this.base.pan.x,
            y: this.base.pan.y
        };
        this.model.pan.x = this.base.pan.x;
        this.model.pan.y = this.base.pan.y;
        /*this.lastClickPoint = {
              x: this.base.pan.x,
              y: this.base.pan.y
            };*/
        /** @type {?} */
        let panStepFunc = (/**
         * @param {?} zoomLevel
         * @return {?}
         */
        (zoomLevel) => {
            // this function gets called during every animation tick in updateDOM(), to calculate where to move the model pan coordinates to (i.e. the translation) for that tick, zoomLevel is ignored within animateToTarget()
            /** @type {?} */
            let targetPoint = {
                // The target point to zoom to for the current animation frame.  It must stay the same as the untranslated point
                x: (oldBase.x - targetModel.pan.x) * this.animationParams.progress,
                y: (oldBase.y - targetModel.pan.y) * this.animationParams.progress
            };
            return { x: -targetPoint.x, y: -targetPoint.y };
        });
        // now set the parameters of our new animation
        if (duration) {
            duration = duration * 1000;
        }
        else {
            duration = this.config.zoomStepDuration * 1000;
        }
        this.animationParams = {
            deltaZoomLevel: deltaZoomLevel,
            // how many zooom levels to zoom in or out
            panStepFunc: panStepFunc,
            // a function which runs on every animation tick, which calcs how much to pan the view on every frame
            // duration: duration || this.config.zoomStepDuration, // how long the animation should take
            duration: duration,
            // how long the animation should take
            progress: 0.0
        };
        this.startAnimation();
    }
    /**
     * @private
     * @param {?} newZoomLevel
     * @param {?} clickPoint
     * @return {?}
     */
    changeZoomLevel(newZoomLevel, clickPoint) {
        // console.log('PanZoomComponent: changeZoomLevel()');
        if (this.animationParams) {
            // let's let any current animation just finish
            return;
        }
        this.zoomLevelIsChanging = true;
        // keep zoom level in bounds
        newZoomLevel = Math.max(this.minimumAllowedZoomLevel, newZoomLevel);
        newZoomLevel = Math.min(this.config.zoomLevels - 1, newZoomLevel);
        // console.log('newZoomLevel:', newZoomLevel);
        /** @type {?} */
        let deltaZoomLevel = newZoomLevel - this.base.zoomLevel;
        if (!deltaZoomLevel) {
            // a deltaZoomLevel of zero means that we aren't changing zoom, because we're either zoomed all the way in or all the way out
            return;
        }
        //
        // Let p be the vector to the clicked point in view coords and let p' be the same point in model coords. Let s be a scale factor
        // and let t be a translation vector. Let the transformation be defined as:
        //
        //  p' = p * s + t
        //
        // And conversely:
        //
        //  p = (1/s)(p' - t)
        //
        // Now use subscription 0 to denote the value before transform and zoom and let 1 denote the value after transform. Scale
        // changes from s0 to s1. Translation changes from t0 to t1. But keep p and p' fixed so that the view coordinate p' still
        // corresponds to the model coordinate p. This can be expressed as an equation relying upon solely upon p', s0, s1, t0, and t1:
        //
        //  (1/s0)(p - t0) = (1/s1)(p - t1)
        //
        // Every variable but t1 is known, thus it is easily isolated to:
        //
        //  t1 = p' - (s1/s0)*(p' - t0)
        //
        /** @type {?} */
        let currentPan = {
            // t0 - the current base coordinates
            x: this.base.pan.x,
            y: this.base.pan.y
        };
        /** @type {?} */
        let currentScale = this.scale;
        // s0 - get the current CSS scale (scale0)
        /** @type {?} */
        let destPoint = clickPoint || this.getCenterPoint();
        // pmark - the point we are aiming to zoom to (either the click point or the centre of the page)
        /** @type {?} */
        let panStepFunc = (/**
         * @param {?} zoomLevel
         * @return {?}
         */
        (zoomLevel) => {
            // this function gets called during every animation tick, to calculate where to move the model pan coordinates to (i.e. the translation) for that tick, where zoomLevel is calculated from the current zoomLevel + the target zoomLevel * the progress of the current animation
            // this function gets called during every animation tick, to calculate where to move the model pan coordinates to (i.e. the translation) for that tick, where zoomLevel is calculated from the current zoomLevel + the target zoomLevel * the progress of the current animation
            /** @type {?} */
            let targetScale = this.getCssScale(zoomLevel);
            // s1 - the scale to translate to for the current animation tick
            /** @type {?} */
            let targetPoint = {
                // t1 - The target point to pan to.  It must stay the same as the untranslated point
                x: destPoint.x - (targetScale / currentScale) * (destPoint.x - currentPan.x),
                y: destPoint.y - (targetScale / currentScale) * (destPoint.y - currentPan.y)
            };
            return {
                // now return the difference between our initial click point and our translated (zoomed) click point
                // these are not absolute coordinates - just how far to move them
                x: targetPoint.x - currentPan.x,
                y: targetPoint.y - currentPan.y
            };
        });
        // now set the parameters of our new animation
        this.animationParams = {
            deltaZoomLevel: deltaZoomLevel,
            // the destination zoom level for this zoom operation (when the animation is completed)
            panStepFunc: panStepFunc,
            // duration: this.config.zoomStepDuration, // how long the animation should take
            duration: this.config.zoomStepDuration * 1000,
            // how long the animation should take
            progress: 0.0
        };
        this.startAnimation();
    }
}
PanZoomComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'pan-zoom',
                // we don't want to kill change detection for all elements beneath this, so we don't set OnPush.  Child views can implement OnPush if the developer wants to.  We can get away with this because the kwheel directive runs outside of Angular, so it doesnt trigger change detection.
                template: `
<div #frameElement class="pan-zoom-frame" style="position:relative; width: 100%; height: 100%; overflow: hidden;">
  <div #panElement class="panElement" style="position: absolute; left: 0px; top: 0px;">
    <div #zoomElement class="zoomElement">
      <ng-content></ng-content>
    </div>
  </div>
</div>
<div #panzoomOverlay style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; opacity: 0; display: none; pointer-events: none;"></div>
  `
            }] }
];
/** @nocollapse */
PanZoomComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
PanZoomComponent.propDecorators = {
    frameElementRef: [{ type: ViewChild, args: ['frameElement', { static: true },] }],
    panElementRef: [{ type: ViewChild, args: ['panElement', { static: true },] }],
    zoomElementRef: [{ type: ViewChild, args: ['zoomElement', { static: true },] }],
    panzoomOverlayRef: [{ type: ViewChild, args: ['panzoomOverlay', { static: true },] }],
    config: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.frameElementRef;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.panElementRef;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.zoomElementRef;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.panzoomOverlayRef;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.config;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.base;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.model;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.api;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.contentHeight;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.contentWidth;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.frameHeight;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.frameWidth;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.lastMouseEventTime;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.previousPosition;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.isDragging;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.panVelocity;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.animationParams;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.jQueryFrameElement;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.animationFrameFunc;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.lastTick;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.isChrome;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.willChangeNextFrame;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.animationId;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.isMobile;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.scale;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.isFirstSync;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.lastClickPoint;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.acceleratedFrameRef;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.zoomLevelIsChanging;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.dragFinishing;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.dragMouseButton;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.maxScale;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.minScale;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.minimumAllowedZoomLevel;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.onMouseWheel;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.onMousedown;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.onTouchStart;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.onMouseMove;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.onTouchMove;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.onMouseUp;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.onTouchEnd;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.onDblClick;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.preventDefault;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.animationTick;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.el;
    /**
     * @type {?}
     * @private
     */
    PanZoomComponent.prototype.zone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFuem9vbS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZzItcGFuem9vbS8iLCJzb3VyY2VzIjpbImxpYi9wYW56b29tLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBb0MsVUFBVSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2xILE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQzs7OztBQW1CakQsNEJBS0M7OztJQUpDLHVDQUF1Qjs7SUFDdkIsb0NBQXNCOztJQUN0QixpQ0FBaUI7O0lBQ2pCLGlDQUFpQjs7Ozs7QUFHbkIsdUJBSUM7OztJQUhDLHFCQUFXOztJQUNYLHFCQUFXOztJQUNYLDBCQUFnQjs7QUFtQmxCLE1BQU0sT0FBTyxnQkFBZ0I7Ozs7O0lBRTNCLFlBQXNCLEVBQWMsRUFDZCxJQUFZO1FBRFosT0FBRSxHQUFGLEVBQUUsQ0FBWTtRQUNkLFNBQUksR0FBSixJQUFJLENBQVE7UUFpQjFCLHFCQUFnQixHQUFhLElBQUksQ0FBQztRQUNsQyxlQUFVLEdBQUcsS0FBSyxDQUFDO1FBQ25CLGdCQUFXLEdBQVUsSUFBSSxDQUFDO1FBQzFCLG9CQUFlLEdBQWtCLElBQUksQ0FBQzs7UUFHdEMsYUFBUSxHQUFHLENBQUMsQ0FBQztRQUNiLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFDakIsd0JBQW1CLEdBQUcsSUFBSSxDQUFDLENBQUMsNkJBQTZCO1FBRXpELGFBQVEsR0FBRyxLQUFLLENBQUM7UUFFakIsZ0JBQVcsR0FBRyxJQUFJLENBQUM7UUFHbkIsd0JBQW1CLEdBQUcsS0FBSyxDQUFDO1FBQzVCLGtCQUFhLEdBQUcsS0FBSyxDQUFDO1FBQ3RCLG9CQUFlLEdBQVcsSUFBSSxDQUFDOzs7OztRQTBLL0IsaUJBQVk7Ozs7UUFBRyxDQUFDLEtBQWlCLEVBQUUsRUFBRTtZQUMzQyxpRUFBaUU7WUFFakUs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Qjs7Ozs7SUFDckIsb0NBQXlCOzs7OztJQUN6QiwrQ0FBbUM7Ozs7O0lBQ25DLHVDQUE0Qjs7Ozs7SUFDNUIsb0NBQXlCOzs7OztJQUN6QixpQ0FBc0I7Ozs7O0lBQ3RCLHVDQUEyQjs7Ozs7SUFDM0IsMENBQThCOzs7OztJQUM5QiwrQ0FBaUM7Ozs7O0lBQ2pDLCtDQUFvQzs7Ozs7SUFDcEMseUNBQThCOzs7OztJQUM5QiwyQ0FBdUM7Ozs7O0lBRXZDLG9DQUF5Qjs7Ozs7SUFDekIsb0NBQXlCOzs7OztJQUN6QixtREFBd0M7Ozs7O0lBc0t4Qyx3Q0E4Q0M7Ozs7O0lBdUJELHVDQXNDQzs7Ozs7SUFJRCx3Q0FzQkM7Ozs7O0lBSUQsdUNBc0ZDOzs7OztJQUlELHVDQWtEQzs7Ozs7SUFJRCxxQ0E4Q0M7Ozs7O0lBSUQsc0NBR0M7Ozs7O0lBSUQsc0NBY0M7Ozs7O0lBSUQsMENBRUM7Ozs7O0lBd0JELHlDQThHQzs7Ozs7SUF6ckJhLDhCQUFzQjs7Ozs7SUFDdEIsZ0NBQW9CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSwgRWxlbWVudFJlZiwgVmlld0NoaWxkLCBJbnB1dCwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBQYW5ab29tQ29uZmlnIH0gZnJvbSAnLi9wYW56b29tLWNvbmZpZyc7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4vcGFuem9vbS1wb2ludCc7XG5pbXBvcnQgeyBQYW5ab29tTW9kZWwgfSBmcm9tICcuL3Bhbnpvb20tbW9kZWwnO1xuaW1wb3J0IHsgUGFuWm9vbUFQSSB9IGZyb20gJy4vcGFuem9vbS1hcGknO1xuaW1wb3J0IHsgUmVjdCB9IGZyb20gJy4vcGFuem9vbS1yZWN0JztcbmRlY2xhcmUgdmFyICQ6IGFueTtcblxuLypcbnZhciBvbGRBZGRFdmVudExpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnROYW1lLCBldmVudEhhbmRsZXI6IGFueSwgb3B0aW9uczogYW55ID0gbnVsbClcbntcbiAgY29uc29sZS5sb2coJ2V2ZW50TmFtZTonLCBldmVudE5hbWUpO1xuICBvbGRBZGRFdmVudExpc3RlbmVyLmNhbGwodGhpcywgZXZlbnROYW1lLCBmdW5jdGlvbihldmVudCkge1xuICAgIGV2ZW50SGFuZGxlcihldmVudCk7XG4gIH0sIG9wdGlvbnMpO1xufTtcbiovXG5cbmludGVyZmFjZSBab29tQW5pbWF0aW9uIHtcbiAgZGVsdGFab29tTGV2ZWw6IG51bWJlcjtcbiAgcGFuU3RlcEZ1bmM6IEZ1bmN0aW9uO1xuICBkdXJhdGlvbjogbnVtYmVyO1xuICBwcm9ncmVzczogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgUG9zaXRpb24ge1xuICB4PzogbnVtYmVyO1xuICB5PzogbnVtYmVyO1xuICBsZW5ndGg/OiBudW1iZXI7XG59XG5cbkBDb21wb25lbnQoIHtcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmNvbXBvbmVudC1zZWxlY3RvclxuICBzZWxlY3RvcjogJ3Bhbi16b29tJyxcbiAgLy8gd2UgZG9uJ3Qgd2FudCB0byBraWxsIGNoYW5nZSBkZXRlY3Rpb24gZm9yIGFsbCBlbGVtZW50cyBiZW5lYXRoIHRoaXMsIHNvIHdlIGRvbid0IHNldCBPblB1c2guICBDaGlsZCB2aWV3cyBjYW4gaW1wbGVtZW50IE9uUHVzaCBpZiB0aGUgZGV2ZWxvcGVyIHdhbnRzIHRvLiAgV2UgY2FuIGdldCBhd2F5IHdpdGggdGhpcyBiZWNhdXNlIHRoZSBrd2hlZWwgZGlyZWN0aXZlIHJ1bnMgb3V0c2lkZSBvZiBBbmd1bGFyLCBzbyBpdCBkb2VzbnQgdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uLlxuICB0ZW1wbGF0ZTogYFxuPGRpdiAjZnJhbWVFbGVtZW50IGNsYXNzPVwicGFuLXpvb20tZnJhbWVcIiBzdHlsZT1cInBvc2l0aW9uOnJlbGF0aXZlOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyBvdmVyZmxvdzogaGlkZGVuO1wiPlxuICA8ZGl2ICNwYW5FbGVtZW50IGNsYXNzPVwicGFuRWxlbWVudFwiIHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAwcHg7IHRvcDogMHB4O1wiPlxuICAgIDxkaXYgI3pvb21FbGVtZW50IGNsYXNzPVwiem9vbUVsZW1lbnRcIj5cbiAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L2Rpdj5cbjxkaXYgI3Bhbnpvb21PdmVybGF5IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IHJpZ2h0OiAwOyBib3R0b206IDA7IG9wYWNpdHk6IDA7IGRpc3BsYXk6IG5vbmU7IHBvaW50ZXItZXZlbnRzOiBub25lO1wiPjwvZGl2PlxuICBgXG59IClcblxuZXhwb3J0IGNsYXNzIFBhblpvb21Db21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG5cbiAgY29uc3RydWN0b3IgKCBwcml2YXRlIGVsOiBFbGVtZW50UmVmLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgem9uZTogTmdab25lICkge31cblxuICBAVmlld0NoaWxkKCdmcmFtZUVsZW1lbnQnLCB7IHN0YXRpYzogdHJ1ZSB9KSBwcml2YXRlIGZyYW1lRWxlbWVudFJlZjogRWxlbWVudFJlZjtcbiAgQFZpZXdDaGlsZCgncGFuRWxlbWVudCcsIHsgc3RhdGljOiB0cnVlIH0pIHByaXZhdGUgcGFuRWxlbWVudFJlZjogRWxlbWVudFJlZjtcbiAgQFZpZXdDaGlsZCgnem9vbUVsZW1lbnQnLCB7IHN0YXRpYzogdHJ1ZSB9KSBwcml2YXRlIHpvb21FbGVtZW50UmVmOiBFbGVtZW50UmVmO1xuICBAVmlld0NoaWxkKCdwYW56b29tT3ZlcmxheScsIHsgc3RhdGljOiB0cnVlIH0pIHByaXZhdGUgcGFuem9vbU92ZXJsYXlSZWY6IEVsZW1lbnRSZWY7XG5cbiAgQElucHV0KCkgcHJpdmF0ZSBjb25maWc6IFBhblpvb21Db25maWc7XG5cbiAgcHJpdmF0ZSBiYXNlOiBQYW5ab29tTW9kZWw7IC8vIHRoaXMgaXMgd2hhdCB0aGUgcGFuL3pvb20gdmlldyBpcyBiZWZvcmUgYSB6b29tIGFuaW1hdGlvbiBiZWdpbnMgYW5kIGFmdGVyIGl0IGVuZHMuICBJdCBhbHNvIHVwZGF0ZXMgd2l0aCBldmVyeSBtb3VzZSBkcmFnIG9yIGZyZWVab29tXG4gIHByaXZhdGUgbW9kZWw6IFBhblpvb21Nb2RlbDsgLy8gdGhpcyBpcyB1c2VkIGZvciBpbmNyZW1lbnRhbCBjaGFuZ2VzIHRvIHRoZSBwYW4vem9vbSB2aWV3IGR1cmluZyBlYWNoIGFuaW1hdGlvbiBmcmFtZS4gIFNldHRpbmcgaXQgd2lsbCB1cGRhdGUgdGhlIHBhbi96b29tIGNvb3JkaW5hdGVzIG9uIHRoZSBuZXh0IGNhbGwgdG8gdXBkYXRlRE9NKCkuICBOb3QgdXNlZCBkdXJpbmcgbW91c2UgZHJhZyBvciBmcmVlWm9vbVxuICBwcml2YXRlIGFwaTogUGFuWm9vbUFQSTtcbiAgcHJpdmF0ZSBjb250ZW50SGVpZ2h0OiBudW1iZXI7XG4gIHByaXZhdGUgY29udGVudFdpZHRoOiBudW1iZXI7XG4gIHByaXZhdGUgZnJhbWVIZWlnaHQ6IG51bWJlcjtcbiAgcHJpdmF0ZSBmcmFtZVdpZHRoOiBudW1iZXI7XG4gIHByaXZhdGUgbGFzdE1vdXNlRXZlbnRUaW1lOiBudW1iZXI7XG4gIHByaXZhdGUgcHJldmlvdXNQb3NpdGlvbjogUG9zaXRpb24gPSBudWxsO1xuICBwcml2YXRlIGlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBwYW5WZWxvY2l0eTogUG9pbnQgPSBudWxsO1xuICBwcml2YXRlIGFuaW1hdGlvblBhcmFtczogWm9vbUFuaW1hdGlvbiA9IG51bGw7XG4gIHByaXZhdGUgalF1ZXJ5RnJhbWVFbGVtZW50OiBKUXVlcnk7XG4gIHByaXZhdGUgYW5pbWF0aW9uRnJhbWVGdW5jOiBGdW5jdGlvbjsgLy8gcmVmZXJlbmNlIHRvIHRoZSBhcHByb3ByaWF0ZSBnZXRBbmltYXRpb25GcmFtZSBmdW5jdGlvbiBmb3IgdGhlIGNsaWVudCBicm93c2VyXG4gIHByaXZhdGUgbGFzdFRpY2sgPSAwO1xuICBwcml2YXRlIGlzQ2hyb21lID0gZmFsc2U7XG4gIHByaXZhdGUgd2lsbENoYW5nZU5leHRGcmFtZSA9IHRydWU7IC8vIHVzZWQgZm9yIHNjYWxpbmcgaW4gQ2hyb21lXG4gIHByaXZhdGUgYW5pbWF0aW9uSWQ6IG51bWJlcjtcbiAgcHJpdmF0ZSBpc01vYmlsZSA9IGZhbHNlO1xuICBwcml2YXRlIHNjYWxlOiBudW1iZXI7XG4gIHByaXZhdGUgaXNGaXJzdFN5bmMgPSB0cnVlO1xuICBwcml2YXRlIGxhc3RDbGlja1BvaW50OiBQb2ludDtcbiAgcHJpdmF0ZSBhY2NlbGVyYXRlZEZyYW1lUmVmOiBhbnk7XG4gIHByaXZhdGUgem9vbUxldmVsSXNDaGFuZ2luZyA9IGZhbHNlO1xuICBwcml2YXRlIGRyYWdGaW5pc2hpbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBkcmFnTW91c2VCdXR0b246IG51bWJlciA9IG51bGw7XG5cbiAgcHJpdmF0ZSBtYXhTY2FsZTogbnVtYmVyOyAvLyB0aGUgaGlnaGVzdCBzY2FsZSAoZnVydGhlc3Qgem9vbWVkIGluKSB0aGF0IHdlIHdpbGwgYWxsb3cgaW4gZnJlZSB6b29tIG1vZGUgKGNhbGN1bGF0ZWQpXG4gIHByaXZhdGUgbWluU2NhbGU6IG51bWJlcjsgLy8gdGhlIHNtYWxsZXN0IHNjYWxlIChmdXJ0aGVzdCB6b29tZWQgb3V0KSB0aGF0IHdlIHdpbGwgYWxsb3cgaW4gZnJlZSB6b29tIG1vZGUgKGNhbGN1bGF0ZWQpXG4gIHByaXZhdGUgbWluaW11bUFsbG93ZWRab29tTGV2ZWw6IG51bWJlcjtcblxuXG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IG5nT25Jbml0KCk6IGluaXRpYWxpemluZyBQYW5ab29tQ29tcG9uZW50Jyk7XG5cbiAgICBpZiAodGhpcy5jb25maWcuaW5pdGlhbFpvb21Ub0ZpdCkge1xuICAgICAgdGhpcy5iYXNlID0gdGhpcy5jYWxjWm9vbVRvRml0KHRoaXMuY29uZmlnLmluaXRpYWxab29tVG9GaXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuYmFzZSA9IHtcbiAgICAgICAgem9vbUxldmVsOiB0aGlzLmNvbmZpZy5pbml0aWFsWm9vbUxldmVsLFxuICAgICAgICBwYW46IHtcbiAgICAgICAgICB4OiB0aGlzLmNvbmZpZy5pbml0aWFsUGFuWCxcbiAgICAgICAgICB5OiB0aGlzLmNvbmZpZy5pbml0aWFsUGFuWVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMubW9kZWwgPSB7XG4gICAgICB6b29tTGV2ZWw6IHRoaXMuYmFzZS56b29tTGV2ZWwsXG4gICAgICBpc1Bhbm5pbmc6IGZhbHNlLCAvLyBPbmx5IHRydWUgaWYgcGFubmluZyBpcyBhY3R1YWxseSB0YWtpbmcgcGxhY2UsIG5vdCBqdXN0IGFmdGVyIG1vdXNlZG93blxuICAgICAgcGFuOiB7XG4gICAgICAgIHg6IHRoaXMuYmFzZS5wYW4ueCxcbiAgICAgICAgeTogdGhpcy5iYXNlLnBhbi55XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuY29uZmlnLm1vZGVsQ2hhbmdlZC5uZXh0KHRoaXMubW9kZWwpO1xuXG4gICAgLy8gY3JlYXRlIHB1YmxpYyBBUElcbiAgICB0aGlzLmFwaSA9IHtcbiAgICAgIG1vZGVsOiB0aGlzLm1vZGVsLFxuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgIGNoYW5nZVpvb21MZXZlbDogdGhpcy56b29tVG9MZXZlbEFuZFBvaW50LmJpbmQodGhpcyksXG4gICAgICB6b29tSW46IHRoaXMuem9vbUluVG9MYXN0Q2xpY2tQb2ludC5iaW5kKHRoaXMpLFxuICAgICAgem9vbU91dDogdGhpcy56b29tT3V0RnJvbUxhc3RDbGlja1BvaW50LmJpbmQodGhpcyksXG4gICAgICB6b29tVG9GaXQ6IHRoaXMuem9vbVRvRml0LmJpbmQodGhpcyksXG4gICAgICByZXNldFZpZXc6IHRoaXMucmVzZXRWaWV3LmJpbmQodGhpcyksXG4gICAgICBnZXRWaWV3UG9zaXRpb246IHRoaXMuZ2V0Vmlld1Bvc2l0aW9uLmJpbmQodGhpcyksXG4gICAgICBnZXRNb2RlbFBvc2l0aW9uOiB0aGlzLmdldE1vZGVsUG9zaXRpb24uYmluZCh0aGlzKSxcbiAgICAgIHBhblRvUG9pbnQ6IHRoaXMucGFuVG9Qb2ludC5iaW5kKHRoaXMpLFxuICAgICAgcGFuRGVsdGE6IHRoaXMucGFuRGVsdGEuYmluZCh0aGlzKSxcbiAgICAgIHBhbkRlbHRhUGVyY2VudDogdGhpcy5wYW5EZWx0YVBlcmNlbnQuYmluZCh0aGlzKSxcbiAgICAgIHBhbkRlbHRhQWJzb2x1dGU6IHRoaXMucGFuRGVsdGFBYnNvbHV0ZS5iaW5kKHRoaXMpXG4gICAgfTtcblxuICAgIHRoaXMuY29uZmlnLmFwaS5uZXh0KHRoaXMuYXBpKTtcblxuICAgIGlmICh0aGlzLmNvbmZpZy5mcmVlTW91c2VXaGVlbCkge1xuICAgICAgdGhpcy5zY2FsZSA9IHRoaXMuZ2V0Q3NzU2NhbGUodGhpcy5jb25maWcuaW5pdGlhbFpvb21MZXZlbCk7XG4gICAgICBsZXQgbWF4Wm9vbUxldmVsID0gdGhpcy5jb25maWcuem9vbUxldmVscyAtIDE7XG4gICAgICB0aGlzLm1heFNjYWxlID0gdGhpcy5nZXRDc3NTY2FsZShtYXhab29tTGV2ZWwpO1xuICAgICAgdGhpcy5taW5TY2FsZSA9IHRoaXMuZ2V0Q3NzU2NhbGUoMCk7XG4gICAgfVxuXG4gICAgdGhpcy5taW5pbXVtQWxsb3dlZFpvb21MZXZlbCA9IDA7XG4gICAgaWYgKHRoaXMuY29uZmlnLmtlZXBJbkJvdW5kcykge1xuICAgICAgdGhpcy5taW5pbXVtQWxsb3dlZFpvb21MZXZlbCA9IHRoaXMuY29uZmlnLm5ldXRyYWxab29tTGV2ZWw7XG4gICAgICB0aGlzLm1pblNjYWxlID0gdGhpcy5nZXRDc3NTY2FsZSh0aGlzLmNvbmZpZy5uZXV0cmFsWm9vbUxldmVsKTtcbiAgICB9XG5cbiAgICB0aGlzLmFjY2VsZXJhdGVkRnJhbWVSZWYgPSB0aGlzLnpvb21FbGVtZW50UmVmO1xuICAgIC8vIGNvbnNvbGUubG9nKCdmcmFtZUhlaWdodDonLCB0aGlzLmZyYW1lSGVpZ2h0KTtcbiAgICAvLyBjb25zb2xlLmxvZygnZnJhbWVXaWR0aDonLCB0aGlzLmZyYW1lV2lkdGgpO1xuXG4gICAgKDxhbnk+dGhpcy5hY2NlbGVyYXRlZEZyYW1lUmVmLm5hdGl2ZUVsZW1lbnQuc3R5bGUpLndpbGxDaGFuZ2UgPSAndHJhbnNmb3JtJztcbiAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5zZWFyY2goJ0Nocm9tZScpID49IDApIHtcbiAgICAgIHRoaXMuaXNDaHJvbWUgPSB0cnVlO1xuICAgICAgdGhpcy5hY2NlbGVyYXRlZEZyYW1lUmVmLm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVooMCknO1xuICAgIH1cblxuICAgIHRoaXMuYW5pbWF0aW9uVGljayhwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgdGhpcy5zY2FsZSA9IHRoaXMuZ2V0Q3NzU2NhbGUodGhpcy5iYXNlLnpvb21MZXZlbCk7XG4gICAgdGhpcy5pc0ZpcnN0U3luYyA9IGZhbHNlO1xuICAgIHN3aXRjaCAodGhpcy5jb25maWcuZHJhZ01vdXNlQnV0dG9uKSB7XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgdGhpcy5kcmFnTW91c2VCdXR0b24gPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgIHRoaXMuZHJhZ01vdXNlQnV0dG9uID0gMTtcbiAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCAoKSA9PiB0aGlzLmZyYW1lRWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2F1eGNsaWNrJywgdGhpcy5wcmV2ZW50RGVmYXVsdCApICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoICgpID0+IGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcy5wcmV2ZW50RGVmYXVsdCApICk7XG4gICAgICAgIHRoaXMuZHJhZ01vdXNlQnV0dG9uID0gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmRyYWdNb3VzZUJ1dHRvbiA9IDA7IC8vIGxlZnRcbiAgICB9XG5cblxuICB9XG5cblxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogbmdBZnRlclZpZXdJbml0KCknKTtcblxuICAgIHRoaXMualF1ZXJ5RnJhbWVFbGVtZW50ID0gJCgnLnBhbi16b29tLWZyYW1lJyk7XG4gICAgdGhpcy5jb250ZW50SGVpZ2h0ID0gJCgnLnpvb21FbGVtZW50JykuY2hpbGRyZW4oKS5oZWlnaHQoKTtcbiAgICB0aGlzLmNvbnRlbnRXaWR0aCA9ICQoJy56b29tRWxlbWVudCcpLmNoaWxkcmVuKCkud2lkdGgoKTtcbiAgICB0aGlzLmZyYW1lSGVpZ2h0ID0gdGhpcy5qUXVlcnlGcmFtZUVsZW1lbnQuaGVpZ2h0KCk7XG4gICAgdGhpcy5mcmFtZVdpZHRoID0gdGhpcy5qUXVlcnlGcmFtZUVsZW1lbnQud2lkdGgoKTtcblxuICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhciggKCkgPT4gdGhpcy5hbmltYXRpb25GcmFtZUZ1bmMgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICk7XG4gICAgLy8gdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCAoKSA9PiB0aGlzLndoZWVsQW5pbWF0aW9uRnJhbWVGdW5jID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApO1xuXG5cbiAgICBpZiAodGhpcy5pc01vYmlsZURldmljZSgpKcKge1xuICAgICAgdGhpcy5pc01vYmlsZSA9IHRydWU7XG4gICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoICgpID0+IHRoaXMuZnJhbWVFbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Ub3VjaFN0YXJ0ICkgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoICgpID0+IHRoaXMuZnJhbWVFbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlZG93biApICk7XG4gICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoICgpID0+IHRoaXMuZnJhbWVFbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCB0aGlzLm9uRGJsQ2xpY2sgKSApO1xuICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCAoKSA9PiB0aGlzLmZyYW1lRWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgKGV2ZW50KSA9PiB0aGlzLmFuaW1hdGlvbkZyYW1lRnVuYyggKCkgPT4gdGhpcy5vbk1vdXNlV2hlZWwoZXZlbnQpICksIHsgcGFzc2l2ZTogdHJ1ZSB9ICkgKTtcbiAgICB9XG5cbiAgfVxuXG5cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogbmdPbkRlc3Ryb3koKScpO1xuICAgIGlmICh0aGlzLmlzTW9iaWxlKSB7XG4gICAgICB0aGlzLmZyYW1lRWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uVG91Y2hTdGFydCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5mcmFtZUVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2Vkb3duKTtcbiAgICAgIHRoaXMuZnJhbWVFbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCAoZXZlbnQpID0+IHRoaXMuYW5pbWF0aW9uRnJhbWVGdW5jKCAoKSA9PiB0aGlzLm9uTW91c2VXaGVlbChldmVudCkgKSwgeyBwYXNzaXZlOiB0cnVlIH0gKTtcbiAgICAgIHRoaXMuZnJhbWVFbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCB0aGlzLm9uRGJsQ2xpY2spO1xuICAgIH1cbiAgICBpZiAodGhpcy5hbmltYXRpb25GcmFtZUZ1bmMgJiYgdGhpcy5hbmltYXRpb25JZCkge1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uSWQpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMuY29uZmlnLmRyYWdNb3VzZUJ1dHRvbikge1xuICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgdGhpcy5kcmFnTW91c2VCdXR0b24gPSAxO1xuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoICgpID0+IHRoaXMuZnJhbWVFbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYXV4Y2xpY2snLCB0aGlzLnByZXZlbnREZWZhdWx0ICkgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhciggKCkgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLnByZXZlbnREZWZhdWx0ICkgKTtcbiAgICAgICAgdGhpcy5kcmFnTW91c2VCdXR0b24gPSAyO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuXG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyBFTkQgT0YgTElGRUNZQ0xFIEhPT0tTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG5cblxuXG5cblxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyBFVkVOVCBIQU5ETEVSUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuXG4gIHByaXZhdGUgb25Nb3VzZVdoZWVsID0gKGV2ZW50OiBXaGVlbEV2ZW50KSA9PiB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IE9uTW91c2VXaGVlbCgpIGV2ZW50OicsIGV2ZW50KTtcblxuICAgIGlmICghKGV2ZW50ICYmIGV2ZW50LnBhZ2VYICYmIGV2ZW50LnBhZ2VZKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGxldCBldmVudCA9IGUuZXZlbnQ7XG4gICAgbGV0IGRlbHRhWSA9IGV2ZW50LmRlbHRhWTtcblxuICAgIGlmICh0aGlzLmNvbmZpZy56b29tT25Nb3VzZVdoZWVsKSB7XG4gICAgICAvLyBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBpZiAodGhpcy5hbmltYXRpb25QYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBhbHJlYWR5IHpvb21pbmdcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmNvbmZpZy5pbnZlcnRNb3VzZVdoZWVsKSB7XG4gICAgICAgIGRlbHRhWSA9IC1kZWx0YVk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKCdkZWx0YVk6JywgZXZlbnQuZGVsdGFZKTtcblxuICAgICAgLy8gbGV0IHNpZ24gPSBldmVudC5kZWx0YVkgLyBNYXRoLmFicyhldmVudC5kZWx0YVkpO1xuXG4gICAgICBsZXQgY2xpY2tQb2ludDogUG9pbnQgPSB7XG4gICAgICAgIHg6IGV2ZW50LnBhZ2VYIC0gdGhpcy5qUXVlcnlGcmFtZUVsZW1lbnQub2Zmc2V0KCkubGVmdCxcbiAgICAgICAgeTogZXZlbnQucGFnZVkgLSB0aGlzLmpRdWVyeUZyYW1lRWxlbWVudC5vZmZzZXQoKS50b3BcbiAgICAgIH07XG5cbiAgICAgIHRoaXMubGFzdENsaWNrUG9pbnQgPSBjbGlja1BvaW50O1xuXG4gICAgICBpZiAodGhpcy5jb25maWcuZnJlZU1vdXNlV2hlZWwpIHtcbiAgICAgICAgLy8gZnJlZSB3aGVlbCBzY3JvbGxcbiAgICAgICAgdGhpcy5mcmVlWm9vbShjbGlja1BvaW50LCBkZWx0YVkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGxldCBzaWduID0gTWF0aC5zaWduKGV2ZW50LmRlbHRhWSk7XG4gICAgICAgIGlmIChkZWx0YVkgPCAwKSB7XG4gICAgICAgICAgdGhpcy56b29tSW4oY2xpY2tQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVsdGFZID4gMCkge1xuICAgICAgICAgIHRoaXMuem9vbU91dChjbGlja1BvaW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cblxuICAvKipcbiAgICogTWV0aG9kIHdpbGwgY2hlY2sgaWYgJ2NoaWxkJyBub2RlIGVsZW1lbnQgaXMgYSBjaGlsZCBvZlxuICAgKiBwYXJlbnQgbm9kZSB3aXRoIGNsYXNzICdjbGFzc05hbWUnXG4gICAqIEBwYXJhbSBjbGFzc05hbWVcbiAgICogQHBhcmFtIGNoaWxkXG4gICAqL1xuICBwcml2YXRlIGlzUGFyZW50RWxlbWVudChjbGFzc05hbWUsIGNoaWxkKSB7XG4gICAgbGV0IG5vZGUgPSBjaGlsZC5wYXJlbnROb2RlO1xuICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgIGlmIChub2RlLmNsYXNzTGlzdCAmJiBub2RlLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cblxuXG4gIHByaXZhdGUgb25Nb3VzZWRvd24gPSAoZXZlbnQ6IGFueSkgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKCdQYW5ab29tQ29tcG9uZW50OiBvbk1vdXNlZG93bigpJywgZXZlbnQpO1xuXG4gICAgLyogQ2hlY2sgaWYgY2xpY2tlZCBsb2NhdGlvbiBpcyBpbnNpZGUgZWxlbWVudCBmcm9tIHdoaWNoXG4gICAgICAgZHJhZ2dpbmcgaXMgcHJldmVudGVkLiAqL1xuICAgIGlmICh0aGlzLmNvbmZpZy5ub0RyYWdGcm9tRWxlbWVudENsYXNzXG4gICAgICAgICYmIHRoaXMuaXNQYXJlbnRFbGVtZW50KHRoaXMuY29uZmlnLm5vRHJhZ0Zyb21FbGVtZW50Q2xhc3MsIGV2ZW50LnNyY0VsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gdGhpcy5kcmFnTW91c2VCdXR0b24gfHwgZXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgLy8gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIHRoaXMuZHJhZ0ZpbmlzaGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5wYW5WZWxvY2l0eSA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLmNvbmZpZy5wYW5PbkNsaWNrRHJhZykge1xuICAgICAgICB0aGlzLnByZXZpb3VzUG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogZXZlbnQucGFnZVgsXG4gICAgICAgICAgeTogZXZlbnQucGFnZVlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sYXN0TW91c2VFdmVudFRpbWUgPSBldmVudC50aW1lU3RhbXA7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMubW9kZWwuaXNQYW5uaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNNb2JpbGUpIHtcbiAgICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoICgpID0+IGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kLCBmYWxzZSApICk7IC8vIGxlYXZlIHRoaXMgb24gZG9jdW1lbnRcbiAgICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoICgpID0+IGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25Ub3VjaE1vdmUsIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogZmFsc2UgfSApICk7IC8vIGxlYXZlIHRoaXMgb24gZG9jdW1lbnRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoICgpID0+IGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUsIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogZmFsc2UgfSApICk7IC8vIGxlYXZlIHRoaXMgb24gZG9jdW1lbnRcbiAgICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoICgpID0+IGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcCApICk7IC8vIGxlYXZlIHRoaXMgb24gZG9jdW1lbnRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cblxuXG4gIHByaXZhdGUgb25Ub3VjaFN0YXJ0ID0gKGV2ZW50OiBUb3VjaEV2ZW50KSA9PiB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IG9uVG91Y2hTdGFydCgpJywgZXZlbnQpO1xuICAgIC8vIGNvbnNvbGUubG9nKCdQYW5ab29tQ29tcG9uZW50OiBvblRvdWNoU3RhcnQoKTogdG91Y2hlczonLCBldmVudC50b3VjaGVzLmxlbmd0aCk7XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAvLyBtdWx0aXBsZSB0b3VjaGVzLCBnZXQgcmVhZHkgZm9yIHpvb21pbmdcblxuICAgICAgLy8gQ2FsY3VsYXRlIHggYW5kIHkgZGlzdGFuY2UgYmV0d2VlbiB0b3VjaCBldmVudHNcbiAgICAgIGxldCB4ID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWCAtIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVg7XG4gICAgICBsZXQgeSA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgLSBldmVudC50b3VjaGVzWzFdLnBhZ2VZO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgbGVuZ3RoIGJldHdlZW4gdG91Y2ggcG9pbnRzIHdpdGggcHl0aGFnb3Jhc1xuICAgICAgLy8gVGhlcmUgaXMgbm8gcmVhc29uIHRvIHVzZSBNYXRoLnBvdyBhbmQgTWF0aC5zcXJ0IGFzIHdlXG4gICAgICAvLyBvbmx5IHdhbnQgYSByZWxhdGl2ZSBsZW5ndGggYW5kIG5vdCB0aGUgZXhhY3Qgb25lLlxuICAgICAgdGhpcy5wcmV2aW91c1Bvc2l0aW9uID0ge1xuICAgICAgICBsZW5ndGg6IHggKiB4ICsgeSAqIHlcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMub25Nb3VzZWRvd24oZXZlbnQpO1xuICB9XG5cblxuXG4gIHByaXZhdGUgb25Nb3VzZU1vdmUgPSAoZXZlbnQ6IGFueSkgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKCdQYW5ab29tQ29tcG9uZW50OiBvbk1vdXNlTW92ZSgpJywgZXZlbnQpO1xuICAgIC8vIGNvbnNvbGUubG9nKGBQYW5ab29tQ29tcG9uZW50OiBvbk1vdXNlTW92ZSgpOiBldmVudC50aW1lU3RhbXA6YCwgZXZlbnQudGltZVN0YW1wKTtcbiAgICAvLyB0aW1lc3RhbXAgLSAxMDU4Ny44Nzk5OTk5OTkxMzIgLSBtaWxsaXNlY29uZHNcbiAgICAvLyBDYWxsZWQgd2hlbiBtb3ZpbmcgdGhlIG1vdXNlIHdpdGggdGhlIGxlZnQgYnV0dG9uIGRvd25cblxuICAgIC8vIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgLy8gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICBpZiAoIShldmVudCAmJiBldmVudC5wYWdlWCAmJiBldmVudC5wYWdlWSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgbm93ID0gZXZlbnQudGltZVN0YW1wO1xuICAgIGxldCB0aW1lU2luY2VMYXN0TW91c2VFdmVudCA9IChub3cgLSB0aGlzLmxhc3RNb3VzZUV2ZW50VGltZSkgLyAxMDAwOyAvLyBvcmlnXG4gICAgLy8gbGV0IHRpbWVTaW5jZUxhc3RNb3VzZUV2ZW50ID0gKG5vdyAtIHRoaXMubGFzdE1vdXNlRXZlbnRUaW1lKTtcbiAgICB0aGlzLmxhc3RNb3VzZUV2ZW50VGltZSA9IG5vdztcbiAgICBsZXQgZHJhZ0RlbHRhID0ge1xuICAgICAgLy8gYSByZXByZXNlbnRhdGlvbiBvZiBob3cgZmFyIGVhY2ggY29vcmRpbmF0ZSBoYXMgbW92ZWQgc2luY2UgdGhlIGxhc3QgdGltZSBpdCB3YXMgbW92ZWRcbiAgICAgIHg6IGV2ZW50LnBhZ2VYIC0gdGhpcy5wcmV2aW91c1Bvc2l0aW9uLngsXG4gICAgICB5OiBldmVudC5wYWdlWSAtIHRoaXMucHJldmlvdXNQb3NpdGlvbi55XG4gICAgfTtcblxuICAgIGlmICh0aGlzLmNvbmZpZy5rZWVwSW5Cb3VuZHMpIHtcbiAgICAgIGxldCB0b3BMZWZ0Q29ybmVyVmlldyA9IHRoaXMuZ2V0Vmlld1Bvc2l0aW9uKCB7IHg6IDAsIHk6IDAgfSApO1xuICAgICAgbGV0IGJvdHRvbVJpZ2h0Q29ybmVyVmlldyA9IHRoaXMuZ2V0Vmlld1Bvc2l0aW9uKCB7IHg6IHRoaXMuY29udGVudFdpZHRoLCB5OiB0aGlzLmNvbnRlbnRIZWlnaHQgfSApO1xuXG5cbiAgICAgIGlmICh0b3BMZWZ0Q29ybmVyVmlldy54ID4gMCAmJiBkcmFnRGVsdGEueCA+IDApIHtcbiAgICAgICAgZHJhZ0RlbHRhLnggKj0gTWF0aC5taW4oMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5wb3codG9wTGVmdENvcm5lclZpZXcueCwgLXRoaXMuY29uZmlnLmtlZXBJbkJvdW5kc0RyYWdQdWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9wTGVmdENvcm5lclZpZXcueSA+IDAgJiYgZHJhZ0RlbHRhLnkgPiAwKSB7XG4gICAgICAgIGRyYWdEZWx0YS55ICo9IE1hdGgubWluKDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5wb3codG9wTGVmdENvcm5lclZpZXcueSwgLXRoaXMuY29uZmlnLmtlZXBJbkJvdW5kc0RyYWdQdWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJvdHRvbVJpZ2h0Q29ybmVyVmlldy54IDwgdGhpcy5jb250ZW50V2lkdGggJiYgZHJhZ0RlbHRhLnggPCAwKSB7XG4gICAgICAgIGRyYWdEZWx0YS54ICo9IE1hdGgubWluKDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5wb3codGhpcy5jb250ZW50V2lkdGggLSBib3R0b21SaWdodENvcm5lclZpZXcueCwgLXRoaXMuY29uZmlnLmtlZXBJbkJvdW5kc0RyYWdQdWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoYm90dG9tUmlnaHRDb3JuZXJWaWV3LnkgPCB0aGlzLmNvbnRlbnRIZWlnaHQgJiYgZHJhZ0RlbHRhLnkgPCAwKSB7XG4gICAgICAgIGRyYWdEZWx0YS55ICo9IE1hdGgubWluKDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnBvdyh0aGlzLmNvbnRlbnRIZWlnaHQgLSBib3R0b21SaWdodENvcm5lclZpZXcueSwgLXRoaXMuY29uZmlnLmtlZXBJbkJvdW5kc0RyYWdQdWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vdyBwYW4gdGhlIHZpZXdcbiAgICBsZXQgZGVsdGE6IFBvaW50ID0ge1xuICAgICAgeDogZHJhZ0RlbHRhLnggfHwgMCxcbiAgICAgIHk6IGRyYWdEZWx0YS55IHx8IDBcbiAgICB9O1xuICAgIHRoaXMubW9kZWwucGFuLnggKz0gZGVsdGEueDtcbiAgICB0aGlzLm1vZGVsLnBhbi55ICs9IGRlbHRhLnk7XG4gICAgdGhpcy5zeW5jQmFzZVRvTW9kZWwoKTtcbiAgICB0aGlzLmFuaW1hdGlvblRpY2socGVyZm9ybWFuY2Uubm93KCkpO1xuXG4gICAgaWYgKCF0aGlzLm1vZGVsLmlzUGFubmluZykge1xuICAgICAgLy8gVGhpcyB3aWxsIGltcHJvdmUgdGhlIHBlcmZvcm1hbmNlLFxuICAgICAgLy8gYmVjYXVzZSB0aGUgYnJvd3NlciBzdG9wcyBldmFsdWF0aW5nIGhpdHMgYWdhaW5zdCB0aGUgZWxlbWVudHMgZGlzcGxheWVkIGluc2lkZSB0aGUgcGFuIHpvb20gdmlldy5cbiAgICAgIC8vIEJlc2lkZXMgdGhpcywgbW91c2UgZXZlbnRzIHdpbGwgbm90IGJlIHNlbnQgdG8gYW55IG90aGVyIGVsZW1lbnRzLFxuICAgICAgLy8gdGhpcyBwcmV2ZW50cyBpc3N1ZXMgbGlrZSBzZWxlY3RpbmcgZWxlbWVudHMgd2hpbGUgZHJhZ2dpbmcuXG4gICAgICB0aGlzLnBhbnpvb21PdmVybGF5UmVmLm5hdGl2ZUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgfVxuXG4gICAgdGhpcy5tb2RlbC5pc1Bhbm5pbmcgPSB0cnVlO1xuXG4gICAgLy8gc2V0IHRoZXNlIGZvciB0aGUgYW5pbWF0aW9uIHNsb3cgZG93biBvbmNlIGRyYWcgc3RvcHNcbiAgICAvLyBwYW5WZWxvY2l0eSBpcyBhIG1lYXN1cmVtZW50IG9mIHNwZWVkIGZvciB4IGFuZCB5IGNvb3JkaW5hdGVzLCBpbiBwaXhlbHMgcGVyIG1vdXNlIG1vdmUgZXZlbnQuICBJdCBpcyBhIG1lYXN1cmUgb2YgaG93IGZhc3QgdGhlIG1vdXNlIGlzIG1vdmluZ1xuICAgIHRoaXMucGFuVmVsb2NpdHkgPSB7XG4gICAgICB4OiBkcmFnRGVsdGEueCAvIHRpbWVTaW5jZUxhc3RNb3VzZUV2ZW50LFxuICAgICAgeTogZHJhZ0RlbHRhLnkgLyB0aW1lU2luY2VMYXN0TW91c2VFdmVudFxuICAgIH07XG4gICAgLy8gY29uc29sZS5sb2coYFBhblpvb21Db21wb25lbnQ6IG9uTW91c2VNb3ZlKCk6IHBhblZlbG9jaXR5OmAsIHRoaXMucGFuVmVsb2NpdHkpO1xuXG4gICAgdGhpcy5wcmV2aW91c1Bvc2l0aW9uID0ge1xuICAgICAgeDogZXZlbnQucGFnZVgsXG4gICAgICB5OiBldmVudC5wYWdlWVxuICAgIH07XG5cbiAgfVxuXG5cblxuICBwcml2YXRlIG9uVG91Y2hNb3ZlID0gKGV2ZW50OiBhbnkpID0+IHtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogb25Ub3VjaE1vdmUoKScpO1xuICAgIC8vIGNvbnNvbGUubG9nKCdQYW5ab29tQ29tcG9uZW50OiBvblRvdWNoTW92ZSgpOiBldmVudDonLCBldmVudCk7XG5cbiAgICAvLyBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBzaW5nbGUgdG91Y2gsIGVtdWxhdGUgbW91c2UgbW92ZVxuICAgICAgdGhpcy5vbk1vdXNlTW92ZShldmVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gbXVsdGlwbGUgdG91Y2hlcywgem9vbSBpbi9vdXRcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdwaW5jaCB6b29taW5nJyk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB4IGFuZCB5IGRpc3RhbmNlIGJldHdlZW4gdG91Y2ggZXZlbnRzXG4gICAgICBsZXQgeCA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggLSBldmVudC50b3VjaGVzWzFdLnBhZ2VYO1xuICAgICAgbGV0IHkgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWTtcbiAgICAgIC8vIENhbGN1bGF0ZSBsZW5ndGggYmV0d2VlbiB0b3VjaCBwb2ludHMgd2l0aCBweXRoYWdvcmFzXG4gICAgICAvLyBUaGVyZSBpcyBubyByZWFzb24gdG8gdXNlIE1hdGgucG93IGFuZCBNYXRoLnNxcnQgYXMgd2VcbiAgICAgIC8vIG9ubHkgd2FudCBhIHJlbGF0aXZlIGxlbmd0aCBhbmQgbm90IHRoZSBleGFjdCBvbmUuXG4gICAgICBsZXQgbGVuZ3RoID0geCAqIHggKyB5ICogeTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGRlbHRhIGJldHdlZW4gY3VycmVudCBwb3NpdGlvbiBhbmQgbGFzdCBwb3NpdGlvblxuICAgICAgbGV0IGRlbHRhID0gbGVuZ3RoIC0gdGhpcy5wcmV2aW91c1Bvc2l0aW9uLmxlbmd0aDtcblxuICAgICAgLy8gTmFpdmUgaHlzdGVyZXNpc1xuICAgICAgaWYgKE1hdGguYWJzKGRlbHRhKSA8IDEwMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBjZW50ZXIgYmV0d2VlbiB0b3VjaCBwb2ludHNcbiAgICAgIGxldCBjZW50ZXJYID0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWCArIHggLyAyO1xuICAgICAgbGV0IGNlbnRlclkgPSBldmVudC50b3VjaGVzWzFdLnBhZ2VZICsgeSAvIDI7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB6b29tIGNlbnRlclxuICAgICAgbGV0IGNsaWNrUG9pbnQgPSB7XG4gICAgICAgIHg6IGNlbnRlclggLSB0aGlzLmpRdWVyeUZyYW1lRWxlbWVudC5vZmZzZXQoKS5sZWZ0LFxuICAgICAgICB5OiBjZW50ZXJZIC0gdGhpcy5qUXVlcnlGcmFtZUVsZW1lbnQub2Zmc2V0KCkudG9wXG4gICAgICB9O1xuICAgICAgdGhpcy5sYXN0Q2xpY2tQb2ludCA9IGNsaWNrUG9pbnQ7XG5cbiAgICAgIHRoaXMuY2hhbmdlWm9vbUxldmVsKCB0aGlzLmJhc2Uuem9vbUxldmVsICsgZGVsdGEgKiAwLjAwMDEsIGNsaWNrUG9pbnQpO1xuICAgICAgLy8gdGhpcy5mcmVlWm9vbSggY2xpY2tQb2ludCwgZGVsdGEpO1xuXG4gICAgICAvLyBVcGRhdGUgbGVuZ3RoIGZvciBuZXh0IG1vdmUgZXZlbnRcbiAgICAgIHRoaXMucHJldmlvdXNQb3NpdGlvbiA9IHtcbiAgICAgICAgbGVuZ3RoOiBsZW5ndGhcbiAgICAgIH07XG4gICAgfVxuICB9XG5cblxuXG4gIHByaXZhdGUgb25Nb3VzZVVwID0gKGV2ZW50KSA9PiB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IG9uTW91c2V1cCgpJywgZXZlbnQpO1xuXG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gdGhpcy5kcmFnTW91c2VCdXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgbGV0IG5vdyA9IGV2ZW50LnRpbWVTdGFtcDtcbiAgICBsZXQgdGltZVNpbmNlTGFzdE1vdXNlRXZlbnQgPSAobm93IC0gdGhpcy5sYXN0TW91c2VFdmVudFRpbWUpIC8gMTAwMDsgLy8gb3JpZ1xuXG4gICAgaWYgKHRoaXMucGFuVmVsb2NpdHkgJiYgKHRoaXMucGFuVmVsb2NpdHkueCAhPT0gMCB8fCB0aGlzLnBhblZlbG9jaXR5LnkgIT09IDApICkge1xuICAgICAgLy8gYXBwbHkgc3Ryb25nIGluaXRpYWwgZGFtcGVuaW5nIGlmIHRoZSBtb3VzZSB1cCBvY2N1cmVkIG11Y2ggbGF0ZXIgdGhhbiB0aGUgbGFzdCBtb3VzZSBtb3ZlLCBpbmRpY2F0aW5nIHRoYXQgdGhlIG1vdXNlIGhhc24ndCBtb3ZlZCByZWNlbnRseVxuICAgICAgLy8gVEJEIC0gZXhwZXJpbWVudCB3aXRoIHRoaXMgZm9ybXVsYVxuICAgICAgbGV0IGluaXRpYWxNdWx0aXBsaWVyID0gTWF0aC5tYXgoXG4gICAgICAgIDAsXG4gICAgICAgIC0wLjIgKyBNYXRoLnBvdyh0aW1lU2luY2VMYXN0TW91c2VFdmVudCArIDEsIC00KVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFuVmVsb2NpdHkueCAqPSBpbml0aWFsTXVsdGlwbGllcjtcbiAgICAgICAgdGhpcy5wYW5WZWxvY2l0eS55ICo9IGluaXRpYWxNdWx0aXBsaWVyO1xuICAgICAgICB0aGlzLmRyYWdGaW5pc2hpbmcgPSB0cnVlO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhgUGFuWm9vbUNvbXBvbmVudDogb25Nb3VzZVVwKCk6IHBhblZlbG9jaXR5OmAsIHRoaXMucGFuVmVsb2NpdHkpO1xuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoICgpID0+IHRoaXMuYW5pbWF0aW9uSWQgPSB0aGlzLmFuaW1hdGlvbkZyYW1lRnVuYyh0aGlzLmFuaW1hdGlvblRpY2spICk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5kcmFnRmluaXNoaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFuVmVsb2NpdHkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgIC8vIHRoaXMubW9kZWwuaXNQYW5uaW5nID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLmlzTW9iaWxlKSB7XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhciggKCkgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmQpICk7XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhciggKCkgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vblRvdWNoTW92ZSwgPGFueT57IHBhc3NpdmU6IHRydWUsIGNhcHR1cmU6IGZhbHNlIH0gKSApO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhciggKCkgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZSwgPGFueT57IHBhc3NpdmU6IHRydWUsIGNhcHR1cmU6IGZhbHNlIH0gKSk7XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhciggKCkgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwLCA8YW55PnsgcGFzc2l2ZTogdHJ1ZSB9ICkpO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgb3ZlcmxheSB0byBub24tYmxvY2tpbmcgYWdhaW46XG4gICAgdGhpcy5wYW56b29tT3ZlcmxheVJlZi5uYXRpdmVFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH1cblxuXG5cbiAgcHJpdmF0ZSBvblRvdWNoRW5kID0gKGV2ZW50OiBhbnkpID0+IHtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogb25Ub3VjaEVuZCgpJyk7XG4gICAgdGhpcy5vbk1vdXNlVXAoZXZlbnQpO1xuICB9XG5cblxuXG4gIHByaXZhdGUgb25EYmxDbGljayA9IChldmVudDogYW55KSA9PiB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IG9uRGJsQ2xpY2soKScpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgLy8gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy56b29tT25Eb3VibGVDbGljaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBjbGlja1BvaW50OiBQb2ludCA9IHtcbiAgICAgIHg6IGV2ZW50LnBhZ2VYIC0gdGhpcy5qUXVlcnlGcmFtZUVsZW1lbnQub2Zmc2V0KCkubGVmdCxcbiAgICAgIHk6IGV2ZW50LnBhZ2VZIC0gdGhpcy5qUXVlcnlGcmFtZUVsZW1lbnQub2Zmc2V0KCkudG9wXG4gICAgfTtcbiAgICB0aGlzLmxhc3RDbGlja1BvaW50ID0gY2xpY2tQb2ludDtcbiAgICB0aGlzLnpvb21JbihjbGlja1BvaW50KTtcbiAgfVxuXG5cblxuICBwcml2YXRlIHByZXZlbnREZWZhdWx0ID0gKGV2ZW50OiBhbnkpID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cblxuXG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gRU5EIEVWRU5UIEhBTkRMRVJTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG5cblxuXG5cblxuXG5cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyBBUFBMWSBBTklNQVRJT05TIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cblxuICBwcml2YXRlIGFuaW1hdGlvblRpY2sgPSAodGltZXN0YW1wOiBudW1iZXIpID0+IHtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogYW5pbWF0aW9uVGljaygpJyk7XG4gICAgLy8gdGltZXN0YW1wIGxvb2tzIGxpa2UgNzY5MTYuOTYzLiAgVGhlIHVuaXQgaXMgbWlsbGlzZWNvbmRzIGFuZCBzaG91bGQgYmUgYWNjdXJhdGUgdG8gNSDCtXMgKG1pY3Jvc2Vjb25kcylcblxuICAgIGxldCBkZWx0YVRpbWUgPSAwO1xuICAgIGlmICh0aGlzLmxhc3RUaWNrICE9PSAwKSB7XG4gICAgICBkZWx0YVRpbWUgPSAodGltZXN0YW1wIC0gdGhpcy5sYXN0VGljayk7IC8vIG9yaWcgLSBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgYW5pbWF0aW9uVGlja1xuICAgIH1cbiAgICB0aGlzLmxhc3RUaWNrID0gdGltZXN0YW1wO1xuXG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uUGFyYW1zKSB7XG4gICAgICAvLyB3aGVuIHdlJ3JlIHJ1bm5pbmcgYW4gYW5pbWF0aW9uIChidXQgbm90IHdhaXRpbmcgZm9yIGEgcmVsZWFzZWQgZHJhZyB0byBoYWx0KVxuICAgICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IGFuaW1hdGlvblRpY2soKTogbW9kZWwgaXMgem9vbWluZycpO1xuXG4gICAgICB0aGlzLmFuaW1hdGlvblBhcmFtcy5wcm9ncmVzcyArPSBNYXRoLmFicyhkZWx0YVRpbWUgLyB0aGlzLmFuaW1hdGlvblBhcmFtcy5kdXJhdGlvbik7XG5cbiAgICAgIGlmICh0aGlzLmFuaW1hdGlvblBhcmFtcy5wcm9ncmVzcyA+PSAxLjApIHtcbiAgICAgICAgLy8gT25seSB3aGVuIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLCBzeW5jIHRoZSBiYXNlIHRvIHRoZSBtb2RlbC5cbiAgICAgICAgdGhpcy5hbmltYXRpb25QYXJhbXMucHJvZ3Jlc3MgPSAxLjA7XG4gICAgICAgIHRoaXMudXBkYXRlRE9NKCk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uUGFyYW1zID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYW5WZWxvY2l0eSAmJiB0aGlzLmRyYWdGaW5pc2hpbmcpIHtcbiAgICAgIC8vIFRoaXMgaXMgd2hlbiB3ZSd2ZSBwYW5uZWQgYW5kIHJlbGVhc2VkIHRoZSBtb3VzZSBidXR0b24gYW5kIHRoZSB2aWV3IGlzIFwiZnJlZS1mbG9hdGluZ1wiIHVudGlsIGl0IHNsb3dzIHRvIGEgaGFsdC4gIERvbid0IGxldCB0aGUgd2hpbGUgbG9vcCBmb29sIHlvdSAtIHRoaXMgb25seSBhcHBsaWVzIGl0IGZvciB0aGUgY3VycmVudCBmcmFtZS5cbiAgICAgIC8vIFByZXZlbnQgb3ZlcnNob290aW5nIGlmIGRlbHRhIHRpbWUgaXMgbGFyZ2UgZm9yIHNvbWUgcmVhc29uLiBXZSBhcHBseSB0aGUgc2ltcGxlIHNvbHV0aW9uIG9mIHNsaWNpbmcgZGVsdGEgdGltZSBpbnRvIHNtYWxsZXIgcGllY2VzIGFuZCBhcHBseWluZyBlYWNoIG9uZVxuICAgICAgaWYgKGRlbHRhVGltZSA+IDApIHtcbiAgICAgICAgZGVsdGFUaW1lID0gZGVsdGFUaW1lIC8gMTAwMDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChkZWx0YVRpbWUgPiAwKSB7XG4gICAgICAgIGxldCBkVGltZSA9IE1hdGgubWluKC4wMiwgZGVsdGFUaW1lKTtcbiAgICAgICAgZGVsdGFUaW1lID0gZGVsdGFUaW1lIC0gZFRpbWU7XG5cbiAgICAgICAgdGhpcy5tb2RlbC5wYW4ueCA9IHRoaXMubW9kZWwucGFuLnggKyB0aGlzLnBhblZlbG9jaXR5LnggKiBkVGltZTtcbiAgICAgICAgdGhpcy5wYW5WZWxvY2l0eS54ID0gdGhpcy5wYW5WZWxvY2l0eS54ICogKDEgLSB0aGlzLmNvbmZpZy5mcmljdGlvbiAqIGRUaW1lKTtcblxuICAgICAgICB0aGlzLm1vZGVsLnBhbi55ID0gdGhpcy5tb2RlbC5wYW4ueSArIHRoaXMucGFuVmVsb2NpdHkueSAqIGRUaW1lO1xuICAgICAgICB0aGlzLnBhblZlbG9jaXR5LnkgPSB0aGlzLnBhblZlbG9jaXR5LnkgKiAoMSAtIHRoaXMuY29uZmlnLmZyaWN0aW9uICogZFRpbWUpO1xuXG4gICAgICAgIGxldCBzcGVlZCA9IHRoaXMubGVuZ3RoKHRoaXMucGFuVmVsb2NpdHkpO1xuXG4gICAgICAgIGlmIChzcGVlZCA8IHRoaXMuY29uZmlnLmhhbHRTcGVlZCkge1xuICAgICAgICAgIHRoaXMubW9kZWwuaXNQYW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5wYW5WZWxvY2l0eSA9IG51bGw7XG4gICAgICAgICAgdGhpcy5kcmFnRmluaXNoaW5nID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmNvbmZpZy5rZWVwSW5Cb3VuZHMgfHwgdGhpcy5kcmFnRmluaXNoaW5nKSB7XG4gICAgICAvLyBDaGVja3MgdGhhdCBrZWVwSW5Cb3VuZHMgaXMgc2V0IGFuZCB0aGF0IHRoZSBtb3VzZSBidXR0b24gaXNuJ3QgcHJlc3NlZCwgYW5kIGlmIHNvLCBpdCBzdG9wcyB0aGUgY29udGVudHMgZnJvbSBnb2luZyBvdXQgb2Ygdmlld1xuICAgICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IGFuaW1hdGlvblRpY2soKToga2VlcEluQm91bmRzJyk7XG4gICAgICBsZXQgdG9wTGVmdENvcm5lclZpZXcgPSB0aGlzLmdldFZpZXdQb3NpdGlvbih7IHg6IDAsIHk6IDAgfSk7XG4gICAgICBsZXQgYm90dG9tUmlnaHRDb3JuZXJWaWV3ID0gdGhpcy5nZXRWaWV3UG9zaXRpb24oeyB4OiB0aGlzLmNvbnRlbnRXaWR0aCwgeTogdGhpcy5jb250ZW50SGVpZ2h0IH0pO1xuXG4gICAgICBpZiAodG9wTGVmdENvcm5lclZpZXcueCA+IDApIHtcbiAgICAgICAgdGhpcy5iYXNlLnBhbi54IC09IHRoaXMuY29uZmlnLmtlZXBJbkJvdW5kc1Jlc3RvcmVGb3JjZSAqIHRvcExlZnRDb3JuZXJWaWV3Lng7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b3BMZWZ0Q29ybmVyVmlldy55ID4gMCkge1xuICAgICAgICB0aGlzLmJhc2UucGFuLnkgLT0gdGhpcy5jb25maWcua2VlcEluQm91bmRzUmVzdG9yZUZvcmNlICogdG9wTGVmdENvcm5lclZpZXcueTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJvdHRvbVJpZ2h0Q29ybmVyVmlldy54IDwgdGhpcy5jb250ZW50V2lkdGgpIHtcbiAgICAgICAgdGhpcy5iYXNlLnBhbi54IC09IHRoaXMuY29uZmlnLmtlZXBJbkJvdW5kc1Jlc3RvcmVGb3JjZSAqIChib3R0b21SaWdodENvcm5lclZpZXcueCAtIHRoaXMuY29udGVudFdpZHRoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJvdHRvbVJpZ2h0Q29ybmVyVmlldy55IDwgdGhpcy5jb250ZW50SGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuYmFzZS5wYW4ueSAtPSB0aGlzLmNvbmZpZy5rZWVwSW5Cb3VuZHNSZXN0b3JlRm9yY2UgKiAoYm90dG9tUmlnaHRDb3JuZXJWaWV3LnkgLSB0aGlzLmNvbnRlbnRIZWlnaHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlRE9NKCk7XG4gICAgdGhpcy5jb25maWcubW9kZWxDaGFuZ2VkLm5leHQodGhpcy5tb2RlbCk7XG5cblxuICAgIGlmICggdGhpcy5hbmltYXRpb25QYXJhbXMgfHwgKHRoaXMucGFuVmVsb2NpdHkgJiYgdGhpcy5kcmFnRmluaXNoaW5nKSApIHtcbiAgICAgIC8vIEFyZSB3ZSBpbiBhbiBhbmltYXRpb24/ICBJZiBzbywgcnVuIHRoZSBuZXh0IGZyYW1lXG5cbiAgICAgIGlmICh0aGlzLmlzQ2hyb21lICYmIHRoaXMuem9vbUxldmVsSXNDaGFuZ2luZykge1xuICAgICAgICAvLyBydW4gd2lsbC1jaGFuZ2UgdG9nZ2xlIGhhY2sgb24gQ2hyb21lIHRvIHRyaWdnZXIgcmUtcmFzdGVyaXphdGlvblxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3VwZGF0ZXMvMjAxNi8wOS9yZS1yYXN0ZXJpbmctY29tcG9zaXRlXG4gICAgICAgIGlmICh0aGlzLndpbGxDaGFuZ2VOZXh0RnJhbWUpIHtcbiAgICAgICAgICAoPGFueT50aGlzLmFjY2VsZXJhdGVkRnJhbWVSZWYubmF0aXZlRWxlbWVudC5zdHlsZSkud2lsbENoYW5nZSA9ICdhdXRvJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAoPGFueT50aGlzLmFjY2VsZXJhdGVkRnJhbWVSZWYubmF0aXZlRWxlbWVudC5zdHlsZSkud2lsbENoYW5nZSA9ICd0cmFuc2Zvcm0nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2lsbENoYW5nZU5leHRGcmFtZSA9ICF0aGlzLndpbGxDaGFuZ2VOZXh0RnJhbWU7XG4gICAgICB9XG4gICAgICAvLyBjb25zb2xlLmxvZygnY2FsbGluZyBuZXh0IHRpY2snKTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWVGdW5jKHRoaXMuYW5pbWF0aW9uVGljayk7IC8vIENhbGwgdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lXG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMucGFuVmVsb2NpdHkgJiYgIXRoaXMuZHJhZ0ZpbmlzaGluZykge1xuICAgICAgLy8gd2UncmUganVzdCBtb3VzZS1wYW5uaW5nIHRoZSBmcmFtZS4gIFdlIGRvbid0IG5lZWQgYW5vdGhlciB0aWNrXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gQW5pbWF0aW9uIGhhcyBlbmRlZFxuICAgICAgdGhpcy5zeW5jQmFzZVRvTW9kZWwoKTtcbiAgICAgIHRoaXMuc2NhbGUgPSB0aGlzLmdldENzc1NjYWxlKHRoaXMuYmFzZS56b29tTGV2ZWwpO1xuICAgICAgdGhpcy53aWxsQ2hhbmdlTmV4dEZyYW1lID0gdHJ1ZTtcbiAgICAgICg8YW55PnRoaXMuYWNjZWxlcmF0ZWRGcmFtZVJlZi5uYXRpdmVFbGVtZW50LnN0eWxlKS53aWxsQ2hhbmdlID0gJ3RyYW5zZm9ybSc7XG4gICAgICB0aGlzLnpvb21MZXZlbElzQ2hhbmdpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMubGFzdFRpY2sgPSAwO1xuICAgIH1cblxuICB9XG5cblxuXG4gIHByaXZhdGUgdXBkYXRlRE9NKCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdQYW5ab29tQ29tcG9uZW50OiB1cGRhdGVET00oKScpO1xuICAgIC8vIENhbGxlZCBieSBuZ0FmdGVyVmlld0luaXQoKSBhbmQgYW5pbWF0aW9uVGljaygpXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBnZXQgY2FsbGVkIGJ5IGZyZWVab29tKCksIHdoaWNoIG9wZXJhdGVzIGluZGVwZW5kZW50bHkgb2YgYW5pbWF0aW9uVGljaygpIGFuZCB1cGRhdGVET00oKS5cblxuICAgIGlmICh0aGlzLmFuaW1hdGlvblBhcmFtcykge1xuICAgICAgLy8gd2UncmUgcnVubmluZyBhbiBhbmltYXRpb24gc2VxdWVuY2UgKGJ1dCBub3QgZnJlZVpvb21pbmcgb3IgcGFubmluZyB3aXRoIG9uTW91c2VNb3ZlKCkgKVxuICAgICAgdGhpcy5tb2RlbC56b29tTGV2ZWwgPSB0aGlzLmJhc2Uuem9vbUxldmVsICsgdGhpcy5hbmltYXRpb25QYXJhbXMuZGVsdGFab29tTGV2ZWwgKiB0aGlzLmFuaW1hdGlvblBhcmFtcy5wcm9ncmVzczsgLy8gY2FsY3VsYXRlIGhvdyBmYXIgd2UgbmVlZCB0byB6b29tIGluIG9yIG91dCBmb3IgdGhlIGN1cnJlbnQgYW5pbWF0aW9uVGlja1xuICAgICAgbGV0IGRlbHRhVHJhbnNsYXRpb24gPSB0aGlzLmFuaW1hdGlvblBhcmFtcy5wYW5TdGVwRnVuYyh0aGlzLm1vZGVsLnpvb21MZXZlbCk7IC8vIGNhbGN1bGF0ZSBob3cgZmFyIHRvIHBhbiB0aGUgdmlldyB0byBiYXNlZCBvbiBvdXIgdHJhbnNsYXRlZCBjb29yZGluYXRlc1xuXG4gICAgICAvLyBzeW5jIHRoZSBtb2RlbCBwYW4gY29vcmRpbmF0ZXMgdG8gb3VyIHRyYW5zbGF0ZWQgcGFuIGNvb3JkaW5hdGVzXG4gICAgICAvLyB3ZSBkbyB0aGlzIGJ5IGFkZGluZyBob3cgZmFyIHdlIHdhbnQgdG8gbW92ZSBpbiBlYWNoIGRpcmVjdGlvbiB0byBvdXIgb3VyIGV4aXN0aW5nIGJhc2UgcGFuIGNvb3JkaW5hdGVzICh3aGVyZSB3ZSBzdGFydGVkKVxuICAgICAgdGhpcy5tb2RlbC5wYW4ueCA9IHRoaXMuYmFzZS5wYW4ueCArIGRlbHRhVHJhbnNsYXRpb24ueDtcbiAgICAgIHRoaXMubW9kZWwucGFuLnkgPSB0aGlzLmJhc2UucGFuLnkgKyBkZWx0YVRyYW5zbGF0aW9uLnk7XG5cbiAgICAgIGlmICh0aGlzLmNvbmZpZy5rZWVwSW5Cb3VuZHMpIHtcbiAgICAgICAgbGV0IHRvcExlZnRDb3JuZXJWaWV3ID0gdGhpcy5nZXRWaWV3UG9zaXRpb24oeyB4OiAwLCB5OiAwIH0pO1xuICAgICAgICBsZXQgYm90dG9tUmlnaHRDb3JuZXJWaWV3ID0gdGhpcy5nZXRWaWV3UG9zaXRpb24oeyB4OiB0aGlzLmNvbnRlbnRXaWR0aCwgeTogdGhpcy5jb250ZW50SGVpZ2h0IH0pO1xuXG4gICAgICAgIGlmICh0b3BMZWZ0Q29ybmVyVmlldy54ID4gMCkge1xuICAgICAgICAgIHRoaXMubW9kZWwucGFuLnggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvcExlZnRDb3JuZXJWaWV3LnkgPiAwKSB7XG4gICAgICAgICAgdGhpcy5tb2RlbC5wYW4ueSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYm90dG9tUmlnaHRDb3JuZXJWaWV3LnggPCB0aGlzLmNvbnRlbnRXaWR0aCkge1xuICAgICAgICAgIHRoaXMubW9kZWwucGFuLnggLT0gKGJvdHRvbVJpZ2h0Q29ybmVyVmlldy54IC0gdGhpcy5jb250ZW50V2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJvdHRvbVJpZ2h0Q29ybmVyVmlldy55IDwgdGhpcy5jb250ZW50SGVpZ2h0KSB7XG4gICAgICAgICAgdGhpcy5tb2RlbC5wYW4ueSAtPSAoYm90dG9tUmlnaHRDb3JuZXJWaWV3LnkgLSB0aGlzLmNvbnRlbnRIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vIEFQUExZIFNDQUxJTkcgLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uUGFyYW1zIHx8IHRoaXMuaXNGaXJzdFN5bmMpIHtcbiAgICAgIGxldCBzY2FsZSA9IHRoaXMuZ2V0Q3NzU2NhbGUodGhpcy5tb2RlbC56b29tTGV2ZWwpO1xuICAgICAgbGV0IHNjYWxlU3RyaW5nID0gYHNjYWxlKCR7c2NhbGV9KWA7XG4gICAgICB0aGlzLnpvb21FbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMCc7XG4gICAgICB0aGlzLnpvb21FbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gc2NhbGVTdHJpbmc7XG4gICAgfVxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8gQVBQTFkgUEFOIEFOSU1BVElPTiAvLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgbGV0IHRyYW5zbGF0ZTNkID0gYHRyYW5zbGF0ZTNkKCR7dGhpcy5tb2RlbC5wYW4ueH1weCwgJHt0aGlzLm1vZGVsLnBhbi55fXB4LCAwKWA7XG4gICAgdGhpcy5wYW5FbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNsYXRlM2Q7XG5cbiAgfVxuXG5cblxuICBwcml2YXRlIGZyZWVab29tKGNsaWNrUG9pbnQ6IFBvaW50LCB3aGVlbERlbHRhOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogZnJlZVpvb20oKTogdGhpcy5iYXNlOicsIHRoaXMuYmFzZSk7XG5cbiAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAvLyBkb24ndCBhbGxvdyB6b29taW5nIGlmIHRoZSBtb3VzZSBpcyBkb3duXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gbm93IGhhbmRsZSBpbnRlcnJ1cHRpb24gb2YgYW4gaW4tcHJvZ3Jlc3MgYW5pbWF0aW9uXG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uUGFyYW1zKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvblBhcmFtcyA9IG51bGw7IC8vIGNhbmNlbCBhbiBleGlzdGluZyBhbmltYXRpb25cbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYW5WZWxvY2l0eSkge1xuICAgICAgdGhpcy5kcmFnRmluaXNoaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLnBhblZlbG9jaXR5ID0gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgY3VycmVudFBhbjogUG9pbnQgPSB7XG4gICAgICAvLyB0aGUgY3VycmVudCBiYXNlIGNvb3JkaW5hdGVzXG4gICAgICB4OiB0aGlzLmJhc2UucGFuLngsXG4gICAgICB5OiB0aGlzLmJhc2UucGFuLnlcbiAgICB9O1xuICAgIC8vICEhIXNvbWV0aGluZywgc29tZXdoZXJlIGlzIHBvdGVudGlhbGx5IGludmFsaWRhdGluZyB0aGUgYmFzZSBwYW4hISFcbiAgICBsZXQgY3VycmVudFNjYWxlID0gdGhpcy5zY2FsZTsgLy8gZ2V0IHRoZSBjdXJyZW50IENTUyBzY2FsZSAoc2NhbGUwKVxuXG4gICAgbGV0IG5ld1NjYWxlID0gdGhpcy5zY2FsZSArICh3aGVlbERlbHRhICogdGhpcy5jb25maWcuZnJlZU1vdXNlV2hlZWxGYWN0b3IgKiB0aGlzLnNjYWxlKTtcblxuICAgIC8vIHRha2VzIGVpdGhlciB0aGUgbWluaW11bSBzY2FsZSAoZnVydGhlc3QgYWxsb3dhYmxlIHpvb21lZCBvdXQpIG9yIHRoZSBjYWxjdWxhdGVkIGN1cnJlbnQgc2NhbGUsIHdoaWNoZXZlciBpcyBncmVhdGVyLCB1bmxlc3MgY2FsY3VsYXRlZCBjdXJyZW50IHNjYWxlIGV4Y2VlZHMgbWF4U2NhbGUgKGZ1cnRoZXN0IGFsbG93YWJsZSB6b29tZWQgaW4pLCBpbiB3aGljaCBjYXNlIG1heFNjYWxlIGlzIHVzZWRcbiAgICBuZXdTY2FsZSA9IE1hdGgubWF4KHRoaXMubWluU2NhbGUsIE1hdGgubWluKCB0aGlzLm1heFNjYWxlLCBuZXdTY2FsZSApKTtcbiAgICB0aGlzLnNjYWxlID0gbmV3U2NhbGU7XG5cbiAgICBsZXQgdGFyZ2V0UG9pbnQ6IFBvaW50ID0ge1xuICAgICAgLy8gVGhlIHRhcmdldCBwb2ludCB0byB6b29tIHRvLiAgSXQgbXVzdCBzdGF5IHRoZSBzYW1lIGFzIHRoZSB1bnRyYW5zbGF0ZWQgcG9pbnRcbiAgICAgIHg6IGNsaWNrUG9pbnQueCAtIChuZXdTY2FsZSAvIGN1cnJlbnRTY2FsZSkgKiAoY2xpY2tQb2ludC54IC0gY3VycmVudFBhbi54KSxcbiAgICAgIHk6IGNsaWNrUG9pbnQueSAtIChuZXdTY2FsZSAvIGN1cnJlbnRTY2FsZSkgKiAoY2xpY2tQb2ludC55IC0gY3VycmVudFBhbi55KVxuICAgIH07XG5cbiAgICAvLyBBcHBseSBQYW4gJiBTY2FsZVxuICAgIGxldCB0cmFuc2xhdGUzZCA9IGB0cmFuc2xhdGUzZCgke3RhcmdldFBvaW50Lnh9cHgsICR7dGFyZ2V0UG9pbnQueX1weCwgMClgO1xuICAgIHRoaXMucGFuRWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zbGF0ZTNkO1xuICAgIGxldCBzY2FsZVN0cmluZyA9IGBzY2FsZSgke3RoaXMuc2NhbGV9KWA7XG4gICAgdGhpcy56b29tRWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwIDAnO1xuICAgIHRoaXMuem9vbUVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBzY2FsZVN0cmluZztcblxuICAgIGlmICh0aGlzLmlzQ2hyb21lKSB7XG4gICAgICBpZiAodGhpcy53aWxsQ2hhbmdlTmV4dEZyYW1lKSB7XG4gICAgICAgICg8YW55PnRoaXMuYWNjZWxlcmF0ZWRGcmFtZVJlZi5uYXRpdmVFbGVtZW50LnN0eWxlKS53aWxsQ2hhbmdlID0gJ2F1dG8nO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICg8YW55PnRoaXMuYWNjZWxlcmF0ZWRGcmFtZVJlZi5uYXRpdmVFbGVtZW50LnN0eWxlKS53aWxsQ2hhbmdlID0gJ3RyYW5zZm9ybSc7XG4gICAgICB9XG4gICAgICB0aGlzLndpbGxDaGFuZ2VOZXh0RnJhbWUgPSAhdGhpcy53aWxsQ2hhbmdlTmV4dEZyYW1lO1xuICAgIH1cblxuICAgIHRoaXMubW9kZWwucGFuLnggPSB0YXJnZXRQb2ludC54O1xuICAgIHRoaXMubW9kZWwucGFuLnkgPSB0YXJnZXRQb2ludC55O1xuICAgIHRoaXMubW9kZWwuem9vbUxldmVsID0gdGhpcy5nZXRab29tTGV2ZWwodGhpcy5zY2FsZSk7XG4gICAgdGhpcy5zeW5jQmFzZVRvTW9kZWwoKTtcbiAgICB0aGlzLmNvbmZpZy5tb2RlbENoYW5nZWQubmV4dCh0aGlzLm1vZGVsKTtcbiAgICAvLyBjb25zb2xlLmxvZyhgUGFuWm9vbUNvbXBvbmVudDogZnJlZVpvb20oKTogYmFzZUFmdGVyWm9vbTogeDogJHt0aGlzLmJhc2UucGFuLnh9IHk6ICR7dGhpcy5iYXNlLnBhbi55fSB6b29tbGV2ZWw6ICR7dGhpcy5iYXNlLnpvb21MZXZlbH1gICk7XG4gICAgLy8gY29uc29sZS5sb2coJ3pvb21MZXZlbDonLCB0aGlzLmJhc2Uuem9vbUxldmVsKTtcbiAgfVxuXG5cblxuXG5cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vLy8vLy8vLy8vLy8vLy8gSEVMUEVSIEZVTkNUSU9OUyAvLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cblxuICBwcml2YXRlIGlzTW9iaWxlRGV2aWNlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAodHlwZW9mIHdpbmRvdy5vcmllbnRhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHx8IChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0lFTW9iaWxlJykgIT09IC0xKTtcbiAgfVxuXG5cblxuXG4gIHByaXZhdGUgc3luY0Jhc2VUb01vZGVsKCkge1xuICAgIHRoaXMuYmFzZS5wYW4ueCA9IHRoaXMubW9kZWwucGFuLng7XG4gICAgdGhpcy5iYXNlLnBhbi55ID0gdGhpcy5tb2RlbC5wYW4ueTtcbiAgICB0aGlzLmJhc2Uuem9vbUxldmVsID0gdGhpcy5tb2RlbC56b29tTGV2ZWw7XG4gIH1cblxuXG5cbiAgcHJpdmF0ZSBsZW5ndGgodmVjdG9yMmQ6IGFueSkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdQYW5ab29tQ29tcG9uZW50OiBsZW5ndGgoKScpO1xuICAgIHJldHVybiBNYXRoLnNxcnQodmVjdG9yMmQueCAqIHZlY3RvcjJkLnggKyB2ZWN0b3IyZC55ICogdmVjdG9yMmQueSk7XG4gIH1cblxuXG5cbiAgcHJpdmF0ZSBnZXRDZW50ZXJQb2ludCgpOiBQb2ludCB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IGdldENlbnRlclBvaW50KCknKTtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogZ2V0Q2VudGVyUG9pbnQoKTogcHJvamVjdGVkQ29udGVudFJlZjonLCB0aGlzLnByb2plY3RlZENvbnRlbnRSZWYpO1xuICAgIGxldCBjZW50ZXIgPSB7XG4gICAgICAvLyB4OiB0aGlzLmpRdWVyeUZyYW1lRWxlbWVudC53aWR0aCgpIC8gMixcbiAgICAgIHg6IHRoaXMuZnJhbWVFbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGggLyAyLFxuICAgICAgLy8geDogdGhpcy5wcm9qZWN0ZWRDb250ZW50UmVmLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGggLyAyLFxuICAgICAgLy8geTogdGhpcy5qUXVlcnlGcmFtZUVsZW1lbnQuaGVpZ2h0KCkgLyAyXG4gICAgICB5OiB0aGlzLmZyYW1lRWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm9mZnNldEhlaWdodCAvIDJcbiAgICAgIC8vIHk6IHRoaXMucHJvamVjdGVkQ29udGVudFJlZi5uYXRpdmVFbGVtZW50Lm9mZnNldEhlaWdodCAvIDJcbiAgICB9O1xuICAgIHJldHVybiBjZW50ZXI7XG4gIH1cblxuXG5cbiAgcHJpdmF0ZSBnZXRDc3NTY2FsZSh6b29tTGV2ZWw6IGFueSk6IG51bWJlciB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IGdldENzc1NjYWxlKCknKTtcbiAgICByZXR1cm4gTWF0aC5wb3codGhpcy5jb25maWcuc2NhbGVQZXJab29tTGV2ZWwsIHpvb21MZXZlbCAtIHRoaXMuY29uZmlnLm5ldXRyYWxab29tTGV2ZWwpO1xuICB9XG5cblxuXG4gIHByaXZhdGUgZ2V0Wm9vbUxldmVsKGNzc1NjYWxlOiBhbnkpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogZ2V0Wm9vbUxldmVsKCknKTtcbiAgICByZXR1cm4gTWF0aC5sb2cxMChjc3NTY2FsZSkgLyBNYXRoLmxvZzEwKHRoaXMuY29uZmlnLnNjYWxlUGVyWm9vbUxldmVsKSArIHRoaXMuY29uZmlnLm5ldXRyYWxab29tTGV2ZWw7XG4gIH1cblxuXG5cbiAgcHJpdmF0ZSBjYWxjWm9vbVRvRml0KHJlY3Q6IFJlY3QpOiBQYW5ab29tTW9kZWwge1xuICAgIC8vIGNvbnNvbGUubG9nKCdQYW5ab29tQ29tcG9uZW50OiBjYWxjWm9vbVRvRml0KCk6IHJlY3Q6JywgcmVjdCk7XG4gICAgLy8gbGV0IChXLCBIKSBkZW5vdGUgdGhlIHNpemUgb2YgdGhlIHZpZXdwb3J0XG4gICAgLy8gbGV0ICh3LCBoKSBkZW5vdGUgdGhlIHNpemUgb2YgdGhlIHJlY3RhbmdsZSB0byB6b29tIHRvXG4gICAgLy8gdGhlbiB3ZSBtdXN0IENTUyBzY2FsZSBieSB0aGUgbWluIG9mIFcvdyBhbmQgSC9oIGluIG9yZGVyIHRvIGp1c3QgZml0IHRoZSByZWN0YW5nbGVcbiAgICAvLyByZXR1cm5zIHRoZSB0YXJnZXQgbGVmdCBhbmQgdG9wIGNvb3JkaW5hdGVzIGZvciB0aGUgcGFuRWxlbWVudCBhbmQgdGFyZ2V0IHpvb21MZXZlbFxuXG4gICAgbGV0IHZpZXdwb3J0V2lkdGggPSB0aGlzLmZyYW1lRWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgIGxldCB2aWV3cG9ydEhlaWdodCA9IHRoaXMuZnJhbWVFbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXG4gICAgbGV0IHRhcmdldFdpZHRoID0gcmVjdC53aWR0aDtcbiAgICBsZXQgdGFyZ2V0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG5cbiAgICBsZXQgY3NzU2NhbGVFeGFjdCA9IE1hdGgubWluKCB2aWV3cG9ydFdpZHRoIC8gdGFyZ2V0V2lkdGgsIHZpZXdwb3J0SGVpZ2h0IC8gdGFyZ2V0SGVpZ2h0ICk7XG4gICAgbGV0IHpvb21MZXZlbEV4YWN0ID0gdGhpcy5nZXRab29tTGV2ZWwoY3NzU2NhbGVFeGFjdCk7XG4gICAgbGV0IHpvb21MZXZlbCA9IHpvb21MZXZlbEV4YWN0ICogdGhpcy5jb25maWcuem9vbVRvRml0Wm9vbUxldmVsRmFjdG9yO1xuICAgIGxldCBjc3NTY2FsZSA9IHRoaXMuZ2V0Q3NzU2NhbGUoem9vbUxldmVsKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHpvb21MZXZlbDogem9vbUxldmVsLFxuICAgICAgICBwYW46IHtcbiAgICAgICAgICAgIHg6IC1yZWN0LnggKiBjc3NTY2FsZSArICh2aWV3cG9ydFdpZHRoIC0gdGFyZ2V0V2lkdGggKiBjc3NTY2FsZSkgLyAyLFxuICAgICAgICAgICAgeTogLXJlY3QueSAqIGNzc1NjYWxlICsgKHZpZXdwb3J0SGVpZ2h0IC0gdGFyZ2V0SGVpZ2h0ICogY3NzU2NhbGUpIC8gMlxuICAgICAgICB9XG4gICAgfTtcbiAgfVxuXG5cblxuICBwcml2YXRlIHpvb21Ub0ZpdE1vZGVsKHRhcmdldDogUGFuWm9vbU1vZGVsLCBkdXJhdGlvbjogbnVtYmVyID0gbnVsbCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdQYW5ab29tQ29tcG9uZW50OiB6b29tVG9GaXRNb2RlbCgpOiB0YXJnZXQ6JywgdGFyZ2V0KTtcblxuICAgIC8vIHRhcmdldC5wYW4ueCBpcyB0aGUgcGFuRWxlbWVudCBsZWZ0IHN0eWxlIHByb3BlcnR5XG4gICAgLy8gdGFyZ2V0LnBhbi55IGlzIHRoZSBwYW5FbGVtZW50IHRvcCBzdHlsZSBwcm9wZXJ0eVxuICAgIHRoaXMuYW5pbWF0ZVRvVGFyZ2V0KHRhcmdldCwgZHVyYXRpb24pO1xuICB9XG5cblxuXG4gIHByaXZhdGUgem9vbVRvTGV2ZWxBbmRQb2ludChsZXZlbDogbnVtYmVyLCBjbGlja1BvaW50OiBQb2ludCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdQYW5ab29tQ29tcG9uZW50OiB6b29tVG9MZXZlbEFuZFBvaW50KCk6IGxldmVsOicsIGxldmVsKTtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogem9vbVRvTGV2ZWxBbmRQb2ludCgpOiBjbGlja1BvaW50OicsIGNsaWNrUG9pbnQpO1xuICAgIHRoaXMuY2hhbmdlWm9vbUxldmVsKCBsZXZlbCwgY2xpY2tQb2ludCApO1xuICB9XG5cblxuXG4gIHByaXZhdGUgem9vbUluVG9MYXN0Q2xpY2tQb2ludCgpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogem9vbUluVG9MYXN0Q2xpY2tQb2ludCgpOiBsYXN0Q2xpY2tQb2ludCcsIHRoaXMubGFzdENsaWNrUG9pbnQpO1xuICAgIHRoaXMuY2hhbmdlWm9vbUxldmVsKCB0aGlzLmJhc2Uuem9vbUxldmVsICsgdGhpcy5jb25maWcuem9vbUJ1dHRvbkluY3JlbWVudCwgdGhpcy5sYXN0Q2xpY2tQb2ludCApO1xuICB9XG5cblxuXG4gIHByaXZhdGUgem9vbU91dEZyb21MYXN0Q2xpY2tQb2ludCgpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogem9vbU91dEZyb21MYXN0Q2xpY2tQb2ludCgpJyk7XG4gICAgdGhpcy5jaGFuZ2Vab29tTGV2ZWwoIHRoaXMuYmFzZS56b29tTGV2ZWwgLSB0aGlzLmNvbmZpZy56b29tQnV0dG9uSW5jcmVtZW50LCB0aGlzLmxhc3RDbGlja1BvaW50ICk7XG4gIH1cblxuXG5cbiAgcHJpdmF0ZSBzdGFydEFuaW1hdGlvbigpIHtcbiAgICB0aGlzLmxhc3RUaWNrID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCAoKSA9PiB0aGlzLmFuaW1hdGlvbklkID0gdGhpcy5hbmltYXRpb25GcmFtZUZ1bmModGhpcy5hbmltYXRpb25UaWNrKSApO1xuICB9XG5cblxuXG5cblxuXG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vIEFQSSBNRVRIT0RTIC8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG5cbiAgcHJpdmF0ZSBnZXRWaWV3UG9zaXRpb24obW9kZWxQb3NpdGlvbjogUG9pbnQpOiBQb2ludCB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IGdldFZpZXdQb3NpdGlvbigpJyk7XG4gICAgLy8gcCcgPSBwICogcyArIHRcbiAgICAvLyB2aWV3UG9zaXRpb24gPSBtb2RlbFBvc2l0aW9uICogc2NhbGUgKyBiYXNlUGFuXG5cbiAgICBsZXQgc2NhbGUsIHRyYW5zbGF0aW9uO1xuXG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uUGFyYW1zKSB7XG4gICAgICBzY2FsZSA9IHRoaXMuZ2V0Q3NzU2NhbGUodGhpcy5iYXNlLnpvb21MZXZlbCArIHRoaXMuYW5pbWF0aW9uUGFyYW1zLmRlbHRhWm9vbUxldmVsICogdGhpcy5hbmltYXRpb25QYXJhbXMucHJvZ3Jlc3MpO1xuICAgICAgbGV0IGRlbHRhVHJhbnNsYXRpb24gPSB0aGlzLmFuaW1hdGlvblBhcmFtcy5wYW5TdGVwRnVuYyh0aGlzLm1vZGVsLnpvb21MZXZlbCk7XG4gICAgICB0cmFuc2xhdGlvbiA9IHsgeDogdGhpcy5iYXNlLnBhbi54ICsgZGVsdGFUcmFuc2xhdGlvbi54LCB5OiB0aGlzLmJhc2UucGFuLnkgKyBkZWx0YVRyYW5zbGF0aW9uLnkgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzY2FsZSA9IHRoaXMuZ2V0Q3NzU2NhbGUodGhpcy5iYXNlLnpvb21MZXZlbCk7XG4gICAgICB0cmFuc2xhdGlvbiA9IHRoaXMuYmFzZS5wYW47XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IG1vZGVsUG9zaXRpb24ueCAqIHNjYWxlICsgdHJhbnNsYXRpb24ueCxcbiAgICAgIHk6IG1vZGVsUG9zaXRpb24ueSAqIHNjYWxlICsgdHJhbnNsYXRpb24ueVxuICAgIH07XG4gIH1cblxuXG5cbiAgcHJpdmF0ZSBnZXRNb2RlbFBvc2l0aW9uKHZpZXdQb3NpdGlvbjogUG9pbnQpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogZ2V0TW9kZWxQb3NpdGlvbigpJyk7XG4gICAgLy8gcCA9ICgxL3MpKHAnIC0gdClcbiAgICBsZXQgcG1hcmsgPSB2aWV3UG9zaXRpb247XG4gICAgbGV0IHMgPSB0aGlzLmdldENzc1NjYWxlKHRoaXMuYmFzZS56b29tTGV2ZWwpO1xuICAgIGxldCB0ID0gdGhpcy5iYXNlLnBhbjtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiAoMSAvIHMpICogKHBtYXJrLnggLSB0LngpLFxuICAgICAgeTogKDEgLyBzKSAqIChwbWFyay55IC0gdC55KVxuICAgIH07XG4gIH1cblxuXG5cbiAgcHJpdmF0ZSByZXNldFZpZXcoKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IHJlc2V0VmlldygpJyk7XG4gICAgaWYgKHRoaXMuY29uZmlnLmluaXRpYWxab29tVG9GaXQpIHtcbiAgICAgIHRoaXMuem9vbVRvRml0KHRoaXMuY29uZmlnLmluaXRpYWxab29tVG9GaXQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmNvbmZpZy5pbml0aWFsUGFuWCAhPT0gbnVsbCAmJiB0aGlzLmNvbmZpZy5pbml0aWFsUGFuWSAhPT0gbnVsbCAmJiB0aGlzLmNvbmZpZy5pbml0aWFsWm9vbUxldmVsICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnpvb21Ub0ZpdE1vZGVsKFxuICAgICAgICB7XG4gICAgICAgICAgem9vbUxldmVsOiB0aGlzLmNvbmZpZy5pbml0aWFsWm9vbUxldmVsLFxuICAgICAgICAgIHBhbjoge1xuICAgICAgICAgICAgeDogdGhpcy5jb25maWcuaW5pdGlhbFBhblgsXG4gICAgICAgICAgICB5OiB0aGlzLmNvbmZpZy5pbml0aWFsUGFuWVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdQYW5ab29tQ29tcG9uZW50OiByZXNldFZpZXcoKSBjb3VsZCBub3QgcmVzZXQgdmlldyBhcyBzb21lIHZhcnMgd2VyZSBub3Qgc2V0LiAgVGhlIGN1bHByaXRzIGFyZSBlaXRoZXIgY29uZmlnLmluaXRpYWxab29tTGV2ZWwsIGNvbmZpZy5pbml0aWFsUGFuWCwgb3IgY29uZmlnLmluaXRpYWxQYW5ZLiAgT3IganVzdCBzZXQgcGFuem9vbUNvbmZpZy5pbml0aWFsWm9vbVRvRml0Jyk7XG4gICAgICBjb25zb2xlLmxvZygnY29uZmlnLmluaXRpYWxab29tTGV2ZWw6ICcgKyB0aGlzLmNvbmZpZy5pbml0aWFsWm9vbUxldmVsKTtcbiAgICAgIGNvbnNvbGUubG9nKCdjb25maWcuaW5pdGlhbFBhblg6ICcgKyB0aGlzLmNvbmZpZy5pbml0aWFsUGFuWCk7XG4gICAgICBjb25zb2xlLmxvZygnY29uZmlnLmluaXRpYWxQYW5ZOiAnICsgdGhpcy5jb25maWcuaW5pdGlhbFBhblkpO1xuICAgIH1cbiAgfVxuXG5cblxuICBwcml2YXRlIHpvb21Ub0ZpdChyZWN0YW5nbGU6IFJlY3QsIGR1cmF0aW9uOiBudW1iZXIgPSBudWxsKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IHpvb21Ub0ZpdCgpOiByZWN0YW5nbGUnLCByZWN0YW5nbGUpO1xuXG4gICAgLy8gd2hlbiBhIHVzZXIgY2xpY2tzIGEgem9vbSB0byBmaXQgYnV0dG9uXG4gICAgLy8gZXhhbXBsZSByZWN0YW5nbGU6IHsgXCJ4XCI6IDAsIFwieVwiOiAxMDAsIFwid2lkdGhcIjogMTAwLCBcImhlaWdodFwiOiAxMDAgfVxuXG4gICAgbGV0IHRhcmdldDogUGFuWm9vbU1vZGVsID0gdGhpcy5jYWxjWm9vbVRvRml0KHJlY3RhbmdsZSk7XG4gICAgLy8gdGFyZ2V0LnBhbi54IGlzIHRoZSBwYW5FbGVtZW50IGxlZnQgc3R5bGUgcHJvcGVydHlcbiAgICAvLyB0YXJnZXQucGFuLnkgaXMgdGhlIHBhbkVsZW1lbnQgdG9wIHN0eWxlIHByb3BlcnR5XG4gICAgdGhpcy5hbmltYXRlVG9UYXJnZXQodGFyZ2V0LCBkdXJhdGlvbik7XG4gIH1cblxuXG5cbiAgcHJpdmF0ZSB6b29tSW4oY2xpY2tQb2ludDogUG9pbnQpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogem9vbUluKCk6IGNsaWNrUG9pbnQ6JywgY2xpY2tQb2ludCk7XG4gICAgdGhpcy5jaGFuZ2Vab29tTGV2ZWwoIHRoaXMuYmFzZS56b29tTGV2ZWwgKyB0aGlzLmNvbmZpZy56b29tQnV0dG9uSW5jcmVtZW50LCBjbGlja1BvaW50ICk7XG4gIH1cblxuXG5cbiAgcHJpdmF0ZSB6b29tT3V0KGNsaWNrUG9pbnQ6IFBvaW50KSB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IHpvb21PdXQoKScpO1xuICAgIHRoaXMuY2hhbmdlWm9vbUxldmVsKCB0aGlzLmJhc2Uuem9vbUxldmVsIC0gdGhpcy5jb25maWcuem9vbUJ1dHRvbkluY3JlbWVudCwgY2xpY2tQb2ludCApO1xuICB9XG5cblxuXG4gIHByaXZhdGUgcGFuVG9Qb2ludChwb2ludDogUG9pbnQsIGR1cmF0aW9uOiBudW1iZXIgPSBudWxsKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ1Bhblpvb21Db21wb25lbnQ6IHBhblRvUG9pbnQoKTogcG9pbnQ6JywgcG9pbnQpO1xuXG4gICAgLy8gQVBJIGNhbGwgdG8gYW5pbWF0ZSB0aGUgdmlldyBzbyB0aGF0IHRoZSBjZW50cmUgcG9pbnQgb2YgdGhlIHZpZXcgaXMgYXQgdGhlXG4gICAgLy8gcG9pbnQgcGFyYW1ldGVyIGNvb3JkaW5hdGVzLCByZWxhdGl2ZSB0byB0aGUgb3JpZ2luYWwsIHVuem9vbWVkXG4gICAgLy8gY29udGVudCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgLy8gZXhhbXBsZSBwb2ludDogeyBcInhcIjogMCwgXCJ5XCI6IDAgfSAvLyBtYWtlcyB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSBjb250ZW50XG4gICAgLy8gdGhlIGNlbnRyZSBvZiB0aGUgdmlld1xuXG4gICAgbGV0IHRhcmdldDogUGFuWm9vbU1vZGVsID0ge1xuICAgICAgcGFuOiB7XG4gICAgICAgIHg6ICggKHRoaXMuZnJhbWVXaWR0aCAvIDIpICkgLSBwb2ludC54ICogdGhpcy5zY2FsZSxcbiAgICAgICAgeTogKCAodGhpcy5mcmFtZUhlaWdodCAvIDIpICkgLSBwb2ludC55ICogdGhpcy5zY2FsZVxuICAgICAgfSxcbiAgICAgIHpvb21MZXZlbDogdGhpcy5iYXNlLnpvb21MZXZlbFxuICAgIH07XG5cbiAgICB0aGlzLmFuaW1hdGVUb1RhcmdldCh0YXJnZXQsIGR1cmF0aW9uKTtcbiAgfVxuXG5cblxuICBwcml2YXRlIHBhbkRlbHRhKGRlbHRhOiBQb2ludCwgZHVyYXRpb246IG51bWJlciA9IG51bGwpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogcGFuRGVsdGEoKTogZGVsdGE6JywgZGVsdGEpO1xuXG4gICAgLy8gQVBJIGNhbGwgdG8gcGFuIHRoZSB2aWV3IGxlZnQsIHJpZ2h0LCB1cCwgb3IgZG93biwgYmFzZWQgb24gYSBudW1iZXIgb2YgcGl4ZWxzXG4gICAgLy8gb2YgdGhlIG9yaWdpbmFsLCB1bnpvb21lZCBjb250ZW50LlxuICAgIC8vIFBvc2l0aXZlIGlzIHJpZ2h0IGFuZCBkb3duXG4gICAgLy8gTmVnYXRpdmUgaXMgbGVmdCBhbmQgdXBcbiAgICAvLyBleGFtcGxlIHBvaW50OiB7IFwieFwiOiAxMDAsIFwieVwiOiAtNTAgfSAvLyBtb3ZlcyB0aGUgdmlldyByaWdodCA1MHB4IGFuZCB1cCA1MHB4XG5cbiAgICBsZXQgdGFyZ2V0OiBQYW5ab29tTW9kZWwgPSB7XG4gICAgICBwYW46IHtcbiAgICAgICAgeDogdGhpcy5iYXNlLnBhbi54IC0gdGhpcy5zY2FsZSAqIGRlbHRhLngsXG4gICAgICAgIHk6IHRoaXMuYmFzZS5wYW4ueSAtIHRoaXMuc2NhbGUgKiBkZWx0YS55XG4gICAgICB9LFxuICAgICAgem9vbUxldmVsOiB0aGlzLmJhc2Uuem9vbUxldmVsXG4gICAgfTtcbiAgICB0aGlzLmFuaW1hdGVUb1RhcmdldCh0YXJnZXQsIGR1cmF0aW9uKTtcbiAgfVxuXG5cblxuICBwcml2YXRlIHBhbkRlbHRhQWJzb2x1dGUoZGVsdGE6IFBvaW50LCBkdXJhdGlvbjogbnVtYmVyID0gbnVsbCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdQYW5ab29tQ29tcG9uZW50OiBwYW5EZWx0YUFic29sdXRlKCk6IGRlbHRhOicsIGRlbHRhKTtcblxuICAgIC8vIEFQSSBjYWxsIHRvIHBhbiB0aGUgdmlldyBsZWZ0LCByaWdodCwgdXAsIG9yIGRvd24sIGJhc2VkIG9uIGEgbnVtYmVyIG9mIHBpeGVsc1xuICAgIC8vIFRoaXMgbWV0aG9kIGRvZXNuJ3QgYWRqdXN0IGZvciBzY2FsZS4gIEknbSBub3Qgc3VyZSB3aHkgeW91J2Qgd2FudCB0aGlzXG4gICAgLy8gYnV0IGhhdmUgaXQgaGVyZSBqdXN0IGluIGNhc2Ugc29tZW9uZSBuZWVkcyBpdFxuICAgIC8vIFBvc2l0aXZlIGlzIHJpZ2h0IGFuZCBkb3duXG4gICAgLy8gTmVnYXRpdmUgaXMgbGVmdCBhbmQgdXBcbiAgICAvLyBleGFtcGxlIHBvaW50OiB7IFwieFwiOiAxMDAsIFwieVwiOiAtNTAgfSAvLyBtb3ZlcyB0aGUgdmlldyByaWdodCA1MHB4IGFuZCB1cCA1MHB4XG5cbiAgICBsZXQgdGFyZ2V0OiBQYW5ab29tTW9kZWwgPSB7XG4gICAgICBwYW46IHtcbiAgICAgICAgeDogdGhpcy5iYXNlLnBhbi54IC0gZGVsdGEueCxcbiAgICAgICAgeTogdGhpcy5iYXNlLnBhbi55IC0gZGVsdGEueVxuICAgICAgfSxcbiAgICAgIHpvb21MZXZlbDogdGhpcy5iYXNlLnpvb21MZXZlbFxuICAgIH07XG4gICAgdGhpcy5hbmltYXRlVG9UYXJnZXQodGFyZ2V0LCBkdXJhdGlvbik7XG4gIH1cblxuXG5cbiAgcHJpdmF0ZSBwYW5EZWx0YVBlcmNlbnQoZGVsdGFQZXJjZW50OiBQb2ludCwgZHVyYXRpb246IG51bWJlciA9IG51bGwpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogcGFuRGVsdGFQZXJjZW50KCk6IGRlbHRhUGVyY2VudDonLCBkZWx0YVBlcmNlbnQpO1xuXG4gICAgLy8gQVBJIGNhbGwgdG8gcGFuIHRoZSB2aWV3IHVwLCBkb3duLCBsZWZ0LCBvciByaWdodCwgYmFzZWQgb24gYSBwZXJjZW50YWdlXG4gICAgLy8gb2YgdGhlIG9yaWdpbmFsLCB1bnpvb21lZCBjb250ZW50IHdpZHRoIGFuZCBoZWlnaHRcbiAgICAvLyBleGFtcGxlIHBvaW50OiB7IFwieFwiOiAxMCwgXCJ5XCI6IC0yMCB9XG5cbiAgICBsZXQgZGVsdGFYID0gMDtcbiAgICBsZXQgZGVsdGFZID0gMDtcbiAgICBpZiAoZGVsdGFQZXJjZW50LnggIT09IDApIHtcbiAgICAgIGRlbHRhWCA9IHRoaXMuY29udGVudFdpZHRoICogKCBkZWx0YVBlcmNlbnQueCAvIDEwMCApICogdGhpcy5zY2FsZTtcbiAgICB9XG4gICAgaWYgKGRlbHRhUGVyY2VudC55ICE9PSAwKSB7XG4gICAgICBkZWx0YVkgPSB0aGlzLmNvbnRlbnRIZWlnaHQgKiAoIGRlbHRhUGVyY2VudC55IC8gMTAwICkgKiB0aGlzLnNjYWxlO1xuICAgIH1cblxuICAgIGxldCB0YXJnZXQ6IFBhblpvb21Nb2RlbCA9IHtcbiAgICAgIHBhbjoge1xuICAgICAgICB4OiB0aGlzLmJhc2UucGFuLnggLSBkZWx0YVgsXG4gICAgICAgIHk6IHRoaXMuYmFzZS5wYW4ueSAtIGRlbHRhWVxuICAgICAgfSxcbiAgICAgIHpvb21MZXZlbDogdGhpcy5iYXNlLnpvb21MZXZlbFxuICAgIH07XG4gICAgLy8gdGFyZ2V0LnBhbi54IGlzIHRoZSBwYW5FbGVtZW50IGxlZnQgc3R5bGUgcHJvcGVydHlcbiAgICAvLyB0YXJnZXQucGFuLnkgaXMgdGhlIHBhbkVsZW1lbnQgdG9wIHN0eWxlIHByb3BlcnR5XG4gICAgdGhpcy5hbmltYXRlVG9UYXJnZXQodGFyZ2V0LCBkdXJhdGlvbik7XG4gIH1cblxuXG5cblxuXG5cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyBBTklNQVRJT04gQlVJTERFUlMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cblxuICBwcml2YXRlIGFuaW1hdGVUb1RhcmdldCh0YXJnZXRNb2RlbDogUGFuWm9vbU1vZGVsLCBkdXJhdGlvbiA9IG51bGwpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnUGFuWm9vbUNvbXBvbmVudDogYW5pbWF0ZVRvVGFyZ2V0KCknKTtcbiAgICAvLyB3aGF0IHRoaXMgZnVuY3Rpb24gcmVhbGx5IGRvZXMgaXMgdGFrZSBhIHRhcmdldCBtb2RlbCwgYW5kIHRoZW4gc2V0c1xuICAgIC8vIHRoaXMuYW5pbWF0aW9uUGFyYW1zIHdpdGggdGhlIHBhcmFtZXRlcnMgZm9yIHRoZSB3aG9sZSBhbmltYXRpb24sXG4gICAgLy8gbmFtZWx5IHRoZSBkZWx0YSB6b29tTGV2ZWxcbiAgICAvLyBpdCBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIGNhbGxlciB0byBraWNrIG9mZiB0aGUgYW5pbWF0aW9uIHdpdGggYSBjYWxsIHRvIGFuaW1hdGlvbkZyYW1lRnVuYygpXG5cbiAgICBpZiAodGhpcy5hbmltYXRpb25QYXJhbXMpIHtcbiAgICAgIC8vIG1ha2UgdGhlIHVzZXIgd2FpdCBmb3IgZXhpc3RpbmcgYW5pbWF0aW9uIHRvIGZpbmlzaCBiZWZvcmUgY2xpY2tpbmdcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnpvb21MZXZlbElzQ2hhbmdpbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5iYXNlLnpvb21MZXZlbCAhPT0gdGFyZ2V0TW9kZWwuem9vbUxldmVsKSB7XG4gICAgICB0aGlzLnpvb21MZXZlbElzQ2hhbmdpbmcgPSB0cnVlO1xuICAgIH1cblxuICAgIGxldCBkZWx0YVpvb21MZXZlbCA9IHRhcmdldE1vZGVsLnpvb21MZXZlbCAtIHRoaXMuYmFzZS56b29tTGV2ZWw7IC8vIGRlbHRhWm9vbUxldmVsIGlzIHRoZSBudW1iZXIgb2Ygem9vbSBsZXZlbHMgd2UgYXJlIGNoYW5naW5nIGhlcmVcblxuICAgIGxldCBvbGRCYXNlOiBQb2ludCA9IHtcbiAgICAgIC8vIHRoZSBjdXJyZW50IGJhc2UgY29vcmRpbmF0ZXNcbiAgICAgIHg6IHRoaXMuYmFzZS5wYW4ueCxcbiAgICAgIHk6IHRoaXMuYmFzZS5wYW4ueVxuICAgIH07XG4gICAgdGhpcy5tb2RlbC5wYW4ueCA9IHRoaXMuYmFzZS5wYW4ueDtcbiAgICB0aGlzLm1vZGVsLnBhbi55ID0gdGhpcy5iYXNlLnBhbi55O1xuICAgIC8qdGhpcy5sYXN0Q2xpY2tQb2ludCA9IHtcbiAgICAgIHg6IHRoaXMuYmFzZS5wYW4ueCxcbiAgICAgIHk6IHRoaXMuYmFzZS5wYW4ueVxuICAgIH07Ki9cblxuICAgIGxldCBwYW5TdGVwRnVuYyA9ICh6b29tTGV2ZWw6IG51bWJlcikgPT4ge1xuICAgICAgLy8gdGhpcyBmdW5jdGlvbiBnZXRzIGNhbGxlZCBkdXJpbmcgZXZlcnkgYW5pbWF0aW9uIHRpY2sgaW4gdXBkYXRlRE9NKCksIHRvIGNhbGN1bGF0ZSB3aGVyZSB0byBtb3ZlIHRoZSBtb2RlbCBwYW4gY29vcmRpbmF0ZXMgdG8gKGkuZS4gdGhlIHRyYW5zbGF0aW9uKSBmb3IgdGhhdCB0aWNrLCB6b29tTGV2ZWwgaXMgaWdub3JlZCB3aXRoaW4gYW5pbWF0ZVRvVGFyZ2V0KClcbiAgICAgIGxldCB0YXJnZXRQb2ludDogUG9pbnQgPSB7XG4gICAgICAgIC8vIFRoZSB0YXJnZXQgcG9pbnQgdG8gem9vbSB0byBmb3IgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGZyYW1lLiAgSXQgbXVzdCBzdGF5IHRoZSBzYW1lIGFzIHRoZSB1bnRyYW5zbGF0ZWQgcG9pbnRcbiAgICAgICAgeDogKG9sZEJhc2UueCAtIHRhcmdldE1vZGVsLnBhbi54KSAqIHRoaXMuYW5pbWF0aW9uUGFyYW1zLnByb2dyZXNzLFxuICAgICAgICB5OiAob2xkQmFzZS55IC0gdGFyZ2V0TW9kZWwucGFuLnkpICogdGhpcy5hbmltYXRpb25QYXJhbXMucHJvZ3Jlc3NcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7IHg6IC10YXJnZXRQb2ludC54LCB5OiAtdGFyZ2V0UG9pbnQueSB9O1xuICAgIH07XG5cbiAgICAvLyBub3cgc2V0IHRoZSBwYXJhbWV0ZXJzIG9mIG91ciBuZXcgYW5pbWF0aW9uXG4gICAgaWYgKGR1cmF0aW9uKSB7XG4gICAgICBkdXJhdGlvbiA9IGR1cmF0aW9uICogMTAwMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBkdXJhdGlvbiA9IHRoaXMuY29uZmlnLnpvb21TdGVwRHVyYXRpb24gKiAxMDAwO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvblBhcmFtcyA9IHtcbiAgICAgIGRlbHRhWm9vbUxldmVsOiBkZWx0YVpvb21MZXZlbCwgLy8gaG93IG1hbnkgem9vb20gbGV2ZWxzIHRvIHpvb20gaW4gb3Igb3V0XG4gICAgICBwYW5TdGVwRnVuYzogcGFuU3RlcEZ1bmMsIC8vIGEgZnVuY3Rpb24gd2hpY2ggcnVucyBvbiBldmVyeSBhbmltYXRpb24gdGljaywgd2hpY2ggY2FsY3MgaG93IG11Y2ggdG8gcGFuIHRoZSB2aWV3IG9uIGV2ZXJ5IGZyYW1lXG4gICAgICAvLyBkdXJhdGlvbjogZHVyYXRpb24gfHwgdGhpcy5jb25maWcuem9vbVN0ZXBEdXJhdGlvbiwgLy8gaG93IGxvbmcgdGhlIGFuaW1hdGlvbiBzaG91bGQgdGFrZVxuICAgICAgZHVyYXRpb246IGR1cmF0aW9uLCAvLyBob3cgbG9uZyB0aGUgYW5pbWF0aW9uIHNob3VsZCB0YWtlXG4gICAgICBwcm9ncmVzczogMC4wXG4gICAgfTtcblxuICAgIHRoaXMuc3RhcnRBbmltYXRpb24oKTtcblxuICB9XG5cblxuXG4gIHByaXZhdGUgY2hhbmdlWm9vbUxldmVsKG5ld1pvb21MZXZlbDogbnVtYmVyLCBjbGlja1BvaW50OiBQb2ludCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdQYW5ab29tQ29tcG9uZW50OiBjaGFuZ2Vab29tTGV2ZWwoKScpO1xuXG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uUGFyYW1zKSB7XG4gICAgICAvLyBsZXQncyBsZXQgYW55IGN1cnJlbnQgYW5pbWF0aW9uIGp1c3QgZmluaXNoXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy56b29tTGV2ZWxJc0NoYW5naW5nID0gdHJ1ZTtcblxuICAgIC8vIGtlZXAgem9vbSBsZXZlbCBpbiBib3VuZHNcbiAgICBuZXdab29tTGV2ZWwgPSBNYXRoLm1heCh0aGlzLm1pbmltdW1BbGxvd2VkWm9vbUxldmVsLCBuZXdab29tTGV2ZWwpO1xuICAgIG5ld1pvb21MZXZlbCA9IE1hdGgubWluKHRoaXMuY29uZmlnLnpvb21MZXZlbHMgLSAxLCBuZXdab29tTGV2ZWwpO1xuICAgIC8vIGNvbnNvbGUubG9nKCduZXdab29tTGV2ZWw6JywgbmV3Wm9vbUxldmVsKTtcblxuICAgIGxldCBkZWx0YVpvb21MZXZlbCA9IG5ld1pvb21MZXZlbCAtIHRoaXMuYmFzZS56b29tTGV2ZWw7IC8vIGRlbHRhWm9vbUxldmVsIGlzIHRoZSBudW1iZXIgb2Ygem9vbSBsZXZlbHMgd2UgYXJlIGNoYW5naW5nIGhlcmVcbiAgICBpZiAoIWRlbHRhWm9vbUxldmVsKSB7XG4gICAgICAvLyBhIGRlbHRhWm9vbUxldmVsIG9mIHplcm8gbWVhbnMgdGhhdCB3ZSBhcmVuJ3QgY2hhbmdpbmcgem9vbSwgYmVjYXVzZSB3ZSdyZSBlaXRoZXIgem9vbWVkIGFsbCB0aGUgd2F5IGluIG9yIGFsbCB0aGUgd2F5IG91dFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gTGV0IHAgYmUgdGhlIHZlY3RvciB0byB0aGUgY2xpY2tlZCBwb2ludCBpbiB2aWV3IGNvb3JkcyBhbmQgbGV0IHAnIGJlIHRoZSBzYW1lIHBvaW50IGluIG1vZGVsIGNvb3Jkcy4gTGV0IHMgYmUgYSBzY2FsZSBmYWN0b3JcbiAgICAvLyBhbmQgbGV0IHQgYmUgYSB0cmFuc2xhdGlvbiB2ZWN0b3IuIExldCB0aGUgdHJhbnNmb3JtYXRpb24gYmUgZGVmaW5lZCBhczpcbiAgICAvL1xuICAgIC8vICBwJyA9IHAgKiBzICsgdFxuICAgIC8vXG4gICAgLy8gQW5kIGNvbnZlcnNlbHk6XG4gICAgLy9cbiAgICAvLyAgcCA9ICgxL3MpKHAnIC0gdClcbiAgICAvL1xuICAgIC8vIE5vdyB1c2Ugc3Vic2NyaXB0aW9uIDAgdG8gZGVub3RlIHRoZSB2YWx1ZSBiZWZvcmUgdHJhbnNmb3JtIGFuZCB6b29tIGFuZCBsZXQgMSBkZW5vdGUgdGhlIHZhbHVlIGFmdGVyIHRyYW5zZm9ybS4gU2NhbGVcbiAgICAvLyBjaGFuZ2VzIGZyb20gczAgdG8gczEuIFRyYW5zbGF0aW9uIGNoYW5nZXMgZnJvbSB0MCB0byB0MS4gQnV0IGtlZXAgcCBhbmQgcCcgZml4ZWQgc28gdGhhdCB0aGUgdmlldyBjb29yZGluYXRlIHAnIHN0aWxsXG4gICAgLy8gY29ycmVzcG9uZHMgdG8gdGhlIG1vZGVsIGNvb3JkaW5hdGUgcC4gVGhpcyBjYW4gYmUgZXhwcmVzc2VkIGFzIGFuIGVxdWF0aW9uIHJlbHlpbmcgdXBvbiBzb2xlbHkgdXBvbiBwJywgczAsIHMxLCB0MCwgYW5kIHQxOlxuICAgIC8vXG4gICAgLy8gICgxL3MwKShwIC0gdDApID0gKDEvczEpKHAgLSB0MSlcbiAgICAvL1xuICAgIC8vIEV2ZXJ5IHZhcmlhYmxlIGJ1dCB0MSBpcyBrbm93biwgdGh1cyBpdCBpcyBlYXNpbHkgaXNvbGF0ZWQgdG86XG4gICAgLy9cbiAgICAvLyAgdDEgPSBwJyAtIChzMS9zMCkqKHAnIC0gdDApXG4gICAgLy9cblxuICAgIGxldCBjdXJyZW50UGFuOiBQb2ludCA9IHtcbiAgICAgIC8vIHQwIC0gdGhlIGN1cnJlbnQgYmFzZSBjb29yZGluYXRlc1xuICAgICAgeDogdGhpcy5iYXNlLnBhbi54LFxuICAgICAgeTogdGhpcy5iYXNlLnBhbi55XG4gICAgfTtcblxuICAgIGxldCBjdXJyZW50U2NhbGUgPSB0aGlzLnNjYWxlOyAvLyBzMCAtIGdldCB0aGUgY3VycmVudCBDU1Mgc2NhbGUgKHNjYWxlMClcbiAgICBsZXQgZGVzdFBvaW50ID0gY2xpY2tQb2ludCB8fCB0aGlzLmdldENlbnRlclBvaW50KCk7IC8vIHBtYXJrIC0gdGhlIHBvaW50IHdlIGFyZSBhaW1pbmcgdG8gem9vbSB0byAoZWl0aGVyIHRoZSBjbGljayBwb2ludCBvciB0aGUgY2VudHJlIG9mIHRoZSBwYWdlKVxuXG5cbiAgICBsZXQgcGFuU3RlcEZ1bmMgPSAoem9vbUxldmVsOiBudW1iZXIpID0+IHtcbiAgICAgIC8vIHRoaXMgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgZHVyaW5nIGV2ZXJ5IGFuaW1hdGlvbiB0aWNrLCB0byBjYWxjdWxhdGUgd2hlcmUgdG8gbW92ZSB0aGUgbW9kZWwgcGFuIGNvb3JkaW5hdGVzIHRvIChpLmUuIHRoZSB0cmFuc2xhdGlvbikgZm9yIHRoYXQgdGljaywgd2hlcmUgem9vbUxldmVsIGlzIGNhbGN1bGF0ZWQgZnJvbSB0aGUgY3VycmVudCB6b29tTGV2ZWwgKyB0aGUgdGFyZ2V0IHpvb21MZXZlbCAqIHRoZSBwcm9ncmVzcyBvZiB0aGUgY3VycmVudCBhbmltYXRpb25cblxuICAgICAgbGV0IHRhcmdldFNjYWxlID0gdGhpcy5nZXRDc3NTY2FsZSh6b29tTGV2ZWwpOyAvLyBzMSAtIHRoZSBzY2FsZSB0byB0cmFuc2xhdGUgdG8gZm9yIHRoZSBjdXJyZW50IGFuaW1hdGlvbiB0aWNrXG4gICAgICBsZXQgdGFyZ2V0UG9pbnQ6IFBvaW50ID0ge1xuICAgICAgICAvLyB0MSAtIFRoZSB0YXJnZXQgcG9pbnQgdG8gcGFuIHRvLiAgSXQgbXVzdCBzdGF5IHRoZSBzYW1lIGFzIHRoZSB1bnRyYW5zbGF0ZWQgcG9pbnRcbiAgICAgICAgeDogZGVzdFBvaW50LnggLSAodGFyZ2V0U2NhbGUgLyBjdXJyZW50U2NhbGUpICogKGRlc3RQb2ludC54IC0gY3VycmVudFBhbi54KSxcbiAgICAgICAgeTogZGVzdFBvaW50LnkgLSAodGFyZ2V0U2NhbGUgLyBjdXJyZW50U2NhbGUpICogKGRlc3RQb2ludC55IC0gY3VycmVudFBhbi55KVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gbm93IHJldHVybiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG91ciBpbml0aWFsIGNsaWNrIHBvaW50IGFuZCBvdXIgdHJhbnNsYXRlZCAoem9vbWVkKSBjbGljayBwb2ludFxuICAgICAgICAvLyB0aGVzZSBhcmUgbm90IGFic29sdXRlIGNvb3JkaW5hdGVzIC0ganVzdCBob3cgZmFyIHRvIG1vdmUgdGhlbVxuICAgICAgICB4OiB0YXJnZXRQb2ludC54IC0gY3VycmVudFBhbi54LFxuICAgICAgICB5OiB0YXJnZXRQb2ludC55IC0gY3VycmVudFBhbi55XG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBub3cgc2V0IHRoZSBwYXJhbWV0ZXJzIG9mIG91ciBuZXcgYW5pbWF0aW9uXG4gICAgdGhpcy5hbmltYXRpb25QYXJhbXMgPSB7XG4gICAgICBkZWx0YVpvb21MZXZlbDogZGVsdGFab29tTGV2ZWwsIC8vIHRoZSBkZXN0aW5hdGlvbiB6b29tIGxldmVsIGZvciB0aGlzIHpvb20gb3BlcmF0aW9uICh3aGVuIHRoZSBhbmltYXRpb24gaXMgY29tcGxldGVkKVxuICAgICAgcGFuU3RlcEZ1bmM6IHBhblN0ZXBGdW5jLFxuICAgICAgLy8gZHVyYXRpb246IHRoaXMuY29uZmlnLnpvb21TdGVwRHVyYXRpb24sIC8vIGhvdyBsb25nIHRoZSBhbmltYXRpb24gc2hvdWxkIHRha2VcbiAgICAgIGR1cmF0aW9uOiB0aGlzLmNvbmZpZy56b29tU3RlcER1cmF0aW9uICogMTAwMCwgLy8gaG93IGxvbmcgdGhlIGFuaW1hdGlvbiBzaG91bGQgdGFrZVxuICAgICAgcHJvZ3Jlc3M6IDAuMFxuICAgIH07XG4gICAgdGhpcy5zdGFydEFuaW1hdGlvbigpO1xuXG4gIH1cblxuXG5cbn1cbiJdfQ==